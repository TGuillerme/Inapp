---
title: "The solution: Count homologies"
author: "Martin R. Smith"
date: "`r Sys.Date()`"
bibliography: [../References.bib, packages.bib]
csl: https://raw.githubusercontent.com/citation-style-language/styles/master/apa-old-doi-prefix.csl
output:
  html_document: default
  pdf_document: default
---

# A solution

```{r, echo=FALSE, message=FALSE}
library('ape')
library('Inapp')
ap<-c('Absent', 'Present')
rb <- c('Red', 'Blue')
orb <- c('', rb)
ia <- c('Inapplicable', 'Applicable')

setPar <- function (mfrow=c(1, 2)) par(mfrow=mfrow, mar=c(0.2, 0.2, 1, 0.2), oma=c(0,0,0,0), cex=0.7)

leafy <- '#7fbf7be0'
lilac <- '#af8dc3e0'

tree12 <- ape::read.tree(text='((((((a, b), c), d), E), F), (G, (H, (i, (j, (k, l))))));')
```

## Minimising homoplasy

A solution can be found if the goal of parsimony is recast not in terms of minimising the number of steps, but instead of minimising the amount of homoplasy in a tree.

De Laet has made this point before [@DeLaet2005,-@DeLaet2015], suggesting that a tree's score should be calculated as 

> Total score = Number of steps + Number of (additional) regions.

Practically, because the number of unavoidable regions is a function of a dataset and not of a tree, one could also count 

> Total score = Number of steps + Number of regions

which would be a constant number larger than the total score generated just counting additional regions; the absolute value of the score is not meaningful in itself and is not comparable between datasets, so the calculation method does not affect tree search.

The tree below gives an example of a tree in which a character in applicable in two regions (one more than the minimum possible, one) and one state change. 

```{r, echo=FALSE, fig.width=6, fig.height=5}
setPar(c(1,1))
vignettePlot(tree12, '1100----0000', na=TRUE, passes=0, state.labels=rb)
#nodelabels(node=17, pch=15, col='#7fbf7be0', cex=2.5)
#nodelabels(node=c(16, 21), pch=15, col='#af8dc3e0', cex=2.5)

edgelabels(edge=5, pch=15, col=leafy, cex=2.5)
edgelabels(edge=c(3, 16), pch=15, col=lilac, cex=2.5)

```

This score denotes two evolutionary observations that cannot be attributed to inheritance from a common ancestor: the blueness of tail in the blue tailed taxa (as the common ancestor inherited a red tail), and the redness of tail in the second region of the tree (as the common ancestor of all tail-bearing taxa did not itself have a tail, so tail colour could no be inherited).


### What does it take to denote separate regions?

It takes three inapplicable nodes (including tips) to force two regions of the tree to be separrated by an inapplicable region.

This can be estabilshed by imagining the Fitch optimisation of a separate character

> Applicability of the character of interest: (0), inapplicable; (1), applicable

In the case of tail colour, this applicability character has the same distribution as the presence / absence of the tail, but this is not necessarily the case (there may be a range of reasons to code a character as inapplicable).

In the tree shown above, the Fitch algorithm identifies two regions where the applicability character is unambiguously 'applicable':

```{r, echo=FALSE, fig.width=6, fig.height=5}
setPar(c(1,1))
vignettePlot(tree12, '111100001111', na=FALSE, passes=1:2, state.labels=ia, legend.pos='none')
```

If one of the inapplicable tips had instead been ambiguous, then the same distribution would arise:

```{r, echo=FALSE, fig.width=6, fig.height=5}
setPar(c(1,1))
vignettePlot(tree12, '111100?01111', na=FALSE, passes=1:2, state.labels=ia, legend.pos='none')
```

But if two were ambiguous, then the 'inapplicable' region could equally be interpreted, under the Fitch algorithm, as 'applicable' -- with the two inapplicable tips becoming inapplicable in the branches that led to them:

```{r, echo=FALSE, fig.width=6, fig.height=5}
setPar(c(1,1))
vignettePlot(tree12, '1111?0?01111', na=FALSE, passes=1:2, state.labels=ia, legend.pos='none')
```

The ambiguous region of this tree may parsimoniously be interpreted as applicable, and doing so increases the opportunity to attribute shared colours in the tail to common ancestry, this our algorithm chooses to interpret the region as applicable whereever it is parsimonious to do so.

Note that the three inapplicable tips necessary to define an inapplicable region must be in a contiguous region of the tree, separated from one another only by taxa whose applicability is ambiguous, in order for two applicable regions to be reconstructed as separate.

### How this fixes the problem

This overcomes the problem where steps cancould be avoided by inferring multiple innovations of a character:

```{r, echo=FALSE, fig.width=8, fig.height=8}
comb15 <- ape::read.tree(text="(((((a, c), d), e), f), (g, (i, (j, (v, (w, (x, (y, z))))))));")
comb5i <- ape::read.tree(text="(((((vv, c), d), yy), f), (g, (xx, (j, (k, (ww, (m, (n, zz))))))));")

char <- '0000000011111'
sub1 <- '--------12222'
sub2 <- '--------11222'
sub3 <- '--------11122'
sub4 <- '--------11122'
sub5 <- '--------11112'

setPar(c(3, 2))
par(oma=c(3,0,0,0))
Compare <- function (char.states, char.label, states.labels, top=FALSE) {
    vignettePlot(comb15, char.states, na=!top, 
                 passes=4 - (2 * top),
                 legend.pos='none', state.labels=states.labels)
    legend('topleft', char.label, bty='n')
    legend('bottomleft', pch=15, pt.cex=1.5, col=leafy, bty='n', "+1 step")
    if (top) title('Single gain of tail (total score = 6)')
    
    vignettePlot(comb5i, char.states, na=!top, 
                 passes=4 - (2 * top),
                 legend.pos='none', state.labels=states.labels)
    if (!top)legend('bottomleft', pch=15, pt.cex=1.5, col=lilac, bty='n', "+4 regions") 
    if (top) legend('bottomleft', pch=15, pt.cex=1.5, col=leafy, bty='n', "+5 steps") 
    if (top) title('Five gains of tail (total score = 25)')
        
}

Compare(char, 'Tail, presence', ap, TRUE)
Compare(sub1, 'Tail, colour', orb)
Compare(sub2, 'Tail, covering', c("", "Scaly", "Hairy"))
mtext("\n... and for three more characters", outer=TRUE, side=1)
#Compare(sub3, 'Tail, shape', c("", "straight", "curly"))
#Compare(sub4, 'Tail, margin', c("", "smooth", "serrated"))
#Compare(sub5, 'Tail, poison barbs', c("", "absent", "present"))


```

On the other hand, if taxa either have a blue, scaly, straight tail or a red, smooth, curly tail, then the fact that the tails have so little in common means that it wouldn't be entirely surprising if the two different tail types evolved twice.  This scenario thus incurs a cost of only one step (for the additional origin of the tail) more than if the tail evolved once, and change all its attributes:

```{r, echo=FALSE, fig.width=8, fig.height=8}
comb15 <- ape::read.tree(text="(((((a, c), d), e), f), (g, (i, (j, (v, (w, (x, (y, z))))))));")
comb5i <- ape::read.tree(text="(((((xx, yy), zz), a), b), (c, (d, (e, (f, (g, (h, (vv, ww))))))));")

char <- '0000000011111'
sub1 <- '--------11222'

setPar(c(3, 2))
par(oma=c(3,0,0,0))
Compare <- function (char.states, char.label, states.labels, top=FALSE) {
    vignettePlot(comb15, char.states, na=!top, 
                 passes=4 - (2 * top),
                 legend.pos='none', state.labels=states.labels)
    legend('topleft', char.label, bty='n')
    legend('bottomleft', pch=15, pt.cex=1.5, col=leafy, bty='n', "+1 step")
    if (top) title('Single gain of tail (total score = 6)')
    
    vignettePlot(comb5i, char.states, na=!top, 
                 passes=4 - (2 * top),
                 legend.pos='none', state.labels=states.labels)
    if (!top)legend('bottomleft', pch=15, pt.cex=1.5, col=lilac, bty='n', "+1 region") 
    if (top) legend('bottomleft', pch=15, pt.cex=1.5, col=leafy, bty='n', "+2 steps") 
    if (top) title('Two gains of tail (total score = 7)')
        
}

Compare(char, 'Tail, presence', ap, TRUE)
Compare(sub1, 'Tail, colour', orb)
Compare(sub2, 'Tail, covering', c("", "Scaly", "Hairy"))
mtext("\n... and for n more characters", outer=TRUE, side=1)
#Compare(sub3, 'Tail, shape', c("", "straight", "curly"))
#Compare(sub4, 'Tail, margin', c("", "smooth", "serrated"))
#Compare(sub5, 'Tail, poison barbs', c("", "absent", "present"))


```

### Summary

This is the desired behaviour.  But how do we count this in practice?

In brief, we evaluate for each tip whether the character in question is applicable, inapplicable, or ambiguous (could be either), and use the standard Fitch algorithm on this applicability data to reconstruct the state of each internal node, reconstructing ambiguous nodes on the uppass as applicable.

This done, we conduct a second Fitch-like pass on the tree, in which we count transformations if they occur at nodes in which the character has been reconstructed as applicable.  Additional regions are also counted on this downpass, by counting nodes that are ancestral to an inapplicable region of the tree that itself leads to an as-yet-uncounted applicable region.
