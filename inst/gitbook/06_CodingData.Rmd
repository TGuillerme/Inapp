---
title: "Implications for character coding"
author: "Martin R. Smith"
date: "`r Sys.Date()`"
bibliography: [References.bib, packages.bib]
csl: https://raw.githubusercontent.com/citation-style-language/styles/master/apa-old-doi-prefix.csl
output:
  html_document: default
  pdf_document: default
---



```{r, message=FALSE, include=FALSE}
library('knitr'); library('Inapp')
quickPlot <- function (tree, character, na=TRUE, legend.pos='bottomleft') {
  tree$edge.length <- rep(1, dim(tree$edge)[1])
  reconstruction <- apply.reconstruction(tree, character, 
                            method=if(na) "NA" else 'Fitch',
                            match.tip.char=TRUE)
  dev.new(); plot(tree, direction='upwards'); corners <- par('usr'); dev.off()
  plot(reconstruction,
       passes=if(na) 1:4 else 1:2, counts=1:2, 
       direction='upwards', legend.pos=legend.pos,
       col.states=TRUE, use.edge.length=TRUE, 
       x.lim=c(-3, corners[2]), y.lim=c(-1, corners[4]+0.1))
}
setPar <- function (mfrow=c(1, 2)) par(mfrow=mfrow, mar=c(0.2, 0.2, 0.66, 0.2), oma=c(1,0,0,0), cex=0.7)

ap <- c("Absent", "Present")
rb <- c("Red", "Blue")
```

## Inapplicable data in a parsimony setting

This is one of a [series](Index.html) of vignettes that works through the inapplicable algorithm proposed by Brazeau _et al._ [-@ThisStudy].

We assume that you'll already have read the [description](OurAlgorithm.html) of our algorithm.

### How this algorithm weights against multiple innovations

We discussed in an [earlier vignette](FailedSolutions.html) that, if we only 
penalise transformations between states in subsidiary characters, 
trees that imply multiple origins of the parent character receive much lower scores
than those in which the parent character evolves once (but its subsidiary characteristics
change multiple times).

Our algorithm counterbalances this by, in effect, imposing a cost for each additional
origin of the parent character.  At first blush, this sounds like it is weighting
against multiple innovations of the parent character -- but this isn't so; it
weights against multiple independent innovations of the SAME state (i.e. homoplasy),
but if a red tail evolved here and a blue tail evolved there, then two innovations of the 
tail imposes a cost of one (additional region) for tail colour, whereas a single innovation of the tail would also impose a cost of one (transformation) for tail colour.
The additional origin of the tail can

- This has a side-effect that we'll study with an invariant character

### Multiple dependencies

It's not a problem to have characters dependent on characters that are dependent
on characters.  Consider the following character heirarchy:

  1. Appendages: (0), absent; (1), present.
  2. Appendage termination: (0), blunt; (1), claw; (2), sucker.
  3. Claw morphology: (0), smooth; (1), serrated.
  4. Sucker morphology: (0), round; (1), polygonal.

The included taxa may or may not bear appendages; if they do, then the 
appendages may end either with either claws or suckers, or neither (but not both).
Claws come in two flavours, smooth and serrated; suckers come in two shapes,
rounded and polygonal.

If character 1 (appendages) is absent, then characters 2--4 are inapplicable.
Otherwise, charcter 2 (appendage termination) must take one of the three applicable values.

If character 2 (termination) has state 0 (blunt), then characters 3 and 4 
(morphology of claw / sucker) are inapplicable.

If character 2 (termination) has state 1 (claw), then character 3
(claw morphology) is applicable and character 4 (sucker morphology) is inapplicable.

If character 2 (termination) has state 2 (sucker), then character 3 
(claw morphology) is inapplicable and character 4 (sucker morphology) is 
applicable.

A sample character matrix might look like this:

```{r, echo=FALSE, asis=TRUE}
nNone <- 3
c1 <- c(rep(0, nNone), rep(1, 10))
c2 <- c(rep('-', nNone), rep(0, 2), rep(1, 4), rep(2, 4))
c3 <- c(rep('-', nNone + 2), 0, 0, 1, 1, rep('-', 4))
c4 <- c(rep('-', nNone + 2 + 4), 0, 0, 1, 1)
mDep <- matrix(c(c1, c2, c3, c4), byrow=TRUE, ncol=length(c1))
colnames(mDep) <- LETTERS[seq_along(c1)]
rownames(mDep) <- c("Appendages: (0), absent; (1), present.",
                    "Appendage termination: (0), blunt; (1), claw; (2), sucker.",
                    "Claw morphology: (0), smooth; (1), serrated.", 
                    "Sucker morphology: (0), round; (1), polygonal.")
kable(mDep, capiton="Coding")
```

Which would plot on a tree thus:

```{r, echo=FALSE, fig.width=8, fig.height=16}
goodtree <- ape::read.tree(text="(a, (b, (c, ((d, e), ((f, (g, (h, i))), ((j, k), (l, m)))))));")
badtree <- ape::read.tree(text="(A, (C, (B, ((D, E), ((F, (J, (K, I))), ((G, H), (L, M)))))));")
par(mfrow=c(4, 2), cex=0.7, mar=c(0, 0.2, 0.6, 0.2), oma=c(0, 0, 2, 0))

Contrast <- function (character, char.label, states.labels, y=0, header=FALSE) {
    vignettePlot(goodtree, character, na=!header, 
                 legend.pos='topleft', state.labels=states.labels)
    text(14, y, char.label, pos=2)
    ape::tiplabels(LETTERS[1:13], frame='none', adj=c(0.5, -1.5))
    if (header) title("An optimal tree")
    vignettePlot(badtree, character, na=!header, 
                 legend.pos='topleft', state.labels=states.labels)
    text(14, y, char.label, pos=2)
    ape::tiplabels(badtree$tip.label, frame='none', adj=c(0.5, -1.5))
    if (header) title("A suboptimal tree")
    
}

Contrast('0001111111111', "Appendages:", c('absent', 'present'), header=TRUE)
Contrast('---0011112222', "Appendage termination:", c("blunt", "claw", "sucker"), y=1.5)
Contrast('-----0011----', "Claw morphology:", c("smooth", "serrated"), y=0.5)
Contrast('---------0011', "Sucker morphology:", c("round", "polygonal"), y=0.5)
mtext("Appendage condition", outer=TRUE)

```



### A parsimony uninformative character that informs parsimony!

- All tails are blue.  Let's say that they are all blue for some complex molecular reason, such that it is most parsimonious if "blueness" has a single evolutionary origin.

```{r tail colour characters, echo = FALSE, results='asis'}
tail <- c(0, 0, 0, 0, 1, 1, 1, 1)
col <- c(rep('-', 4), rep(1, 4))
bcol <- c(1,1, 2,2,2,2, 1,1)
blueTails <- matrix(c(tail, col, bcol), byrow=TRUE, ncol=length(tail))
colnames(blueTails) <- LETTERS[seq_along(tail)]
rownames(blueTails) <- c("Tail: (0), absent; (1), present",
                         "Tail colour: (-), inapplicable; (1), blue",
                         "Body colour: (1), black; (2), white")
kable(blueTails, capiton="Coding")
```

- This complex molecular reason is grounds to suspect that the tails have a common ancestor
- More formally, we wish to attribute this complex molecular reason to common ancestry, rather than homoplasy
- Thus "blueness" represents a separate character that has the same distribution as tails (or a sbuset thereof, if some tails are of uncertain colour)

Let's compare two trees.  One groups taxa based on the presence of tails; the other
groups taxa based on body colour.

```{r, echo=FALSE, fig.height=3, fig.width=8}
tailTree <- ape::read.tree(text="((((A:1, B:1):1, C:1):1, D:1):1, (E:1, (F:1, (G:1, H:1):1):1):1);")
bodyTree <- ape::read.tree(text="((((F, E), C), D), (A, (B, (G, H))));")
tail <- "00001111"
col <- "----1111"
bcol <- "11222211"

par(mfrow=c(1, 2), mar=c(0, 0.2, 0.2, 0.2), oma=c(0, 0, 2, 0), cex=0.8)
quickPlot(tailTree, tail, FALSE)
quickPlot(bodyTree, tail, FALSE)
mtext("Tail presence", outer=TRUE)


quickPlot(tailTree, col)
quickPlot(bodyTree, col)
mtext("Tail colour", outer=TRUE)

quickPlot(tailTree, bcol, FALSE)
quickPlot(bodyTree, bcol, FALSE)
mtext("Body colour", outer=TRUE)
```

- So the tree on the left, which reconstructs a single origin of the tail, a single origin of a blue tail colouration, and two changes in body colour, is preferred to the tree on the right, which reconstructs a single change in body colour but two origins of the tail, and two origins of blue colouration on the tail.

- We should include this character if it's meaningful.  But not if it's not (e.g. number of base pairs in a tail).


#### Difficulties
<mark>Here are some marginal cases where discretion is required.</mark>

<mark>Here are some trees that show why we would code things our way
this is why you need to look at your data carefully and see whether you like what your mode of coding is implying!</mark>