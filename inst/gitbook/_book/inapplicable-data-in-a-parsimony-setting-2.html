<!DOCTYPE html>
<html >

<head>

  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>The Fitch Algorithm</title>
  <meta name="description" content="Inapplicable data in a parsimony setting">
  <meta name="generator" content="bookdown 0.4 and GitBook 2.6.7">

  <meta property="og:title" content="The Fitch Algorithm" />
  <meta property="og:type" content="book" />
  
  
  <meta property="og:description" content="Inapplicable data in a parsimony setting" />
  <meta name="github-repo" content="TGuillerme/Inapp" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="The Fitch Algorithm" />
  
  <meta name="twitter:description" content="Inapplicable data in a parsimony setting" />
  

<meta name="author" content="Thomas Guillerme">


<meta name="date" content="2018-03-05">

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  
  
<link rel="prev" href="inapplicable-data-in-a-parsimony-setting-1.html">
<link rel="next" href="ambiguity.html">
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />









<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>

<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="./">Inapplicable data in a parsimony setting</a></li>

<li class="divider"></li>
<li class="chapter" data-level="1" data-path="inapplicable-data-in-a-parsimony-setting.html"><a href="inapplicable-data-in-a-parsimony-setting.html"><i class="fa fa-check"></i><b>1</b> Inapplicable data in a parsimony setting</a><ul>
<li class="chapter" data-level="1.1" data-path="inapplicable-data-in-a-parsimony-setting.html"><a href="inapplicable-data-in-a-parsimony-setting.html#the-fitch-algorithm"><i class="fa fa-check"></i><b>1.1</b> The Fitch algorithm</a><ul>
<li class="chapter" data-level="1.1.1" data-path="inapplicable-data-in-a-parsimony-setting.html"><a href="inapplicable-data-in-a-parsimony-setting.html#downpass"><i class="fa fa-check"></i><b>1.1.1</b> Downpass</a></li>
<li class="chapter" data-level="1.1.2" data-path="inapplicable-data-in-a-parsimony-setting.html"><a href="inapplicable-data-in-a-parsimony-setting.html#uppass"><i class="fa fa-check"></i><b>1.1.2</b> Uppass</a></li>
<li class="chapter" data-level="1.1.3" data-path="inapplicable-data-in-a-parsimony-setting.html"><a href="inapplicable-data-in-a-parsimony-setting.html#discussion-how-to-optimise-characters"><i class="fa fa-check"></i><b>1.1.3</b> Discussion: How to optimise characters</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="2" data-path="problems-with-the-fitch-algorithm.html"><a href="problems-with-the-fitch-algorithm.html"><i class="fa fa-check"></i><b>2</b> Problems with the Fitch algorithm</a><ul>
<li class="chapter" data-level="2.1" data-path="problems-with-the-fitch-algorithm.html"><a href="problems-with-the-fitch-algorithm.html#red-tails-blue-tails"><i class="fa fa-check"></i><b>2.1</b> Red tails, blue tails</a></li>
<li class="chapter" data-level="2.2" data-path="problems-with-the-fitch-algorithm.html"><a href="problems-with-the-fitch-algorithm.html#why-reductive-coding-doesnt-work"><i class="fa fa-check"></i><b>2.2</b> Why Reductive coding doesn’t work</a><ul>
<li class="chapter" data-level="2.2.1" data-path="problems-with-the-fitch-algorithm.html"><a href="problems-with-the-fitch-algorithm.html#an-exception"><i class="fa fa-check"></i><b>2.2.1</b> An exception</a></li>
</ul></li>
<li class="chapter" data-level="2.3" data-path="problems-with-the-fitch-algorithm.html"><a href="problems-with-the-fitch-algorithm.html#why-extra-state-coding-doesnt-work"><i class="fa fa-check"></i><b>2.3</b> Why Extra State coding doesn’t work</a></li>
<li class="chapter" data-level="2.4" data-path="problems-with-the-fitch-algorithm.html"><a href="problems-with-the-fitch-algorithm.html#why-a-single-multi-state-character-doesnt-work"><i class="fa fa-check"></i><b>2.4</b> Why a single multi-state character doesn’t work</a></li>
<li class="chapter" data-level="2.5" data-path="problems-with-the-fitch-algorithm.html"><a href="problems-with-the-fitch-algorithm.html#sankoff-matrices"><i class="fa fa-check"></i><b>2.5</b> Sankoff matrices</a><ul>
<li class="chapter" data-level="2.5.1" data-path="problems-with-the-fitch-algorithm.html"><a href="problems-with-the-fitch-algorithm.html#symmetric"><i class="fa fa-check"></i><b>2.5.1</b> Symmetric</a></li>
<li class="chapter" data-level="2.5.2" data-path="problems-with-the-fitch-algorithm.html"><a href="problems-with-the-fitch-algorithm.html#gain-and-loss-asymmetric"><i class="fa fa-check"></i><b>2.5.2</b> Gain and loss asymmetric</a></li>
</ul></li>
<li class="chapter" data-level="2.6" data-path="problems-with-the-fitch-algorithm.html"><a href="problems-with-the-fitch-algorithm.html#conclusion"><i class="fa fa-check"></i><b>2.6</b> Conclusion</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="the-problem-with-counting-steps.html"><a href="the-problem-with-counting-steps.html"><i class="fa fa-check"></i><b>3</b> The problem with counting steps</a></li>
<li class="chapter" data-level="4" data-path="minimising-homoplasy.html"><a href="minimising-homoplasy.html"><i class="fa fa-check"></i><b>4</b> Minimising homoplasy</a><ul>
<li class="chapter" data-level="4.0.1" data-path="minimising-homoplasy.html"><a href="minimising-homoplasy.html#what-does-it-take-to-denote-separate-regions"><i class="fa fa-check"></i><b>4.0.1</b> What does it take to denote separate regions?</a></li>
<li class="chapter" data-level="4.1" data-path="minimising-homoplasy.html"><a href="minimising-homoplasy.html#how-this-fixes-the-problem"><i class="fa fa-check"></i><b>4.1</b> How this fixes the problem</a></li>
<li class="chapter" data-level="4.2" data-path="minimising-homoplasy.html"><a href="minimising-homoplasy.html#summary"><i class="fa fa-check"></i><b>4.2</b> Summary</a></li>
</ul></li>
<li class="chapter" data-level="5" data-path="inapplicable-data-in-a-parsimony-setting-1.html"><a href="inapplicable-data-in-a-parsimony-setting-1.html"><i class="fa fa-check"></i><b>5</b> Inapplicable data in a parsimony setting</a><ul>
<li class="chapter" data-level="5.1" data-path="inapplicable-data-in-a-parsimony-setting-1.html"><a href="inapplicable-data-in-a-parsimony-setting-1.html#implementation"><i class="fa fa-check"></i><b>5.1</b> Implementation</a><ul>
<li class="chapter" data-level="5.1.1" data-path="inapplicable-data-in-a-parsimony-setting-1.html"><a href="inapplicable-data-in-a-parsimony-setting-1.html#passes-1-2"><i class="fa fa-check"></i><b>5.1.1</b> Passes 1 &amp; 2</a></li>
<li class="chapter" data-level="5.1.2" data-path="inapplicable-data-in-a-parsimony-setting-1.html"><a href="inapplicable-data-in-a-parsimony-setting-1.html#pass-3"><i class="fa fa-check"></i><b>5.1.2</b> Pass 3</a></li>
<li class="chapter" data-level="5.1.3" data-path="inapplicable-data-in-a-parsimony-setting-1.html"><a href="inapplicable-data-in-a-parsimony-setting-1.html#pass-4"><i class="fa fa-check"></i><b>5.1.3</b> Pass 4</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="6" data-path="inapplicable-data-in-a-parsimony-setting-2.html"><a href="inapplicable-data-in-a-parsimony-setting-2.html"><i class="fa fa-check"></i><b>6</b> Inapplicable data in a parsimony setting</a><ul>
<li class="chapter" data-level="6.1" data-path="inapplicable-data-in-a-parsimony-setting-2.html"><a href="inapplicable-data-in-a-parsimony-setting-2.html#multiple-dependencies"><i class="fa fa-check"></i><b>6.1</b> Multiple dependencies</a></li>
<li class="chapter" data-level="6.2" data-path="inapplicable-data-in-a-parsimony-setting-2.html"><a href="inapplicable-data-in-a-parsimony-setting-2.html#invariant-characters-can-inform-parsimony"><i class="fa fa-check"></i><b>6.2</b> Invariant characters can inform parsimony</a></li>
<li class="chapter" data-level="6.3" data-path="inapplicable-data-in-a-parsimony-setting-2.html"><a href="inapplicable-data-in-a-parsimony-setting-2.html#variable-but-parsimony-uninformative-characters-can-inform-parsimony"><i class="fa fa-check"></i><b>6.3</b> Variable but ‘parsimony uninformative’ characters can inform parsimony</a></li>
<li class="chapter" data-level="6.4" data-path="inapplicable-data-in-a-parsimony-setting-2.html"><a href="inapplicable-data-in-a-parsimony-setting-2.html#this-may-not-be-desirable-in-neomorphic-characters"><i class="fa fa-check"></i><b>6.4</b> This may not be desirable in neomorphic characters</a><ul>
<li class="chapter" data-level="6.4.1" data-path="inapplicable-data-in-a-parsimony-setting-2.html"><a href="inapplicable-data-in-a-parsimony-setting-2.html#three-scenarios"><i class="fa fa-check"></i><b>6.4.1</b> Three scenarios</a></li>
<li class="chapter" data-level="6.4.2" data-path="inapplicable-data-in-a-parsimony-setting-2.html"><a href="inapplicable-data-in-a-parsimony-setting-2.html#does-absence-contain-phylogenetic-information"><i class="fa fa-check"></i><b>6.4.2</b> Does absence contain phylogenetic information?</a></li>
</ul></li>
<li class="chapter" data-level="6.5" data-path="inapplicable-data-in-a-parsimony-setting-2.html"><a href="inapplicable-data-in-a-parsimony-setting-2.html#coding-ontologically-dependent-neomorphic-characters"><i class="fa fa-check"></i><b>6.5</b> Coding ontologically dependent neomorphic characters</a><ul>
<li class="chapter" data-level="6.5.1" data-path="inapplicable-data-in-a-parsimony-setting-2.html"><a href="inapplicable-data-in-a-parsimony-setting-2.html#neomorphic-and-transformational-characters"><i class="fa fa-check"></i><b>6.5.1</b> Neomorphic and transformational characters</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="7" data-path="ambiguity.html"><a href="ambiguity.html"><i class="fa fa-check"></i><b>7</b> Ambiguity</a><ul>
<li class="chapter" data-level="7.1" data-path="ambiguity.html"><a href="ambiguity.html#ambiguity-when-parent-character-ambiguous"><i class="fa fa-check"></i><b>7.1</b> Ambiguity when parent character ambiguous</a></li>
<li class="chapter" data-level="7.2" data-path="ambiguity.html"><a href="ambiguity.html#ambiguity-when-parent-character-known"><i class="fa fa-check"></i><b>7.2</b> Ambiguity when parent character known</a><ul>
<li class="chapter" data-level="7.2.1" data-path="ambiguity.html"><a href="ambiguity.html#subordinate-character-has-finite-states"><i class="fa fa-check"></i><b>7.2.1</b> Subordinate character has finite states</a></li>
<li class="chapter" data-level="7.2.2" data-path="ambiguity.html"><a href="ambiguity.html#subordinate-character-may-have-unobserved-states"><i class="fa fa-check"></i><b>7.2.2</b> Subordinate character may have unobserved states</a></li>
</ul></li>
<li class="chapter" data-level="7.3" data-path="ambiguity.html"><a href="ambiguity.html#recommendation-1"><i class="fa fa-check"></i><b>7.3</b> Recommendation</a></li>
<li class="chapter" data-level="7.4" data-path="ambiguity.html"><a href="ambiguity.html#some-caterpillars"><i class="fa fa-check"></i><b>7.4</b> Some caterpillars</a><ul>
<li class="chapter" data-level="7.4.1" data-path="ambiguity.html"><a href="ambiguity.html#three-equally-suboptimal-alternatives"><i class="fa fa-check"></i><b>7.4.1</b> Three equally suboptimal alternatives</a></li>
<li class="chapter" data-level="7.4.2" data-path="ambiguity.html"><a href="ambiguity.html#a-better-caterpillar-tree"><i class="fa fa-check"></i><b>7.4.2</b> A better caterpillar tree</a></li>
</ul></li>
<li class="chapter" data-level="7.5" data-path="ambiguity.html"><a href="ambiguity.html#de-laets-caterpillars"><i class="fa fa-check"></i><b>7.5</b> De Laet’s caterpillars</a></li>
</ul></li>
<li class="chapter" data-level="" data-path="references.html"><a href="references.html"><i class="fa fa-check"></i>References</a></li>
<li class="chapter" data-level="8" data-path="inapplicable-data-in-a-parsimony-setting-3.html"><a href="inapplicable-data-in-a-parsimony-setting-3.html"><i class="fa fa-check"></i><b>8</b> Inapplicable data in a parsimony setting</a><ul>
<li class="chapter" data-level="8.1" data-path="inapplicable-data-in-a-parsimony-setting-3.html"><a href="inapplicable-data-in-a-parsimony-setting-3.html#the-packages"><i class="fa fa-check"></i><b>8.1</b> The packages</a></li>
</ul></li>
<li class="divider"></li>
<li><a href="https://github.com/TGuillerme/Inapp/" target="blank">Project GitHub page</a></li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">The Fitch Algorithm</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="inapplicable-data-in-a-parsimony-setting-2" class="section level1">
<h1><span class="header-section-number">6</span> Inapplicable data in a parsimony setting</h1>
<p>This is one of a <a href="Index.html">series</a> of vignettes that works through the inapplicable algorithm proposed by Brazeau <em>et al.</em> <span class="citation">(<a href="#ref-ThisStudy">2017</a>)</span>.</p>
<p>We assume that you’ll already have read the <a href="OurAlgorithm.html">description</a> of our algorithm.</p>
<div id="multiple-dependencies" class="section level2">
<h2><span class="header-section-number">6.1</span> Multiple dependencies</h2>
<p>It’s not a problem to have characters dependent on characters that are dependent on characters. Consider the following characters, whose descriptions are written in order to emphasize their heirarchical nature <span class="citation">(following the recommendations of Sereno, <a href="#ref-Sereno2007">2007</a>)</span>:</p>
<ol style="list-style-type: decimal">
<li>Appendages: (0), absent; (1), present.</li>
<li>Appendages, termination: (0), blunt; (1), sucker; (2), claw.</li>
<li>Appendages, suckers, morphology: (0), round; (1), polygonal.</li>
<li>Appendages, claws, morphology: (0), smooth; (1), serrated.</li>
</ol>
<p>The included taxa may or may not bear appendages; if they do, then the appendages may end either with either claws or suckers, or neither (but not both). Claws come in two flavours, smooth and serrated; suckers come in two shapes, rounded and polygonal.</p>
<p>If character 1 (appendages) is absent, then characters 2–4 are inapplicable. Otherwise, charcter 2 (appendage termination) must take one of the three applicable values.</p>
<p>If character 2 (termination) has state 0 (blunt), then characters 3 and 4 (morphology of sucker / claw) are inapplicable.</p>
<p>If character 2 (termination) has state 1 (sucker), then character 3 (sucker morphology) is applicable and character 4 (claw morphology) is inapplicable.</p>
<p>If character 2 (termination) has state 2 (claw), then character 3 (sucker morphology) is inapplicable and character 4 (claw morphology) is applicable.</p>
<p>A sample character matrix might look like this:</p>
<table>
<thead>
<tr class="header">
<th></th>
<th align="left">A</th>
<th align="left">B</th>
<th align="left">C</th>
<th align="left">D</th>
<th align="left">E</th>
<th align="left">F</th>
<th align="left">G</th>
<th align="left">H</th>
<th align="left">I</th>
<th align="left">J</th>
<th align="left">K</th>
<th align="left">L</th>
<th align="left">M</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Appendages: (0), absent; (1), present.</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr class="even">
<td>Appendage termination: (1), blunt; (2), sucker; (3), claw.</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">2</td>
<td align="left">2</td>
<td align="left">2</td>
<td align="left">2</td>
<td align="left">3</td>
<td align="left">3</td>
<td align="left">3</td>
<td align="left">3</td>
</tr>
<tr class="odd">
<td>Sucker morphology: (1), smooth; (2), serrated.</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">2</td>
<td align="left">2</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">-</td>
</tr>
<tr class="even">
<td>Claw morphology: (1), round; (2), polygonal.</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">2</td>
<td align="left">2</td>
</tr>
</tbody>
</table>
<p>Which would plot on a tree thus:</p>
<p><img src="Inapplicable_data_files/figure-html/unnamed-chunk-38-1.png" width="768" /></p>
<p>There’s no limit to the depth of recursion: one could add a further character</p>
<ol start="5" style="list-style-type: decimal">
<li>Appendages, claws, serrations, spacing: (1), regular; (2), irregular.</li>
</ol>
<p>that would be inapplicable in all taxa that lacked serrated claws.</p>
<p><img src="Inapplicable_data_files/figure-html/unnamed-chunk-39-1.png" width="768" /></p>
<p>To readers familiar with standard Fitch parsimony, it will be surprising to notice that the two trees receive a different score for this invariant character. When our algorithm is employed, invariant characters that contain inapplicable tokens can inform parsimony.</p>
</div>
<div id="invariant-characters-can-inform-parsimony" class="section level2">
<h2><span class="header-section-number">6.2</span> Invariant characters can inform parsimony</h2>
<p>Consider a situation in which every tail in the observed taxa is blue – but the same complex molecular machinery is responsible for this blue colouration in every taxon.</p>
<p>If its underlying mechanism is considered biologically and evolutionarily meaningful, then a systematist might opt to include tail colour as an additional character, even though it is invariant in the taxa of interest. Reconstructions that attribute this common colouration to common ancestry will be more parsimonious than those that do not.</p>
<table>
<thead>
<tr class="header">
<th></th>
<th align="left">A</th>
<th align="left">B</th>
<th align="left">C</th>
<th align="left">D</th>
<th align="left">E</th>
<th align="left">F</th>
<th align="left">G</th>
<th align="left">H</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Tail: (0), absent; (1), present</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr class="even">
<td>Tail colour: (1), blue; (-), inapplicable</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr class="odd">
<td>Body colour: (1), black; (2), white</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">2</td>
<td align="left">2</td>
<td align="left">2</td>
<td align="left">2</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
</tbody>
</table>
<p>Let’s compare two trees. The first groups taxa based on the presence of tails; the other groups taxa based on body colour.</p>
<p><img src="Inapplicable_data_files/figure-html/unnamed-chunk-41-1.png" width="768" /><img src="Inapplicable_data_files/figure-html/unnamed-chunk-41-2.png" width="768" /><img src="Inapplicable_data_files/figure-html/unnamed-chunk-41-3.png" width="768" /></p>
<p>Where the tail has a single origin (one step), blue colouration also evolves once (zero steps), but body colour must change twice (two steps; total score = three). But where body colour changes only once (one step), the tail necessarily arises twice (two steps), meaning two independent origins of its distinctive blue colouration (one extra homoplasy; total score = four)</p>
<p>If the invariant tail colour character had not been included, both trees would have the same score, and there would be nothing to choose between them. As such, the inclusion or exclusion of invariant characters must be carefully evaluated: if there is a case that an invariant (ontologically dependent) character implies an exclusive common ancestry between those taxa that share it, then it should be included; if not, then it should be excluded.</p>
</div>
<div id="variable-but-parsimony-uninformative-characters-can-inform-parsimony" class="section level2">
<h2><span class="header-section-number">6.3</span> Variable but ‘parsimony uninformative’ characters can inform parsimony</h2>
<p>The same effect of course follows if a character has an additional state that is only observed in one taxon.</p>
<table>
<thead>
<tr class="header">
<th></th>
<th align="left">A</th>
<th align="left">B</th>
<th align="left">C</th>
<th align="left">D</th>
<th align="left">E</th>
<th align="left">F</th>
<th align="left">G</th>
<th align="left">H</th>
<th align="left">I</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Tail: (0), absent; (1), present</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr class="even">
<td>Tail colour: (1), red; (2), blue; (-), inapplicable</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left"><strong>2</strong></td>
</tr>
<tr class="odd">
<td>Body colour: (1), black; (2), white</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">2</td>
<td align="left">2</td>
<td align="left">2</td>
<td align="left">2</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
</tbody>
</table>
<p>Any tree that implies that blueness evolves multiple times will incur an additional penalty that would not have been encountered had the tail colour character been omitted.</p>
<p><img src="Inapplicable_data_files/figure-html/unnamed-chunk-43-1.png" width="768" /></p>
</div>
<div id="this-may-not-be-desirable-in-neomorphic-characters" class="section level2">
<h2><span class="header-section-number">6.4</span> This may not be desirable in neomorphic characters</h2>
<p>The more general rule is that any tree that reconstructs the same state arising twice, independently, in an ontologically dependent character will incur a penalty relative to one that reconstructs that same state arising once.</p>
<p>With transformational characters, this is often a desideratum – as discussed above.</p>
<p>In particular neomorphic characters, however, it may not be desirable to penalise trees in which the <em>absence</em> of a character arises multiple times.</p>
<p>Let us imagine that there is a biological reason to believe that tails in a particular group lacked poisoned barbs when they first evolved: that is, poisoned barbs are an evolutionary innovation that can only be added to a tail once a tail is already present.</p>
<table>
<thead>
<tr class="header">
<th></th>
<th align="left">A</th>
<th align="left">B</th>
<th align="left">C</th>
<th align="left">D</th>
<th align="left">E</th>
<th align="left">F</th>
<th align="left">G</th>
<th align="left">H</th>
<th align="left">I</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Tail: (0), absent; (1), present</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr class="even">
<td>Tail, poison barbs: (-), inapplicable; (0), absent; (1), present</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
</tbody>
</table>
<div id="three-scenarios" class="section level3">
<h3><span class="header-section-number">6.4.1</span> Three scenarios</h3>
<p>The presence of poison barbs obviously contains grouping information – a reconstruction that attribute the presence of posion barbs to a single evolutionary gain in a common ancestor is parsimonious with respect to that character (even if it is less parsimonious with respect to another – e.g. the presence or absence of a tail).</p>
<p><img src="Inapplicable_data_files/figure-html/unnamed-chunk-46-1.png" width="576" /></p>
<p>Consider a reconstruction in which a tail evolved twice, and barbs evolved twice. Here, the duplicate origin of barbs (as well as the duplicate origin of the tail) makes this reconstruction less parsimonious.</p>
<p><img src="Inapplicable_data_files/figure-html/unnamed-chunk-47-1.png" width="576" /></p>
<p>But what about a situation in which a tail evolved twice, and lacked barbs each time it evolved? Coding this character as transformational penalises the duplicate origin of the state “no poison barbs”, making this reconstruction less parsimonious.</p>
<p>If we expect a tail, when it evolves, to lack barbs, then the second origin of “no barbs” does not represent a homoplasy: it’s not a feature that has evolved twice, but rather an observation that something has <em>not</em> evolved twice.</p>
<p>The absence of poison barbs in the two ancestral tail-bearers has been inherited from a common ancestor that did not itself bear tail barbs (by virtue, in this instance, of not bearing a tail). This second non-origination should not, therefore, be penalized in this situation.</p>
<p><img src="Inapplicable_data_files/figure-html/unnamed-chunk-48-1.png" width="576" /></p>
<p>This problem has arisen because the inapplicable token has been used in a character that is, in fact, applicable.</p>
<p>The statement “A tail is absent; the tail is red” is not logically consistent, which is why the inapplicable token is necessary. In contrast, the statement “A tail is absent; tail barbs are absent” <em>is</em> logically consistent, and the inapplicable token is not necessary. Instead, the ‘absence’ token should be employed instead of the inapplicable:</p>
<p><img src="Inapplicable_data_files/figure-html/unnamed-chunk-49-1.png" width="576" /></p>
<p>The point here is that the inapplicable token ought only to be used in tips where a character description literally does not apply. As an example, De Laet <span class="citation">(De Laet, <a href="#ref-DeLaet2017">2017</a>)</span> contends that the character “Tail: absent/present” is inapplicable in an angiosperm. We disagree. Angiosperms do not have tails. “Tail”&quot; should be coded as absent in angiosperms.</p>
<p>One way to emphasize this distinction in character matrices is to reserve the <code>0</code> token to denote absence, and denoting states of transformational characters using the positive integers:</p>
<table>
<thead>
<tr class="header">
<th></th>
<th align="left">A</th>
<th align="left">B</th>
<th align="left">C</th>
<th align="left">D</th>
<th align="left">E</th>
<th align="left">F</th>
<th align="left">G</th>
<th align="left">H</th>
<th align="left">I</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Tail: (0), absent; (1), present</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr class="even">
<td>Tail, poison barbs: (0), absent; (1), present</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr class="odd">
<td>Tail, colour: (-), inapplicable; (1), red; (2), blue</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">2</td>
<td align="left">2</td>
<td align="left">2</td>
</tr>
</tbody>
</table>
<!--
#### Evaluation
It is possible that a researcher might feel uncomfortable grouping taxa on the basis of the non-occurrence of a complex feature that did not occur in their common ancestor.  Putting this another way, it is not clear that the fact that a feature has not evolved in two instances represents a homoplasy.  The absence of eyespots in a tail is not an evolutionary innovation -- it is an inheritance from a common ancestor that did not have eyespots (and did not have a tail).-->
<p>One implication of this coding strategy is that the loss of a tail (a single evolutionary event) causes the loss of all contintent characters – characters are not independent.</p>
<p><img src="Inapplicable_data_files/figure-html/unnamed-chunk-51-1.png" width="384" /></p>
<p>If a poisoned tail was present in a lineage, then lost, then re-gained, would one expect the re-gained tail to also re-gain its poisoned barbs? One could spend some time evaluating whether this behaviour has a biological underpinning, or whether it is desirable – is a reconstruction that invokes the loss of a complex tail more parsimonious than one that invokes the loss of a simple tail?</p>
<p>Indeed, it would be straightforwards to construct an algorithm that does not penalise losses where the loss corresponds to the inferred loss of a parent character.</p>
<p>The underlying issue, however, is that both parsimony and the Mk model assume character independence; it is perhaps more fruitful to focus effort on developing models of evolution that take proper account of character non-independence.</p>
</div>
<div id="does-absence-contain-phylogenetic-information" class="section level3">
<h3><span class="header-section-number">6.4.2</span> Does absence contain phylogenetic information?</h3>
<p>In some cases, the absence of a feature (e.g. serrations) may represent a transformational character and should thus be coded as such. But this decision is an important one and merits careful thought. A researcher may or may not be justified in including properties of a tail that occur in only one, or even in none, of the taxa of interest, for if absence is informative for parsimony, then such characters will influence tree topology: <a href="CodingData.html">parsimony uninformative characters inform parsimony</a>.</p>
<table>
<thead>
<tr class="header">
<th></th>
<th align="left">A</th>
<th align="left">B</th>
<th align="left">C</th>
<th align="left">D</th>
<th align="left">E</th>
<th align="left">F</th>
<th align="left">G</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Tail: (0), absent; (1), present</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr class="even">
<td>Tail, margin: (-), inapplicable; (1), smooth; (2), serrated</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">{12}</td>
<td align="left">{12}</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr class="odd">
<td>Tail, glow-in-the-dark pigment: (-), inapplicable; (1), absent; (2), present</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">{12}</td>
<td align="left">{12}</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr class="even">
<td>Tail, ability to generate electricity: (-), inapplicable; (1), absent; (2), present</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">{12}</td>
<td align="left">{12}</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
</tbody>
</table>
<p>Note that each of the unobserved characters provides evidence against independent origins of the tail, preferring instead independent losses:</p>
<p><img src="Inapplicable_data_files/figure-html/unnamed-chunk-53-1.png" width="768" /></p>
<p>Under the simple matrix presented above, the left-hand tree receives a score of five (two independent gains of the tail, plus the three ontologically dependent characters with an additional step each), whereas the right-hand tree scores but three (three independent losses of the tail; no steps in the ontologically dependent characters), making it more parsimonious.</p>
<p>If the three ontologically-dependent characters were coded as ‘absent’ (instead of inapplicable) when the tail was absent, then the left-hand tree would be preferred (with a score of 2 vs. 3).</p>
<p>The two trees are equally parsimonious (both scoring three) if tail margin is treated as a trasnformational character (inapplicable when tail absent) and the other characters are treated as neomorphic (absent when tail absent).</p>
<table>
<thead>
<tr class="header">
<th></th>
<th align="left">A</th>
<th align="left">B</th>
<th align="left">C</th>
<th align="left">D</th>
<th align="left">E</th>
<th align="left">F</th>
<th align="left">G</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Tail: (0), absent; (1), present</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr class="even">
<td>Tail, margin: (1), smooth; (2), serrated</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">{12}</td>
<td align="left">{12}</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr class="odd">
<td>Tail, glow-in-the-dark pigment: (-), inapplicable; (0), absent; (1), present</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">{01}</td>
<td align="left">{01}</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
<tr class="even">
<td>Tail, ability to generate electricity: (-), inapplicable; (0), absent; (1), present</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">{01}</td>
<td align="left">{01}</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
</tbody>
</table>

</div>
</div>
<div id="coding-ontologically-dependent-neomorphic-characters" class="section level2">
<h2><span class="header-section-number">6.5</span> Coding ontologically dependent neomorphic characters</h2>
<div id="neomorphic-and-transformational-characters" class="section level3">
<h3><span class="header-section-number">6.5.1</span> Neomorphic and transformational characters</h3>
<p>Researchers should be aware that our algorithm treats nemorphic characters as though they are transformational; that is, “absence” of a feature is seen as equally informative as “presence”.</p>
<p>In some cases, this may be desirable. One might argue that “Serrations on tail margin: (0), absent; (1), present” behaves as a transformational character, as a tail must have a margin of some sort, and “serratedness” is a property of the margin – perhaps there is no reason to assume that the tail was primitively simple, or that serrations necesssarily represent a secondary increase in complexity.</p>
<p>In other cases, this may not be desirable. As an example, consider a complex character, such as the eyespots on the tail of a peacock.</p>
<table>
<thead>
<tr class="header">
<th></th>
<th align="left">A</th>
<th align="left">B</th>
<th align="left">C</th>
<th align="left">D</th>
<th align="left">E</th>
<th align="left">F</th>
<th align="left">G</th>
<th align="left">H</th>
<th align="left">I</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Tail: (0), absent; (1), present</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr class="even">
<td>Tail eyespots: (-), inapplicable; (0), absent; (1), present</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
</tbody>
</table>
<p>The presence of tail eyespots obviously contains grouping information – we should prefer reconstructions that attribute the presence of tail eyespots to common ancestry to those that imply independent gains of this complex characteristic.</p>
<p>It is less obvious whether the <em>absence</em> of such complex features should convey grouping information. This decision ought to be defended for individual characters by individual researchers, but researchers should be aware of the implications of their chosen coding strategy.</p>
<div id="three-trees" class="section level4">
<h4><span class="header-section-number">6.5.1.1</span> Three trees</h4>
<p>Consider the following three scenarios:</p>
<p><img src="Inapplicable_data_files/figure-html/unnamed-chunk-57-1.png" width="576" /></p>
<p>Each of these trees implies two independent origins of the tail. Their score differs only with respect to the eyespots character.</p>
<div id="one-tail-spotted-one-not" class="section level5">
<h5><span class="header-section-number">6.5.1.1.1</span> One tail spotted, one not</h5>
<p>The first tree has the minimum possible score for the eyespots character. (A score of one would also be obtained if the tail evolved once, and a single transformation occurred between 0 and 1 – but we are only considering trees where the tail evolved twice.)</p>
</div>
<div id="two-spot-appearances" class="section level5">
<h5><span class="header-section-number">6.5.1.1.2</span> Two spot appearances</h5>
<p>The next tree has a score of two for the eyespots character, which is obviously correct: Eye spots, a complex character, have evolved twice independently, which is not as parsimonious.</p>
</div>
<div id="two-non-spotted-appearances" class="section level5">
<h5><span class="header-section-number">6.5.1.1.3</span> Two non-spotted appearances</h5>
<p>The final tree also has a score of two for the eyespots character: even though eyespots have only evolved once, just as in the first tree. The score of two occurs because the “absence of eyespots” has evolved twice.</p>
</div>
<div id="evaluation" class="section level5">
<h5><span class="header-section-number">6.5.1.1.4</span> Evaluation</h5>
<p>It is possible that a researcher might feel uncomfortable grouping taxa on the basis of the non-occurrence of a complex feature that did not occur in their common ancestor. Putting this another way, it is not clear that the fact that a feature has not evolved in two instances represents a homoplasy. The absence of eyespots in a tail is not an evolutionary innovation – it is an inheritance from a common ancestor that did not have eyespots (and did not have a tail).</p>
</div>
<div id="implications" class="section level5">
<h5><span class="header-section-number">6.5.1.1.5</span> Implications</h5>
<p>A researcher that argues that the absence of a feature contains phylogenetic information must surely include all properties of a tail that are only observed in a single taxon (because the absence of that feature in other taxa also contains grouping information). A researcher may also include all properties of a tail that do not occur in any of the taxa of interest, for these too will influence tree topology: <a href="CodingData.html">parsimony uninformative characters inform parsimony</a>.</p>
<table>
<thead>
<tr class="header">
<th></th>
<th align="left">A</th>
<th align="left">B</th>
<th align="left">C</th>
<th align="left">D</th>
<th align="left">E</th>
<th align="left">F</th>
<th align="left">G</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Tail: (0), absent; (1), present</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr class="even">
<td>Tail with glow-in-the-dark pigment: (-), inapplicable; (0), absent; (1), present</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">{01}</td>
<td align="left">{01}</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
<tr class="odd">
<td>Tail with ability to generate electricity: (-), inapplicable; (0), absent; (1), present</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">{01}</td>
<td align="left">{01}</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
</tbody>
</table>
<p>Note that each of the unobserved characters provides evidence against independent origins of the tail, preferring instead independent losses:</p>
<p><img src="Inapplicable_data_files/figure-html/unnamed-chunk-59-1.png" width="768" /></p>
<p><mark>Thus the simple matrix presented above sees both of these trees as equally parsimonious – three losses of a single-origin tail that lacks two unlikely attributes is considered as likely as one independent gain of a similar tail.</mark> <!-- I may need to tweak these trees--></p>
<p>This behaviour is desired if the similarity between the tails requires an evoltuionary explanation. But the absence of these features does not seem any more difficult to explain if the tails do not have a common ancestor.</p>
<p>The solution here is to deploy a different character coding strategy, coding absences as absences. That way, absence CAN be inherited from a common ancestor, in which a complex-feature-of-the-tail (eyespots, glow-inthe-dark pigment) was absent (and the tail was absent too).</p>
<table>
<thead>
<tr class="header">
<th></th>
<th align="left">A</th>
<th align="left">B</th>
<th align="left">C</th>
<th align="left">D</th>
<th align="left">E</th>
<th align="left">F</th>
<th align="left">G</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Tail: (0), absent; (1), present</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr class="even">
<td>Tail with glow-in-the-dark pigment: (-), inapplicable; (0), absent; (1), present</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">{01}</td>
<td align="left">{01}</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
<tr class="odd">
<td>Tail with ability to generate electricity: (-), inapplicable; (0), absent; (1), present</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">{01}</td>
<td align="left">{01}</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
</tbody>
</table>
<p>This can be handled by the Fitch algorithm, and works well in simple cases:</p>
<p><img src="Inapplicable_data_files/figure-html/unnamed-chunk-60-1.png" width="768" /></p>
<p>The behaviour only becomes questionable when a tail is secondarily lost, then re-gained, as the loss of a tail seems like it should be a single evolutionary step, but also causes the loss of all contingent characters, which must then “reevolve” as though they had never existed:</p>
<p><img src="Inapplicable_data_files/figure-html/unnamed-chunk-61-1.png" width="384" /></p>
<p>Perhaps there are cases – as might be seen in phenotypic plasticity – where a tail might be lost, and then re-activate preexisting genes when it evolves again? This starts to require an explicit model of evolution, however, which is somewhat beyond the remit of parsimony.</p>
</div>
</div>
<div id="recommendation" class="section level4">
<h4><span class="header-section-number">6.5.1.2</span> Recommendation</h4>
<ul>
<li>Neomorphic characters should probably be coded as absent everywhere they are absent, whether this is because there’s no tail or because there’s a tail without the complex feature.</li>
</ul>
<p>If you’re coding a neomorphic character as transformational, then you encounter problems.</p>
<p><img src="Inapplicable_data_files/figure-html/unnamed-chunk-62-1.png" width="576" /></p>

</div>
</div>
</div>
</div>
<h3>References</h3>
<div id="refs" class="references">
<div id="ref-ThisStudy">
<p>Brazeau, M. D., Guillerme, T., &amp; Smith, M. R. (2017). Morphological phylogenetic analysis with inapplicable data. <em>bioR<span class="math inline">\(\chi\)</span>iv</em>. doi:<a href="https://doi.org/10.1101/209775">10.1101/209775</a></p>
</div>
<div id="ref-Sereno2007">
<p>Sereno, P. C. (2007). Logical basis for morphological characters in phylogenetics. <em>Cladistics</em>, <em>23</em>(6), 565–587. doi:<a href="https://doi.org/10.1111/j.1096-0031.2007.00161.x">10.1111/j.1096-0031.2007.00161.x</a></p>
</div>
<div id="ref-DeLaet2017">
<p>De Laet, J. (2017). A note on brazeau et al.’s (2017) algorithm for characters with inapplicable data, illustrated with an analysis of their fig. 3d using anagallis, a program for parsimony analysis of character hierarchies. doi:<a href="https://doi.org/10.13140/RG.2.2.31309.54245">10.13140/RG.2.2.31309.54245</a></p>
</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="inapplicable-data-in-a-parsimony-setting-1.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="ambiguity.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script>
require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"google": false,
"weibo": false,
"instapper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": "https://github.com/TGuillerme/Inapp/inst/gitbook/edit/master/06_CodingData.Rmd",
"text": "Edit"
},
"download": null,
"toc": {
"collapse": "subsection"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:" && /^https?:/.test(script.src))
      script.src  = script.src.replace(/^https?:/, '');
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
