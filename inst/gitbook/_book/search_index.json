[
["index.html", "Inapplicable data 1 Inapplicable data in a parsimony setting 1.1 The packages", " Inapplicable data Martin Brazeau (m.brazeau@imperial.ac.uk), Thomas Guillerme (guillert@tcd.ie) and Martin Smith (martin.smith@durham.ac.uk) 2018-02-21 1 Inapplicable data in a parsimony setting This series of vignettes works through the inapplicable algorithm proposed by Brazeau et al. (2017). 1.1 The packages Illustration of the inapplicable algorithm is based on the Inapp R package. This package allows to visualise how the algorithm is counting the score of a tree for a given character with different algorithms treating inapplicable data differently. It allows users to input any tree and character. To actually perform tree search, pleas have a look at the inapplicable R package. This package is currently in development but allows some heuristic searches on reasonable sized matrices. Both these R packages are based on the morphylib C library that allows to score characters with inapplicable using our new algorithm. This library will be eventually implemented in Morphy, a fully functional C based API for phylogenetic searches. References "],
["the-fitch-algorithm.html", "2 The Fitch algorithm 2.1 Downpass 2.2 Uppass 2.3 Discussion: How to optimise characters 2.4 Problems with the Fitch algorithm 2.5 Conclusion 2.6 Counting steps is doomed", " 2 The Fitch algorithm This algorithm was proposed by Fitch (1971) and is implemented in many phylogenetic softwares based on maximum parsimony (Swofford, 2001,Goloboff &amp; Catalano (2016)) or probabilistic methods (Ronquist et al., 2012,Stamatakis (2014)). The procedure is rather simple and elegant and consist in going down the tree to count the number of transformation and then go up the tree again to finalise the ancestral states reconstructions. The way the algorithms goes up and down depends on the software but often uses a traversal: a recursive function that can visit all tips and nodes in a logical fashion. For example, consider the following tree: A downpass traversal will first apply the algorithm to the first cherry (or pair of taxa) (A below), then save the results in n1 and move to the second pair of tips/nodes (B), apply the algorithm and save the results in n2, etc. until all the nodes/tips are visited. An uppass traversal works identically but in the other way, going from the nodes to towards the tips. In both traversals, the direction (i.e. which cherry to pick first in a downpass traversal or whether to continue left or right in an uppass traversal) can be arbitrary as long as all tips and nodes are always visited. Now let’s consider a more complex tree ((((a, b), c), d), (e, (f, (g, h)))); with a binary character distributed for the tips 10011001 respectively to the tips alphabetical order. We can use the Inapp package to apply the Fitch algorithm for this character on this tree. ## Loading the Inapp package library(Inapp) ## The tree tree &lt;- read.tree(text = &quot;((((a, b), c), d), (e, (f, (g, h))));&quot;) ## The character character &lt;- &quot;10011001&quot; ## Applying the Fitch algorithm matrix &lt;- apply.reconstruction(tree, character, method = &quot;Fitch&quot;, passes = 2) 2.1 Downpass The downpass is quite simple and follows the following rules for the two possible cases in the traversal: If the two considered tips or nodes have at least one state in common, set the node to be these states in common. Else, if there is nothing in common between the to tips or nodes, set the node to be the union of the two states. For example, node n15 is case 2 because there is nothing in common between the tips h and g (respectively states 1 and 0). Node n14 is case 1 because there is at least one state in common between the tip f and the node n15 (state 0). Important: when the case 2 is encountered, a transformation is implied in the descendants of the considered node. The score of the tree is incremented by +1. In the following example, nodes that are in case one are in light orange and nodes that imply a transformation (i.e. that add to the tree score) are in blue. ## Plotting the first downpass plot.states.matrix(matrix, passes = 1, counts = 2, show.labels = c(1,2)) 2.2 Uppass The downpass is sufficient for calculating the score of the tree, but some nodes might node yet be properly resolved. For example, it seems clear that the sate of node n14 could not be 0 since both its ancestor and one of its descendants has an ambiguous state of 01. It would less parsimonious for this node to be also ambiguous (rather than implying the loss and the subsequent gain of the state 1 on the branch fron n13 to h). Similarly to the downpass, it is possible to run a traversal with the following rules: If the current node and its ancestor have all states in common, the node is resolved. If there is at least one state in common between both left and right tips or nodes directly descending from the current node, resolve the node as being the states in common between its ancestor and both his descendants. If there is there are no states in common between its descendants, resolve the node as being the states in common between the ancestor and the current node. For example, node n13 is already resolved (it has all its states in common with the ancestor - case 1). Node n14 has not all its states in common with its ancestor but its two descendants (n15 and f) have at least one state in common (0). This node is thus solved to be the states in common between both descendants (01) and its ancestor (01 as well). ## Plotting the first downpass plot.states.matrix(matrix, passes = c(1,2), counts = 2, show.labels = c(1,2)) More complex cases can be studied in the Inapp App (running in your favourite web browser) by switching the Reconstruction method to Normal Fitch. ## Running the Inapp App runInapp() 2.3 Discussion: How to optimise characters Acctran vs Deltran: Neither is guaranteed to always maximise homology With transformational characters, there’s no way to decide. With neomorphic characters though, we want to assume the minimum number of innovations of the innovation. This is what we mean by maximising homology: always assume a neomorphic character is present if you can Here’s how we’d resolve the ambiguous trees from (Agnarsson &amp; Miller, 2008). 2.4 Problems with the Fitch algorithm The Fitch algorithm counts changes in a character. It assumes that the character is applicable throughout the tree. This assumption does not lead to error if: - The character is inapplicable in fewer than three tips; or - In the trees being considered, applicable and inapplicable tokens occur in distinct regions of the tree (Maddison, 1993). 2.4.1 Red tails, blue tails Maddison (1993) provided the following example to demonstrate the problem encountered by the Fitch algorithm when inapplicable characters were present. Consider the following tree, each node of which is supported by a number of characters. Tail colour (illustrated; 0 = red, 1 = blue) has not yet been considered, but has the potential to resolve the polytomy on the left hand side (bold). Tail colour should group the red-tailed tips together, and the blue-tailed tips together, but does not establish whether the ancestor of the left-hand tail-bearing clade had a red or blue tail. 2.4.2 Why Reductive coding doesn’t work Using reductive coding, our character looks like: Tail: (0), absent; (1), present. Tail colour: (0), red; (1), blue; (?), inapplicable. Consider the following two trees, each of which receives a score of two for the first character, Tail: absent/present. The score of the second character, for tail colour, is not as desired. The Fitch algorithm will prefer trees in which the left-hand tail-bearing clade has a blue tail, simply because the right-hand tail-bearing clade ancestrally did. Notice the additional step reconstructed at the root node: the Fitch algorithm reconstructs a change in tail colour in a taxon that doesn’t have a tail! This reconstruction is not logically consistent. 2.4.3 Why Extra State doesn’t work An alternative is to code the inapplicable token as an extra state: Tail: (0), absent; (1), present. Tail colour: (0), red; (1), blue; (2), inapplicable. This seems to resolve the problem case that we encountered with reductive coding: Both trees now receive the same score for the ‘tail colour’ character, which contributes four steps. Two of these steps, however, correspond to steps that have already been counted in the parent character, reflecting the two gains of a tail. Although this reconstruction is now logically consistent, the gain (or loss) of the tail is now reflected in two characters – characters are not independent of one another. The outcome is that each ontologically dependent character serves to increase the weight of its parent character. The loss of a tail, for example, would incur a cost of one step in the tail character and one step in each ontologically dependent character, even though it represents a single evolutionary event. 2.4.4 Why a single multi-state character doesn’t work A different approach is to use a single character to denote both the presence and the colour of the tail: Tail: (0), absent; (1), present, red; (2), present, blue. This seems to resolve the problem case that we encountered with reductive coding: However, we now have a situation where the gain/loss of a tail is afforded the same weight as a change in tail colour. We ought to prefer a tree where the tail evolved once (and changed colour) to one where it evolved twice (being a different colour each time). 2.4.5 Sankoff matrices It would be possible to establish a Sankoff matrix such that a change between absent and red or absent and blue cost more than a change between red and blue, but this effectively up-weights the tail character, and it’s not clear that this is desirable – or how much this extra weight should be (Maddison, 1993). 2.4.5.1 Symmetric Consider a character with three ontologically dependent characters: Tail: Absent / present Tail colour: Red / blue Tail covering: Scaly / hairy Tail shape: Straight / curly This could be coded as a single transformation series using a Sankoff matrix: Table 2.1: Tail: Cost to go from left state to top entry: 0 1 2 3 . . . 8 (0), absent 0 4 4 4 . . . 4 (1), present, red, scaly, straight 4 0 1 1 . . . 3 (2), present, red, scaly, curly 4 1 0 2 . . . 2 (3), present, red, hairy, straight 4 1 2 0 . . . 2 . . . . . 0 . . . . . . . . . 0 . . . . . . . . . 0 . (8), present, blue, hairy, curly 4 3 2 2 . . . 0 The first thing to note is that each additional ontologically depedent character generates disproportionately more complexity in the Sankoff matrix. Even if this additional complexity could be handled, the underlying issue remains that losing a tail, which arguably corresponds to a single evolutionary event, is allocated a large cost that only grows with the number of ontogenetically dependant characters. 2.4.5.2 Gain and loss asymmetric At the cost of symmetry, one could argue that the loss of a tail requires a single transformation, whereas the gain requires the addition of a tail and the “setting” of each ontologically dependent character, rendering an asymmetric Sankoff matrix that nevertheless respects triangular inequality: Table 2.2: Tail: Cost to go from left to top entry: 0 1 2 3 . . . 8 (0), absent 0 4 4 4 . . . 4 (1), present, red, scaly, straight 1 0 1 1 . . . 3 (2), present, red, scaly, curly 1 1 0 2 . . . 2 (3), present, red, hairy, straight 1 1 2 0 . . . 2 . . . . . 0 . . . . . . . . . 0 . . . . . . . . . 0 . (8), present, blue, hairy, curly 1 3 2 2 . . . 0 Here, though, we encounter a new problem: reconstructions involving very many losses are preferred to those involving a single gain. 2.5 Conclusion No coding mechanism can generate consistent and logically meaningful tree scores when employing the Fitch algorithm. The inapplicable state needs treating differently from other states. A new algorithm is needed. 2.6 Counting steps is doomed Plenty of people informally have attempted to solve the problem by counting steps. (E.g. that U of Texas PhD that we found; goloboff pers. comm.?) It’ll never work. here’s why. One example: multiple independent gains are preferred because they avoid adding steps. References "],
["our-solution.html", "3 Our solution 3.1 Counting homologies is the answer 3.2 How this fixes the problem 3.3 Implementation 3.4 How this algorithm weights against multiple innovations 3.5 Coding ontologically dependent neomorphic characters 3.6 Coding ambiguous taxa 3.7 Examples", " 3 Our solution 3.1 Counting homologies is the answer 3.1.1 What we count The problem with the Fitch is that it counts steps. We get around this by counting homoplasies. See De Laet’s work on this. The total score = steps + (additional) regions. Here’s an example tree showing that. 3.1.1.1 What does it take to denote separate regions? Three inapplicable tips, arranged just so. (Addresses Goloboff’s comment.) 3.2 How this fixes the problem Here are some examples of how this fixes the problems that we encountered. Take the example of two very different tails. Because they are so different, it makes sense that they might have evolved twice. 3.2.1 Furhter examples Here are Goloboff’s trees as examples of how we would approach them, and why that’s preferable to how he would approach them Here are De Laet’s cases and here’s why they aren’t problematic. 3.2.2 Summary We can show that this produces the correct behaviour. But how do we count this in practice? 3.3 Implementation Consider a tree with 12 taxa and the following multi-state characters with inapplicable data 23--1??--032; say the character is “colour of the tail” ranging from 0 to 3 (four colours). Four taxa in our example have no tail (hence the inapplicable data -) and for two taxa, the data is missing (?- we don’t known the colour of the tail or even whether the taxa have a tail or not). We can use the Inapp package to apply our four passes inapplicable algorithm for this character on this tree. ## Loading the Inapp package library(Inapp) ## The tree tree &lt;- read.tree(text = &quot;((((((1,2),3),4),5),6),(7,(8,(9,(10,(11,12))))));&quot;) ## The character character &lt;- &quot;23--1??--032&quot; ## Applying the NA algorithm matrix &lt;- apply.reconstruction(tree, character, method = &quot;NA&quot;, passes = 4) Here is what is happening: 3.3.1 Passes 1 &amp; 2 The first two passes are a standard Fitch algorithm applied the the parent character of the studied character (see [Fitch.Rmd]) with a special rule for the inapplicable state (-). For the first pass (first downpass): If state in common between the two descendants is the inapplicable state, but that both have also applicable states, set the node’s state to be the union between the descendants states (rather than their state in common). If there is no state in common between the descendants and both descendants have applicable states, remove the inapplicable state from their union (rather than simply setting the nodal state to their union). For the second pass (first uppass): If the focal node has both applicable and inapplicable states, set it to be the inapplicable state only if its ancestor has also only the inapplicable state, else remove the inapplicable state. If the focal node has only an inapplicable state and it’s ancestor has not only the inapplicable state, set it to be the union between it’s descendants states if their are both applicable, else, leave it as the inapplicable state. ## Plotting the NA two first passes plot(matrix, passes = c(1,2), counts = 0, main = &quot;Inapplicable reconstruction&quot;) The parent character can be considered as a binary character “presence (1) or absence (0) of a tail” that would be 11001??00111. The character would be reconstructed as: ## The parent character parent_character &lt;- &quot;11001??00111&quot; ## Applying the Fitch algorithm matrix_parent &lt;- apply.reconstruction(tree, parent_character, method = &quot;Fitch&quot;, passes = 2) plot(matrix_parent, passes = c(1,2), counts = 0, main = &quot;Fitch reconstruction of the parent character&quot;) As you can see, both reconstructions are identical: nodes with no tail are denoted as 0 in the case of the “parent character” and as - for our current character. Note however that contrary to the Fitch algorithm, there is no tree score counting in our algorithm for the two first passes. Indeed, in the case of the Fitch reconstruction of the “parent character”, the gain or losses of a tail are counted but not the changes in states for the subtending character (the tree score is 3 in Fitch, 5 in our case). 3.3.2 Pass 3 The third pass further resolves ambiguities at nodal states. If the node is applicable, the standard Fitch downpass comparisons between the descendants are applied (see [Fitch.Rmd]) but with the rules relative to the inapplicable state described for the first downpass above. During this pass, we can also count the tree score. This score is composed of both: the change in states (e.g. the change in the colour of the tail) the change between applicable and inapplicable regions (e.g. the change in the parent character: a gain or a loss of the tail) The changes of states are calculated the same way as Fitch for the applicable states only: If there is no state in common between both node’s descendants and that the node and its descendant have a least one applicable state, increment the tree score. ## Plotting the NA two first passes plot(matrix, passes = c(1,2,3), counts = 2, main = &quot;State changes&quot;, show.labels = c(1,2)) For example, for node n23, there is no state in common between the tip 12 (2) and 11 (3), the tree score is incremented at this node (case 1 above). Note, however, that for node n21, there is no state in common between node n22 (023) and tip 9 (-) but the score is not incremented since it does not concern applicable states only. In other words, there is no change in state at the node n21 from the tail having a colour 0, 2 or 3 to the tail not being present (-) but rather a change in the parent character between presence and absence of the tail (present is 023 and absent is -). 3.3.2.0.1 Tracking applicable regions To know whether any node leads to a region of applicable states we can use a “tracker” for each node that tells us at any moment whether descendants of a node contain applicable data or not. Doing so, we can know, when a node is inapplicable and its descendant lead to applicable regions that extra applicable regions are implied by the tree. In other words and following our “colour of the tail” character, extra applicable regions imply independent appearances of the tail somewhere in the node’s descendants. The tracker is initialised during the second pass (first uppass) and is updated during the third pass (second downpass). The tracker works as follows for each node’s left and right descendants: If the descendant state was resolved as applicable, the node leads to an applicable region, else, it leads to an inapplicable one. The trackers are initialised for each node during the first uppass and then propagated back down the tree during the second downpass. Using these trackers, we can then increments the tree score for all changes that imply a new applicable region. The switch to or from an inapplicable and applicable region are counted as follow: If the node is inapplicable and both descendants lead to regions of applicable states, increment the region count. ## Plotting the NA two first passes plot(matrix, passes = c(1,2,3), counts = 1, main = &quot;Applicable regions&quot;, show.labels = c(1,2)) For example, node n15 is solved as inapplicable but both his descendants lead to two independent applicable regions (tip 5 with the state 1 and node n18 with the states 1 and 2). This implies an independent change in the parent character (in our example, tail is absent at node n15 but evolves independently at tip 5 and node n18). Conversely, node n21 is solved as inapplicable but not both his descendants lead to independent applicable regions. This node does thus not imply an independent change in the parent character. Note that the number of applicable regions for a character is always at least 1 (unless every taxa has the inapplicable state) and therefore, we only count the additional regions. Combining both scores - the number of changes in character states and the number of additional applicable regions - we get indeed a total tree score of 5 for this tree and character ## Plotting the NA two first passes plot(matrix, passes = c(1,2,3), counts = c(1,2), show.labels = c(1,2)) Using these tree passes is enough to get the tree score (while taking into account inapplicable data!) but does not solve all ancestral reconstructions. A fourth pass (second uppass) might be necessary to finalise the node states reconstructions. 3.3.3 Pass 4 In the example above, the node n23 is still not correctly solved after the third pass. In fact, considering its ancestor’s states (023) and its descendants’ states (2 and 3), it should be resolved as 023 under a delayed transition model (DELTRAN). In order to do so, we can apply a extra pass similar to the second pass (first uppass), as described above. ## Plotting the NA two first passes plot(matrix, passes = c(1,2,3,4), counts = c(1,2), show.labels = c(1,2)) 3.4 How this algorithm weights against multiple innovations We discussed in an in an earlier chapter that, if we only penalise transformations between states in subsidiary characters, trees that imply multiple origins of the parent character receive much lower scores than those in which the parent character evolves once (but its subsidiary characteristics change multiple times). Our algorithm counterbalances this by, in effect, imposing a cost for each additional origin of the parent character. At first blush, this sounds like it is weighting against multiple innovations of the parent character – but this isn’t so; it weights against multiple independent innovations of the SAME state (i.e. homoplasy), but if a red tail evolved here and a blue tail evolved there, then two innovations of the tail imposes a cost of one (additional region) for tail colour, whereas a single innovation of the tail would also impose a cost of one (transformation) for tail colour. The additional origin of the tail can This has a side-effect that we’ll study with an invariant character 3.4.0.1 Multiple dependencies It’s not a problem to have characters dependent on characters that are dependent on characters. Consider the following character heirarchy: Appendages: (0), absent; (1), present. Appendage termination: (0), blunt; (1), claw; (2), sucker. Claw morphology: (0), smooth; (1), serrated. Sucker morphology: (0), round; (1), polygonal. The included taxa may or may not bear appendages; if they do, then the appendages may end either with either claws or suckers, or neither (but not both). Claws come in two flavours, smooth and serrated; suckers come in two shapes, rounded and polygonal. If character 1 (appendages) is absent, then characters 2–4 are inapplicable. Otherwise, charcter 2 (appendage termination) must take one of the three applicable values. If character 2 (termination) has state 0 (blunt), then characters 3 and 4 (morphology of claw / sucker) are inapplicable. If character 2 (termination) has state 1 (claw), then character 3 (claw morphology) is applicable and character 4 (sucker morphology) is inapplicable. If character 2 (termination) has state 2 (sucker), then character 3 (claw morphology) is inapplicable and character 4 (sucker morphology) is applicable. A sample character matrix might look like this: A B C D E F G H I J K L M Appendages: (0), absent; (1), present. 0 0 0 1 1 1 1 1 1 1 1 1 1 Appendage termination: (0), blunt; (1), claw; (2), sucker. - - - 0 0 1 1 1 1 2 2 2 2 Claw morphology: (0), smooth; (1), serrated. - - - - - 0 0 1 1 - - - - Sucker morphology: (0), round; (1), polygonal. - - - - - - - - - 0 0 1 1 Which would plot on a tree thus: 3.4.1 A parsimony uninformative character that informs parsimony! All tails are blue. Let’s say that they are all blue for some complex molecular reason, such that it is most parsimonious if “blueness” has a single evolutionary origin. A B C D E F G H Tail: (0), absent; (1), present 0 0 0 0 1 1 1 1 Tail colour: (-), inapplicable; (1), blue - - - - 1 1 1 1 Body colour: (1), black; (2), white 1 1 2 2 2 2 1 1 This complex molecular reason is grounds to suspect that the tails have a common ancestor More formally, we wish to attribute this complex molecular reason to common ancestry, rather than homoplasy Thus “blueness” represents a separate character that has the same distribution as tails (or a sbuset thereof, if some tails are of uncertain colour) Let’s compare two trees. One groups taxa based on the presence of tails; the other groups taxa based on body colour. So the tree on the left, which reconstructs a single origin of the tail, a single origin of a blue tail colouration, and two changes in body colour, is preferred to the tree on the right, which reconstructs a single change in body colour but two origins of the tail, and two origins of blue colouration on the tail. We should include this character if it’s meaningful. But not if it’s not (e.g. number of base pairs in a tail). 3.4.1.1 Difficulties Here are some marginal cases where discretion is required. Here are some trees that show why we would code things our way this is why you need to look at your data carefully and see whether you like what your mode of coding is implying! 3.5 Coding ontologically dependent neomorphic characters 3.5.1 Neomorphic and transformational characters Researchers should be aware that our algorithm treats nemorphic characters as though they are transformational; that is, “absence” of a feature is seen as equally informative as “presence”. In some cases, this may be desirable. One might argue that “Serrations on tail margin: (0), absent; (1), present” behaves as a transformational character, as a tail must have a margin of some sort, and “serratedness” is a property of the margin – perhaps there is no reason to assume that the tail was primitively simple, or that serrations necesssarily represent a secondary increase in complexity. In other cases, this may not be desirable. As an example, consider a complex character, such as the eyespots on the tail of a peacock. A B C D E F G H I Tail: (0), absent; (1), present 0 0 0 1 1 1 1 1 1 Tail eyespots: (-), inapplicable; (0), absent; (1), present - - - 0 0 0 0 1 1 The presence of tail eyespots obviously contains grouping information – we should prefer reconstructions that attribute the presence of tail eyespots to common ancestry to those that imply independent gains of this complex characteristic. It is less obvious whether the absence of such complex features should convey grouping information. This decision ought to be defended for individual characters by individual researchers, but researchers should be aware of the implications of their chosen coding strategy. 3.5.1.1 Three trees Consider the following three scenarios: Each of these trees implies two independent origins of the tail. Their score differs only with respect to the eyespots character. 3.5.1.1.1 One tail spotted, one not The first tree has the minimum possible score for the eyespots character. (A score of one would also be obtained if the tail evolved once, and a single transformation occurred between 0 and 1 – but we are only considering trees where the tail evolved twice.) 3.5.1.1.2 Two spot appearances The next tree has a score of two for the eyespots character, which is obviously correct: Eye spots, a complex character, have evolved twice independently, which is not as parsimonious. 3.5.1.1.3 Two non-spotted appearances The final tree also has a score of two for the eyespots character: even though eyespots have only evolved once, just as in the first tree. The score of two occurs because the “absence of eyespots” has evolved twice. 3.5.1.1.4 Evaluation It is possible that a researcher might feel uncomfortable grouping taxa on the basis of the non-occurrence of a complex feature that did not occur in their common ancestor. Putting this another way, it is not clear that the fact that a feature has not evolved in two instances represents a homoplasy. The absence of eyespots in a tail is not an evolutionary innovation – it is an inheritance from a common ancestor that did not have eyespots (and did not have a tail). 3.5.1.1.5 Implications A researcher that argues that the absence of a feature contains phylogenetic information must surely include all properties of a tail that are only observed in a single taxon (because the absence of that feature in other taxa also contains grouping information). A researcher may also include all properties of a tail that do not occur in any of the taxa of interest, for these too will influence tree topology: parsimony uninformative characters inform parsimony. A B C D E F G Tail: (0), absent; (1), present 0 0 0 1 1 1 1 Tail with glow-in-the-dark pigment: (-), inapplicable; (0), absent; (1), present - - - {01} {01} 0 0 Tail with ability to generate electricity: (-), inapplicable; (0), absent; (1), present - - - {01} {01} 0 0 Note that each of the unobserved characters provides evidence against independent origins of the tail, preferring instead independent losses: Thus the simple matrix presented above sees both of these trees as equally parsimonious – three losses of a single-origin tail that lacks two unlikely attributes is considered as likely as one independent gain of a similar tail. This behaviour is desired if the similarity between the tails requires an evoltuionary explanation. But the absence of these features does not seem any more difficult to explain if the tails do not have a common ancestor. The solution here is to deploy a different character coding strategy, coding absences as absences. That way, absence CAN be inherited from a common ancestor, in which a complex-feature-of-the-tail (eyespots, glow-inthe-dark pigment) was absent (and the tail was absent too). A B C D E F G Tail: (0), absent; (1), present 0 0 0 1 1 1 1 Tail with glow-in-the-dark pigment: (-), inapplicable; (0), absent; (1), present 0 0 0 {01} {01} 0 0 Tail with ability to generate electricity: (-), inapplicable; (0), absent; (1), present 0 0 0 {01} {01} 0 0 This can be handled by the Fitch algorithm, and works well in simple cases: The behaviour only becomes questionable when a tail is secondarily lost, then re-gained, as the loss of a tail seems like it should be a single evolutionary step, but also causes the loss of all contingent characters, which must then “reevolve” as though they had never existed: Perhaps there are cases – as might be seen in phenotypic plasticity – where a tail might be lost, and then re-activate preexisting genes when it evolves again? This starts to require an explicit model of evolution, however, which is somewhat beyond the remit of parsimony. 3.5.1.2 Recommendation Neomorphic characters should probably be coded as absent everywhere they are absent, whether this is because there’s no tail or because there’s a tail without the complex feature. If you’re coding a neomorphic character as transformational, then you encounter problems. 3.6 Coding ambiguous taxa Ambiguous data does not pose a problem for the algorithm, but the nature of the ambiguity must be considered when scoring a character. 3.6.1 Ambiguity when parent character ambiguous If it’s not clear whether or not a taxon has a tail, then tail colour should be coded as ?, denoting that any possible token (including the inapplicable token) may be the most parsimonious for the tail. In trees in which the tail can be reconstructed as present, the ambiguous tip will be reconstructed as having a tail of the appropriate colour: In trees in which the tail cannot be reconstructed as present without inferring a homoplasious origin, the tail colour will be reconstructed as inapplicable: 3.6.2 Ambiguity when parent character known If a taxon is known to have a tail, there are two scenarios for ontologically dependent transformational characters: 3.6.2.1 Subordinate character has finite states If the subordinate character must take one of a finite set of values, then the unobserved property of the tail is known to belong to these values and should be coded accordingly. For example: Tail: (0), absent; (1), present Tail margin: (0), smooth; (1), serrated. Assume that the tail margin must either be smooth or serrated, and there is no reason to assume that either state is ancestral (i.e. the character is strictly transformational). Tail margin should then be coded as {01}: i.e. the tail is known to have taken one of the two states 0 or 1. 3.6.2.2 Subordinate character may have unobserved states A more complicated situation arises where a subordinate character may have unobserved states, as with Tail colour: (0), red; (1), blue. A taxon that is known to have a tail, but whose tail colour is uncertain, should generally be coded as ?. Coding it as {01} would be appropriate if the tail was known to certainly be homologous with other tails in the dataset, in which case it would be most parsimonious to assume that the tail colour is the same colour as the ancestor of the tip, which was necessarily either red or blue. But if, as will more often be the case, homology of the tails is not known a priori, then it is possible that this taxon has a tail that is not homologous with any other tail whose colour has been observed. In this case, coding the tail colour as {01} states that the tail is the same colour as a tail that has already been observed. This means that the independent origin of the tail also represents an independent origin of this particular colour – and hence an instance of homoplasy. Coding the tail colour as ? allows the possibility that the independently- evolved tail has a different colour to the tails already observed – green, perhaps. Reconstructing the tail colour as a colour that has not already been observed avoids an instance of homoplasy, and is therefore more parsimonious. In the case that the unknown tail evolved independently and was green, the original character formulation – which only provides tokens for red and blue tails – cannot be applied and is thus inapplicable. Our algorithm will thus reconstruct tail colour as being inapplicable in such a taxon. 3.6.3 Recommendation We therefore recommend the following coding schema for ambiguous tips where the tail is (A) known to be present; (B) ambiguous; (C) known to be absent: A B C Tail: (0), absent; (1), present. 1 ? 0 Tail margin: (0), smooth; (1), serrated. {01} ? - Tail colour: (0), red; (1), blue. ? ? - 3.7 Examples This vignette describes how the algorithm approaches some example trees. We follow the example of a tail coded using two characters: Tail: (0), absent; (1), present; Tail colour: (0), red; (1), blue. 3.7.1 Some caterpillars First we’ll address some pectinate “caterpillar” trees, in which eight taxa have tails (and eight do not), four of which are red, four of which are blue. An optimal tree with this character invokes a single origin of the tail, and a single change in tail colour, thus incurring a score of two. Here is one example: If we insist that the tail evolves twice, then the best score is accomplished by reconstructing a different colour of tail in each of the two regions in which the tail is present. On a caterpillar tree, this means the loss of a tail that has one colour, and an independent innovation in a tail-less taxon of a tail that has a different colour: Under the parsimony criterion, it is considered less optimal if a tail, when it re-evolves, happens to independently re-evolve a colour that has already been observed – “blueness” has evolved twice on the following tree, meaning that the second innovation of “blueness” represents an instance of homoplasy. 3.7.1.1 Three equally suboptimal alternatives The following three trees differ in the number of innovations of the tail that are implied, and the number of changes in tail colour. All are equally parsimonious. Under the first, our algorithm reconstructs the tail as ancestrally present, being lost on edge 2, gained on edge 5, lost in tips H and I, lost on edge 11, and gained on edge 14 (a total of six homoplasies). It further reconstructs independent, homoplastic origins of tail redness on edge 5, tail blueness on edge 14, and a change in tail colour from red to blue somewhere between edges 7 and 9 (three homoplasies). In the second, our algorithm reconstructs the tail as ancestrally present, being lost in tips B, D, E, H, and I, and on edge 11, before being independently gained on edge 14 (a total of seven homoplasies). It further reconstructs an independent, homoplastic origins of tail blueness on edge 14, and a change in tail colour from red to blue somewhere between edges 7 and 9 (two homoplasies). The third configuration reconstructs the tail as ancestrally present, being lost in tips B, D, F, H, J, L, N and P (a total of eight homoplastic losses). It further reconstructs a single change in tail colour from red to blue on edge 8. 3.7.1.2 A better caterpillar tree The tree below obtains a better score than any of the previous three: it implies a loss of the tail at edge 2, a gain at edge 6, a loss at edge 10, and a gain at edge 14; it invokes a homoplastic origin of redness at edge 6, one of blueness at edge 14, and a change in colour at edge 8, for a combined score of 7. "],
["references.html", "References", " References "]
]
