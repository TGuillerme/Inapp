(time_C <- system.time(results_C <- .C("count_primes_C", limit = as.integer(10000), n_primes = as.integer(0))))
(time_C <- system.time(results_C <- .C("count_primes_C", limit = as.integer(100000), n_primes = as.integer(0))))
dyn.load("prime.so")
(time_C1 <- system.time(results_C2 <- .C("count_primes_C", limit = as.integer(100000))))
(time_C1 <- system.time(results_C2 <- .Call("count_primes_C", limit = as.integer(100000))))
(time_C1 <- system.time(results_C2 <- .Call("count_primes_C", limit = as.integer(1000000))))
x <- 1
++x
x+1
if(x<-TRUE) {cat("yes")}
.Call("get", n = "a")
toString
methods(toString)
getAnywhere(toString.default)
? strtrim
?dist
x <- matrix(rnorm(100), nrow = 5)#
dist(x)#
dist(x, diag = TRUE)#
dist(x, upper = TRUE)#
m <- as.matrix(dist(x))#
d <- as.dist(m)#
stopifnot(d == dist(x))
rownames(x) <- LETTERS[1:5]
colnames(x) <- letters[1:20]
x
dist(x)
?attr(x)
attr(x)
attrs(x)
.Call("get", n = "abd")
.Call("get_length", newick = "abd")
\
dyn.load("newick.so")
.Call("get_length", newick = "I got you you motherfucker")
.Call("get_length", newick = letters[])
.Call("get_length", newick = letters[1:27])
.Call("get_length", newick = letters[1:26])
.Call("get_length", newick = as.character(letters[1:26]))
.Call("get_length", newick = paste(as.character(letters[1:26]), collaps = "" )
)
.Call("get_length", newick = paste(as.character(letters[1:26]), collapse = "" ))
.Call("get_length", newick = paste(as.character(letters[1:26]), collapse = "-" ))
.Call("get_length", newick = paste(as.character(letters[1:26]), collapse = "---" ))
72*2
405696+12742
5966-25
runApp("~/Projects/Inapp/")
library(dispRity)
?dispRity
## Load the Beck & Lee 2014 data#
data(BeckLee_mat50)#
#
## Calculating the disparity as the sum of variances from a single matrix#
sum_of_variances <- dispRity(BeckLee_mat50, metric = c(sum, variances))#
summary(sum_of_variances)#
## Bootstrapping this value#
bootstrapped_data <- boot.matrix(BeckLee_mat50, bootstraps = 100)
BeckLee_mat50
bootstrapped_data
var <- dispRity(bootstrapped_data, metric = ranges)
range <- dispRity(bootstrapped_data, metric = ranges)
range
summary(range)
dispRity(range, metric = sum)
sum <- dispRity(range, metric = sum)
summary(sum)
dispRity(bootstrapped_data, metric = var)
library(shiny)
?runGitHub
library(squid)
?squid
squiApp()
squidR()
squidApp()
runGitHub("Inapp", "TGuillerme")
5000/12
5000/12/24
one_site <- read.csv("../Data/GreenBassin.csv")
setwd("$file_path")
## Generating some data#
    tree <- ape::read.tree(text = "((((((1,2),3),4),5),6),(7,(8,(9,(10,(11,12))))));")#
    character <- "23--1??--032"#
    NA_matrix <- apply.reconstruction(tree, character, passes = 4, method = "NA")#
    Fitch_matrix <- apply.reconstruction(tree, character, passes = 2, method = "Fitch")
test_NA <- make.output.data.frame(NA_matrix)
test_Fitch <- make.output.data.frame(Fitch_matrix)
test_Fitch
expect_is(test_Fitch, "data.frame")
dim(test_NA)
expect_is(test_NA, "data.frame")#
    expect_is(test_Fitch, "data.frame")#
    expect_equal(dim(test_NA), c(23, 6))#
    expect_equal(dim(test_Fitch), c(23, 3))
test_NA$Changes
expect_is(test_NA$Changes, "logical")
expect_is(test_NA$Regions, "logical")
expect_is(test_NA$regions, "logical")
test_NA
## Making an output matrix#
make.output.data.frame <- function(states_matrix) {#
    ## Create the output table#
    output_matrix <- as.data.frame(matrix(NA, nrow = ape::Ntip(states_matrix$tree) + ape::Nnode(states_matrix$tree), ncol = 6))#
    colnames(output_matrix) <- c(names(states_matrix)[2:5], "Changes", "Regions")#
    if(is.null(states_matrix$tree$node.label)) {#
        rownames(output_matrix) <- c(states_matrix$tree$tip.label, paste("n", (ape::Ntip(states_matrix$tree)+1):length(states_matrix$Char), sep = ""))#
    } else {#
        rownames(output_matrix) <- c(states_matrix$tree$tip.label, tree$node.label)#
    }#
    ## Selecting all states (for missing data)#
    all_states <- sort((unique(unlist(states_matrix$Char))))#
#
    ## Collapsing the data#
    collapse.data <- function(data, all_states) {#
        if(all(all_states %in% data)){#
            return("?")#
        } else {#
            return(paste(gsub(-1, "-", data), collapse = ""))#
        }#
    }#
#
    ## Collapse the character names#
    output_list <- lapply(states_matrix[2:5], lapply, collapse.data, all_states = all_states)#
#
    ## Fill up the matrix#
    for(recon in 1:4) {#
        output_matrix[,recon] <- unlist(output_list[[recon]])#
    }#
#
    ## Add the changes#
    output_matrix[,5] <- FALSE#
    if(length(states_matrix$changes) != 0) {#
        output_matrix[states_matrix$changes, 5] <- TRUE#
    }#
#
    ## Add the applicable regions#
    output_matrix[,6] <- TRUE#
    if(!is.null(unlist(states_matrix$tracker[[4]]))) {#
        output_matrix[, 6] <- unlist(states_matrix$tracker[[4]])#
    }    #
#
    ## If Fitch, remove the extra columns#
    if(is.null(unlist(states_matrix$Dp2)) && is.null(unlist(states_matrix$Up2))) {#
        output_matrix <- output_matrix[,-c(3,4,6)]#
    }#
#
    return(output_matrix)#
}#
## Asking for confirmation#
read.key <- function(msg1, msg2, scan = TRUE) {#
    message(msg1)#
    if(scan == TRUE) {#
        scan(n = 1, quiet = TRUE)#
    }#
    silent <- "yes"#
    if(!missing(msg2)) {#
        message(msg2)#
    }#
}
## Generating some data#
    tree <- ape::read.tree(text = "((((((1,2),3),4),5),6),(7,(8,(9,(10,(11,12))))));")#
    character <- "23--1??--032"#
    NA_matrix <- apply.reconstruction(tree, character, passes = 4, method = "NA")#
    Fitch_matrix <- apply.reconstruction(tree, character, passes = 2, method = "Fitch")#
#
    ## Creating the output matrix#
    test_NA <- make.output.data.frame(NA_matrix)#
    test_Fitch <- make.output.data.frame(Fitch_matrix)
expect_is(test_NA, "data.frame")#
    expect_is(test_Fitch, "data.frame")#
    expect_equal(dim(test_NA), c(23, 6))#
    expect_equal(dim(test_Fitch), c(23, 3))#
#
    ## Right output values#
    expect_is(test_NA$Changes, "logical")#
    expect_is(test_NA$Regions, "logical")
expect_is(test_Fitch$Regions, "NULL")
expect_is(test_Fitch$Changes, "logical")
expect_is(test_NA$Dp1, "character")
expect_is(test_NA$Dp1, "character")#
    expect_is(test_NA$Up1, "character")#
    expect_is(test_NA$Dp2, "character")#
    expect_is(test_NA$Up2, "character")
expect_is(test_NA$Changes, "logical")#
    expect_is(test_NA$Regions, "logical")
context("Right output management")#
test_that("make.output.data.frame works", {#
#
    ## Generating some data#
    tree <- ape::read.tree(text = "((((((1,2),3),4),5),6),(7,(8,(9,(10,(11,12))))));")#
    character <- "23--1??--032"#
    NA_matrix <- apply.reconstruction(tree, character, passes = 4, method = "NA")#
    Fitch_matrix <- apply.reconstruction(tree, character, passes = 2, method = "Fitch")#
#
    ## Creating the output matrix#
    test_NA <- make.output.data.frame(NA_matrix)#
    test_Fitch <- make.output.data.frame(Fitch_matrix)#
#
    ## Right output type#
    expect_is(test_NA, "data.frame")#
    expect_is(test_Fitch, "data.frame")#
    expect_equal(dim(test_NA), c(23, 6))#
    expect_equal(dim(test_Fitch), c(23, 3))#
#
    ## Right output values#
    expect_is(test_NA$Dp1, "character")#
    expect_is(test_NA$Up1, "character")#
    expect_is(test_NA$Dp2, "character")#
    expect_is(test_NA$Up2, "character")#
    expect_is(test_NA$Changes, "logical")#
    expect_is(test_NA$Regions, "logical")#
#
    expect_is(test_Fitch$Dp1, "character")#
    expect_is(test_Fitch$Up1, "character")#
    expect_is(test_Fitch$Dp2, "NULL")#
    expect_is(test_Fitch$Up2, "NULL")#
    expect_is(test_Fitch$Changes, "logical")#
    expect_is(test_Fitch$Regions, "NULL")#
})
output_matrix
states_matrix <- NA_matrix
output_matrix <- make.output.data.frame(states_matrix)
filename = "states_matrix"
setwd("/Users/TGuillerme/Packaging/Inapp/R")
path = "."
## states_matrix#
    if(class(states_matrix) != "states.matrix") {#
        stop(paste(match_call$states_matrix, "must be of class 'states.matrix'.\nSee make.states.matrix() or apply.reconstruction()."))#
    }
output = "csv"
## output#
    if(!is.null(output)) {#
        ## Checking output's method#
        all_outputs <- c("newick", "nexus", "csv", "pdf", "tre", "nex")#
        if(class(output) != "character") {#
            stop("output argument must be one of the following: ", paste(all_outputs[1:4], collapse = ", "), ".")#
        } else {#
            if(length(output) != 1) {#
                stop("output argument must be one of the following: ", paste(all_outputs[1:4], collapse = ", "), ".")#
            } else {#
                if(!(output %in% all_outputs)) {#
                    stop("output argument must be one of the following: ", paste(all_outputs[1:4], collapse = ", "), ".")#
                }#
            }#
        }#
    } else {#
        ## If output is null, return.#
        return(invisible())#
    }#
    ## Change output names#
    output <- ifelse(output == "newick", "tre", output)#
    output <- ifelse(output == "nexus", "nex", output)#
#
    ## Filename and path#
    if(class(filename) != "character" || length(filename) != 1) {#
        stop(paste(match_call$filename, "must be a single character string."))#
    } else {#
        if(class(path) != "character" || length(path) != 1) {#
            stop(paste(match_call$path, "must be a single character string."))#
        } else {#
            full_path <- paste(path, paste(filename, output, sep = "."), sep = "/")#
#
            ## Check if the path exists#
            if(!dir.exists(path)) {#
                stop(paste("path", path, "not found."))#
            }#
#
            ## Check if file exists#
            if(length(list.files(full_path)) != 0) {#
                read.key(paste("file \"", full_path, "\" already exists!\nPress [enter] to overwrite or [esc] to cancel.", sep = ""), paste(filename, "has been overwritten."))#
            }#
        }#
    }
?write.csv
write.csv(output_matrix, file = full_path)
refresh.pkg("Inapp")
