---
title: "A four-pass algorithm for inapplicable data"
author: "Martin R. Smith"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
bibliography: ../inst/REFERENCES.bib
csl: https://raw.githubusercontent.com/citation-style-language/styles/master/apa-old-doi-prefix.csl
vignette: >
  %\VignetteIndexEntry{2. Problems with Fitch}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
```{R setup}
library('Inapp')
library('ape')
data("brewer")
```

# Inapplicable data in a parsimony setting

This is one of a [series](Index.html) of vignettes that works through the inapplicable algorithm proposed by Brazeau _et al._ [-@ThisStudy].

We assume that you are already familiar with the [Fitch algorithm](Fitch.html).

## Problems with the Fitch algorithm

The Fitch algorithm counts changes in a character.
It assumes that the character is applicable throughout the tree.
This assumption does not lead to error if:
- The character is inapplicable in fewer than three tips; or
- In the trees being considered, applicable and inapplicable tokens occur
  in distinct regions of the tree [@Maddison1993].


### Red tails, blue tails
Maddison [-@Maddison1993] provided the following example to demonstrate
the problem encountered by the Fitch algorithm when inapplicable
characters were present.


Consider the following tree, each node of which is supported by a number of
characters.  Tail colour (illustrated; 0 = red, 1 = blue) has not yet been 
considered, but has the potential to resolve the polytomy on the left hand side (bold).

```{R Maddison example, echo=FALSE, fig.height=5, fig.width=8}
par(mar=rep(0.2, 4))
treeUnresolved <- ape:::read.tree(text="(((((A, B, C, D), e), f), g), (h, (i, (j, (K, (L, (M, N)))))));")
treeUnresolved$edge.length <- rep(1, dim(treeUnresolved$edge)[1])
edgeWidths <- rep(2, dim(treeUnresolved$edge)[1])
edgeWidths[5:8] <- 4
plot(treeUnresolved, direction='upwards', use.edge.length=TRUE, show.tip.label=FALSE,
     edge.width = edgeWidths)
c0 <- brewer[[2]][1]
c1 <- brewer[[2]][2]
cX <- "#cccccc"
tiplabels(c(0, 1, 0, 1, rep('-', 6), 1, 1, 0, 0), bg=c(c0, c1, c0, c1, rep(cX, 6), c1, c1, c0, c0))
     
```

Tail colour should group the red-tailed tips together, and the blue-tailed tips together,
but does not establish whether the ancestor of the left-hand tail-bearing clade 
had a red or blue tail.

### Why Reductive coding doesn't work

Using reductive coding, our character looks like:

> Tail: (0), absent; (1), present.
>
> Tail colour: (0), red; (1), blue; (?), inapplicable.

Consider the following two trees, each of which receives a score of two for the first
character, Tail: absent/present.  The score of the second character, for tail colour,
is not as desired.

The Fitch algorithm will prefer trees in which the left-hand tail-bearing clade
has a blue tail, simply because the right-hand tail-bearing clade ancestrally did.

```{R Maddison example 2ab, echo=FALSE, fig.height=9, fig.width=8}
par(mar=rep(0.2, 4), mfrow=c(2, 1), cex=0.8)
treeA <- ape::read.tree(text="(((((((A, B), C), D), e), f), g), (h, (i, (j, (K, (L, (M, N)))))));")
treeB <- ape::read.tree(text="(((((A, (B, (C, D))), e), f), g), (h, (i, (j, (K, (L, (M, N)))))));")
vignettePlot(treeA, '0011------1100', na=FALSE)     
vignettePlot(treeB, '0011------1100', na=FALSE)     
```

Notice the additional step reconstructed at the root node: the Fitch algorithm
reconstructs a change in tail colour in a taxon that doesn't have a tail!

This reconstruction is not logically consistent.


### Why Extra State doesn't work

An alternative is to code the inapplicable token as an extra state:

> Tail: (0), absent; (1), present.
>
> Tail colour: (0), red; (1), blue; (2), inapplicable.

This seems to resolve the problem case that we encountered with reductive coding:

```{R Extra state no good, echo=FALSE, fig.height=9, fig.width=8}
par(mar=rep(0.2, 4), mfrow=c(2, 1), cex=0.8)
treeA <- ape::read.tree(text="(((((((A, B), C), D), e), f), g), (h, (i, (j, (K, (L, (M, N)))))));")
treeB <- ape::read.tree(text="(((((A, (B, (C, D))), e), f), g), (h, (i, (j, (K, (L, (M, N)))))));")
vignettePlot(treeA, '00112222221100', na=FALSE)     
vignettePlot(treeB, '00112222221100', na=FALSE)     
```

Both trees now receive the same score for the 'tail colour' character, which 
contributes four steps.  Two of these steps, however, correspond to steps that have
already been counted in the parent character, reflecting the two gains of a tail.

Although this reconstruction is now logically consistent, the gain (or loss) of the tail
is now reflected in two characters -- characters are not independent of one another.

The outcome is that each ontologically dependent character serves to increase
the weight of its parent character.

### Why a single multi-state character doesn't work

An alternative is to use a single character to denote the tail:

> Tail: (0), absent; (1), present, red; (2), present, blue.

This seems to resolve the problem case that we encountered with reductive coding:

```{R Maddison example 2cd, echo=FALSE, fig.height=9, fig.width=8}
par(mar=rep(0.2, 4), mfrow=c(2, 1), cex=0.8)
treeA <- ape::read.tree(text="(((((((A, B), C), D), e), f), g), (h, (i, (j, (K, (L, (M, N)))))));")
treeB <- ape::read.tree(text="(((((A, (B, (C, D))), e), f), g), (h, (i, (j, (K, (L, (M, N)))))));")
vignettePlot(treeA, '11220000002211', na=FALSE)     
vignettePlot(treeB, '11220000002211', na=FALSE)     
```

One problem here is that the gain/loss of a tail is afforded the same weight 
as a change in tail colour.  It would be possible to establish a Sankoff matrix
such that a change between absent and red or absent and blue cost more than 
a change between red and blue, but there's no objective way to set this extra weight [@Maddison1993].

A further problem is that this does not extend well to cases where more than
one character is contingent on a parent character.  A single transformation
series with myriad states, and a polynomially larger step matrix, would need to
be constructed.  

Even if these technical limitations could be overcome, however, Sankoff matrices don't work.


### Why Sankoff matrices don't work

#### Gain and loss symmetric

Consider a character with just three ontologically dependent characters:

> Tail: Absent / present
>
> Tail colour: Red / blue
>
> Tail covering: Scaly / hairy
>
> Tail shape: Straight / curly

This could be coded as a single transformation series using a Sankoff matrix:

```{R Sankoff example, echo = FALSE, results='asis'}
dots <- rep('.', 3)
state <- c(0:3, dots, 8)
costs <- matrix(c(
  c(0, 4, 4, 4, dots, 4),
  c(4, 0, 1, 1, dots, 3),
  c(4, 1, 0, 2, dots, 2),
  c(4, 1, 2, 0, dots, 2),
  c(rep('.', 4), 0, rep('.', 3)),
  c(rep('.', 5), 0, rep('.', 2)),
  c(rep('.', 6), 0, rep('.', 1)),
  c(4, 3, 2, 2, dots, 0)) , byrow=TRUE, ncol=length(state))
costNames <- c("(0), absent", 
                     "(1), present, red, scaly, straight",
                     "(2), present, red, scaly, curly",
                     "(3), present, red, hairy, straight",
                     dots,
                     "(8), present, blue, hairy, curly")
colnames(costs) <-  state
rownames(costs) <- costNames
knitr::kable(costs, caption="Tail: Cost to go from left state to top entry:")

```

The issue here is that losing a tail, which arguably corresponds to a single evolutionary
event, is allocated a large cost that only grows with the number of 
ontogenetically dependant characters.

#### Gain and loss asymmetric

At the cost of symmetry, one could argue that the loss of a tail requires a single
transformation, whereas the gain requires the addition of a tail and the "setting"
of each ontologically dependent character, rendering an asymmetric Sankoff
matrix that nevertheless respects triangular inequality:

```{R Sankoff example 2, echo = FALSE, results='asis'}
costs <- matrix(c(
  c(0, 4, 4, 4, dots, 4),
  c(1, 0, 1, 1, dots, 3),
  c(1, 1, 0, 2, dots, 2),
  c(1, 1, 2, 0, dots, 2),
  c(rep('.', 4), 0, rep('.', 3)),
  c(rep('.', 5), 0, rep('.', 2)),
  c(rep('.', 6), 0, rep('.', 1)),
  c(1, 3, 2, 2, dots, 0)) , byrow=TRUE, ncol=length(state))
colnames(costs) <-  state
rownames(costs) <- costNames
knitr::kable(costs, caption="Tail: Cost to go from left to top entry:")

```

Here, we encounter a new problem: reconstructions involving very many losses 
are preferred to those involving a single gain.

```{R Sankoff is still no good, echo=FALSE, fig.height=7, fig.width=8}
par(mfrow=c(2, 1), mar=rep(0.2, 4))
sankTree <- ape::read.tree(text="(((((a, b), c), dX), eX), (fX, (gX, (p, (q, r)))));")
#vignettePlot(sankTree, '1110000888', na=FALSE, legend='none', blankNodes=TRUE)
sankTree$edge.length <- rep(1, dim(sankTree$edge)[1])
c1 <- brewer[[3]][1]
c0 <- brewer[[3]][2]
c8 <- brewer[[3]][3]
plot(sankTree, show.tip.label=FALSE, direction='upwards', edge.width=2,
     edge.col= c(c0, c0, c1, c1, c1, c1, c1, rep(c0, 6), rep(c8, 5)))
tiplabels(c(1,1,1,0,0,0,0,8,8,8), bg=c(rep(c1, 3),
                                       rep(c0, 4),
                                       rep(c8, 3)))
legend('bottomleft', bty='n', bg = NULL, pch=15, col="#7fbf7be0", pt.cex=1.8,
      legend = "Two gains: cost = 8") 
nodelabels(c("0>1 (+4)", "0>8 (+4)"), node=c(13, 17), bg="#7fbf7b00", pos=3, frame='no', col="#7fbf7be0", font=2)

plot(sankTree, show.tip.label=FALSE, direction='upwards', edge.width=2,
     edge.col= c(rep(c1, 7), c0, c0, c8, c0, c8, c0, rep(c8, 5)))
edgelabels()
tiplabels(c(1,1,1,0,0,0,0,8,8,8), bg=c(rep(c1, 3),
                                       rep(c0, 4),
                                       rep(c8, 3)))
legend('bottomleft', bty='n', bg = NULL, pch=15, col="#af8dc3e0", pt.cex=1.8,
      legend = "Four losses: cost = 7") 
nodelabels(c("1>8 (+3)", rep("1>0 (+1)",  2), rep("8>0 (+1)", 2)), node=c(11:13, 16:17), 
           bg="#af8dc300", pos=3, frame='no', col="#af8dc3e0", font=2)
```

## References
