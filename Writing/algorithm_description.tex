\documentclass[a4paper,12pt]{article}
\usepackage{hyperref}
\usepackage{enumitem}
\usepackage{ulem}
\usepackage{color}

\begin{document}

\noindent{\Large \bf Inapplicable algorithm description}

\section{First downpass} \label{1stDp}

% Write algorithm using https://en.wikibooks.org/wiki/LaTeX/Algorithms

    % If, else, \textbf{then} -> bold
    % \textit{set}, go, \textbf{\textit{increment}} -> italic

\begin{enumerate}
    \item Enter on any cherry (i.e. pair of tips) on the tree and move to its most recent common ancestor; \textbf{then}, \textit{go} to \ref{1stDp:enter}.
    \item \label{1stDp:enter} \sout{\textbf{If} both node's descendants have at least one applicable state in common, \textit{set} it to be the node state and \textit{go} to \ref{1stDp:exit}. \textbf{Else}, \textit{go} to \ref{1stDp:AND-}.}\textcolor{red}{[This isn't what happens in, for example, ((1,2),(3,4)); ... 0-0- , which reconstructs the ancestral node as -0 (not 0).]}
    \item \label{1stDp:AND-} \textbf{If} both descendants have only the inapplicable state, \textit{set} it to be the node state and \textit{go} to \ref{1stDp:exit}. \textbf{Else}, \textit{go} to \ref{1stDp:OR}.
    \item \label{1stDp:OR} \sout{\textbf{If} any of the descendants have an applicable state,}\textcolor{red}{[ALWAYS TRUE, or step \ref{1stDp:AND-} would have taken ELSE branch]}\sout{ \textit{set} the node's state to be the union the applicable states of its descendants and \textit{go} to \ref{1stDp:exit}.}\\
    \textcolor{blue}{\textbf{If} both descendants have an applicable state, \textit{set} the node's state to be the union of the descendants' states and \textit{go} to \ref{1stDp:exit}. \textbf{Else}, \textit{go} to \ref{1stDp:XOR}.
    \item \label{1stDp:XOR} \textbf{If} both descendants include an inapplicable state, \textit{set} the node's state to be the inapplicable state and \textit{go} to \ref{1stDp:exit}. \textbf{Else}, \textit{set} the node's state to be the union of the descendants' states and \textit{go} to \ref{1stDp:exit}.
    }
    \item \label{1stDp:exit} \textbf{If} possible, move to the node's ancestor and \textit{go} to \ref{1stDp:enter}; \textbf{else} move to the next unvisited cherry's ancestor and \textit{go} to \ref{1stDp:enter}. Once all nodes have been visited, end the first downpass.
\end{enumerate}
% Useful testing tree:
% (((((1,2),(3,4)),5),6),(7,(8,(9,(10,(11,12))))));
% 1-0-2-0-{01}-1-
\section{First uppass} \label{1stUp}

\begin{enumerate}
    \item Enter the tree on its root. \textbf{If} the root has any applicable state, remove the eventual inapplicable state. \textbf{Then} move to one of the root's descendants and \textit{go} to \ref{1stUp:enter}.
    \item \label{1stUp:enter} \textbf{If} the node has the inapplicable state, \textit{go} to \ref{1stUp:nodeNA1}; \textbf{else}, leave the node's state unchanged and \textit{go} to \ref{1stUp:exit}.
    \item \label{1stUp:nodeNA1} \textbf{If} the node also has an applicable state, \textit{go} to \ref{1stUp:nodeNAandA}; \textbf{else}, \textit{go} to \ref{1stUp:nodeNA2}.
    \item \label{1stUp:nodeNAandA} \textbf{If} the node's ancestor has an inapplicable state, \textit{set} the node's state to be the inapplicable state only; \textbf{else} \textit{set} the node's state to be the applicable states only. \textbf{Then} \textit{go} to \ref{1stUp:exit}.
    \item \label{1stUp:nodeNA2} \textbf{If} the node's ancestor has the inapplicable state, \textit{set} the node's state to be the inapplicable state only and \textit{go} to \ref{1stUp:exit}; \textbf{else} \textit{go} to \ref{1stUp:nodeNAOR}.
    \item \label{1stUp:nodeNAOR} \textbf{If} any of the descendants have an applicable state, then \textit{set} the node's state to be the union the applicable states of its descendants; \textbf{else} \textit{set} the node's state to be the inapplicable state only. \textbf{Then} \textit{go} to \ref{1stUp:exit}.
    \item \label{1stUp:exit} \textbf{If} any of the node's descendant is not a tip, move to the next node and \textit{go} to \ref{1stUp:enter}. \textbf{If} both descendants are tips, move to the closest non-visited node and \textit{go} to \ref{1stUp:enter}. Once all nodes have been visited, end the first uppass.
\end{enumerate}


\section{Second downpass} \label{2ndDp}

\begin{enumerate}
    \item  Enter on any cherry on the tree and move to its most recent common ancestor; \textbf{then}, \textit{go} to \ref{2ndDp:enter}.
    \item \label{2ndDp:enter} \textbf{If} there is any state in common between both descendants, \textit{go} to \ref{2ndDp:AND}; \textbf{else}, \textit{go} to \ref{2ndDp:OR}.
    \item \label{2ndDp:AND} \textbf{If} the states in common are applicable, \textit{set} the node's state to be these states in common without the eventual inapplicable token; \textbf{else} \textit{set} the node's state to be the inapplicable state. \textbf{Then} \textit{go} to \ref{2ndDp:exit}. 
    \item \label{2ndDp:OR} \textit{Set} the node's state to be the union of the applicable states of both descendants and \textit{go} to \ref{2ndDp:CountChange}.
    \item \label{2ndDp:CountChange} \textbf{If} both descendants have an applicable state, \textbf{\textit{increment}} the tree length (change increment) and \textit{go} to \ref{2ndDp:exit}; \textbf{else} \textit{go} to \ref{2ndDp:CountRegion}.
    \item \label{2ndDp:CountRegion} \textbf{If} both node's descendants had at least an applicable state in the previous pass (First uppass - for tips with missing data, use the current node's previous pass states instead), \textbf{\textit{increment}} the tree length (applicable region increment) \textbf{then} \textit{go} to \ref{2ndDp:exit}; \textbf{else} just \textit{go} to \ref{2ndDp:exit}.
    \item \label{2ndDp:exit} \textbf{If} possible, move to the node's ancestor and \textit{go} to \ref{2ndDp:enter}; \textbf{else} move to the next unvisited cherry's ancestor and \textit{go} to \ref{2ndDp:enter}. Once all nodes have been visited, end the second downpass.
\end{enumerate}

\section{Second uppass} \label{2ndUp}

\begin{enumerate}
    \item Enter the tree on its root and move to one of the root's descendants. \textbf{Then} \textit{go} to \ref{2ndUp:enter}.
    \item \label{2ndUp:enter} \textbf{If} the node has any applicable state, \textit{go} to \ref{2ndUp:nodeA}; \textbf{else}, \textit{go} to \ref{2ndUp:CountRegion}.
    \item \label{2ndUp:nodeA} \textbf{If} the node's ancestor has any applicable state, \textit{go} to \ref{2ndUp:ancestorA1}; \textbf{else}, \textit{go} to \ref{2ndUp:ancestorNA}.
    \item \label{2ndUp:ancestorA1} \textbf{If} the node states are the same as its ancestor, \textit{go} to \ref{2ndUp:exit}; \textbf{else}, \textit{go} to \ref{2ndUp:ancestorA2}.
    \item \label{2ndUp:ancestorA2} \textbf{If} there is any state in common between the node's descendants, \textit{go} to \ref{2ndUp:ANDdesc}; \textbf{else} \textit{go} to \ref{2ndUp:ORdesc}.
    \item \label{2ndUp:ANDdesc} \textit{Add} to the current node any state in common between its ancestor and its descendants. Then \textit{go} to \ref{2ndUp:exit}.
    \item \label{2ndUp:ORdesc} \textbf{If} the union between the node's descendants contains the inapplicable state, \textit{go} to \ref{2ndUp:ORdescNA}; \textbf{else} \textit{go} to \ref{2ndUp:ORdescA}.
    \item \label{2ndUp:ORdescNA} \textbf{If} there is any state in common between the node's descendants and ancestor, \textit{set} the node's states to be its ancestor's; \textbf{else} \textit{add} to the current node states the applicable states also found in its descendants and ancestor. \textbf{Then} \textit{go} to \ref{2ndUp:exit}.
    \item \label{2ndUp:ORdescA} \textit{Add} to the node's states the states of its ancestor. \textbf{Then} \textit{go} to \ref{2ndUp:exit}.
    \item \label{2ndUp:ancestorNA} \textbf{If} there is any state in common between both descendants, \textit{set} them to be the node's states. \textit{Go} to \ref{2ndUp:exit}. %TG: No else
    \item \label{2ndUp:CountRegion} \textbf{If} both node's descendants had at least an applicable state in the previous pass (Second Downpass), \textbf{\textit{increment}} the tree length (applicable region increment) \textbf{then} \textit{go} to \ref{2ndUp:exit}; \textbf{else} \textit{go} to \ref{2ndUp:exit}.
    \item \label{2ndUp:exit} \textbf{If} any one of the node's descendants is not a tip, move to the next node and \textit{go} to \ref{2ndUp:enter}. \textbf{If} both descendants are tips, move to the closest non-visited node and \textit{go} to \ref{2ndUp:enter}. Once all nodes have been visited, end the second uppass.
\end{enumerate}

The tree length is then equal to the number of state changes and the number of additional applicable regions.

\end{document}
