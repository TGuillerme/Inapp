---
title: "Implications for character coding"
author: "Martin R. Smith"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
bibliography: ../inst/REFERENCES.bib
csl: https://raw.githubusercontent.com/citation-style-language/styles/master/apa-old-doi-prefix.csl
vignette: >
  %\VignetteIndexEntry{6. Implications for characters}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{R initialize, message=FALSE, include=FALSE}
library(knitr); library('Inapp')
quickPlot <- function (tree, character, subtitle="", na=TRUE) {
  tree$edge.length <- rep(1, dim(tree$edge)[1])
  reconstruction <- apply.reconstruction(tree, character, 
                            method=if(na) "NA" else 'Fitch',
                            match.tip.char=TRUE)
  dev.new(); plot(tree); corners <- par('usr'); dev.off()
  plot(reconstruction,
       passes=if(na) 1:4 else 1:2, counts=1:2,
       col.states=TRUE, use.edge.length=TRUE, x.lim=c(-3, corners[2]))

  text(-2.7, 1, subtitle, pos=4)
}

```

# Inapplicable data in a parsimony setting

This is one of a series of vignettes that works through the inapplicable algorithm proposed by Brazeau _et al._ [-@ThisStudy].

We assume that you'll already have read the [description](OurAlgorithm.html) of our algorithm.

## How this algorithm weights against multiple innovations

- We saw in an earlier section that step counts can be avoided by causing multiple innovations
- Our algorithm counterbalances that by charging a levy for each innoation of the parent character
- This has a side-effect that we'll study with an invariant character

## Multiple dependencies

- It's not a problem to have characters dependent on characters that are dependent on characters.
- This is our chance to respond to Goloboff's point 6.

## A parsimony uninformative character that informs parsimony!

- All tails are blue.  Let's say that they are all blue for some complex molecular reason, such that it is most parsimonious if "blueness" has a single evolutionary origin.

```{r tail colour characters, echo = FALSE, results='asis'}
tail <- c(0, 0, 0, 0, 1, 1, 1, 1)
col <- c(rep('-', 4), rep(1, 4))
bcol <- c(1,1, 2,2,2,2, 1,1)
blueTails <- matrix(c(tail, col, bcol), byrow=TRUE, ncol=length(tail))
colnames(blueTails) <- LETTERS[seq_along(tail)]
rownames(blueTails) <- c("Tail: (0), absent; (1), present",
                         "Tail colour: (-), inapplicable; (1), blue",
                         "Body colour: (1), black; (2), white")
kable(blueTails, capiton="Coding")
```

- This complex molecular reason is grounds to suspect that the tails have a common ancestor
- More formally, we wish to attribute this complex molecular reason to common ancestry, rather than homoplasy
- Thus "blueness" represents a separate character that has the same distribution as tails (or a sbuset thereof, if some tails are of uncertain colour)

Let's compare two trees.  One groups taxa based on the presence of tails; the other
groups taxa based on body colour.

```{R invariant yet informative, echo=FALSE, fig.height=6}
par(mfrow=c(3, 2), mar=c(2, 0.2, 0.2, 0.2), oma=c(1:4))
tailTree <- ape::read.tree(text="((((A:1, B:1):1, C:1):1, D:1):1, (E:1, (F:1, (G:1, H:1):1):1):1);")
bodyTree <- ape::read.tree(text="((((F, E), C), D), (A, (B, (G, H))));")
tail <- "00001111"
col <- "----1111"
bcol <- "11222211"

quickPlot(tailTree, tail, "Tail presence", FALSE)
quickPlot(bodyTree, tail, "Tail presence", FALSE)
quickPlot(tailTree, col, "Tail colour")
quickPlot(bodyTree, col, "Tail colour")
quickPlot(tailTree, bcol, "Body colour", FALSE)
quickPlot(bodyTree, bcol, "Body colour", FALSE)


```

- So the tree on the left, which reconstructs a single origin of the tail, a single origin of a blue tail colouration, and two changes in body colour, is preferred to the tree on the right, which reconstructs a single change in body colour but two origins of the tail, and two origins of blue colouration on the tail.

- We should include this character if it's meaningful.  But not if it's not (e.g. number of base pairs in a tail).


## Neomorphic and transformational characters

Researchers should be aware that our algorithm treats nemorphic characters as though they are transformational; that is, "absence" of a feature is seen as equally informative as "presence".  In some cases, this may be desirable: For example, it is not difficult to argue that "serrated margin on tail: present / absent" behaves as a transformational character, as a tail must have a margin of some sort, and "serratedness" is a property of the margin.  

In other cases, this may not be desirable.  As an example, consider a complex character, such as the eyespots on the tail of a peacock.  

```{r tail eyespot characters, echo = FALSE, results='asis'}

tail <- c(0, 0, 0, 1, 1, 1, 1, 1, 1)
eyespot <- c("-", "-", "-", 0,0,0,0,1,1)

tailEyes <- matrix(c(tail, eyespot), byrow=TRUE, ncol=length(tail))
colnames(tailEyes) <- LETTERS[seq_along(tail)]
rownames(tailEyes) <- c("Tail: (0), absent; (1), present",
                        "Tail eyespots: (-), inapplicable; (0), absent; (1), present")
kable(tailEyes, capiton="Coding")
```

The presence of tail eyespots obviously contains grouping information, but it is less obvious whether the absence of such complex features should convey grouping information.  This decision ought to be defended for individual characters by individual researchers, but researchers should be aware of the implications of their chosen coding strategy. 

```{R tail spot alternatives, echo=FALSE, fig.height=8, fig.width=4}
par(mfrow=c(3, 1), mar=c(0.2, 0.2, 0.2, 0.2))
splitSpots <- ape::read.tree(text="(((H, C), A), (B, (D, (E, (G, (F, H))))));")
naysHaveIt <- ape::read.tree(text="((((H, I), C), A), (B, (D, (E, (G, F)))));")
eyesHaveIt <- ape::read.tree(text="(((((H, I), G), C), A), (B, (D, (E, F))));")
#tail <- "000111111"
col <- "---000011"

quickPlot(naysHaveIt, col, "One tail spotted, one not")
quickPlot(splitSpots, col, "Two spot appearances")
quickPlot(eyesHaveIt, col, "Two non-spotted appearances")

```

All of these trees imply two independent origins of the tail.  Their score differs only with respect to the eyespots character.


The fisrt tree has the minimum possible score for the eyespots character.  (A score of one would also be obtained if the tail evolved once, and a single transformation occurred between 0 and 1 -- but we are only considering trees where the tail evolved twice.)  

The next tree has a score of two for the eyespots character, which is obviously correct: Eye spots, a complex character, have evolved twice independently, which is not as parsimonious.

The final tree also has a score of two for the eyespots character: even though eyespots have only evolved once, just as in the first tree.  The score of two occurs because the "absence of eyespots" has evolved twice.  

It is possible that a researcher might feel uncomfortable grouping taxa on the basis of the non-occurrence of a complex feature that did not occur in their common ancestor.  Putting this another way, it is not clear that the fact that a feature has not evolved in two instances represents a homoplasy.  The absence of eyespots in a tail is not an evolutionary innovation -- it is an inheritance from a common ancestor that did not have eyespots (and did not have a tail).

A researcher that argues that the absence of a feature contains phylogenetic information must surely include all properties of a tail that are only observed in a single taxon (because the absence of that feature in other taxa also contains grouping information).  A researcher may also include all properties of a tail that do not occur in any of the taxon in interest, for these too will influence tree topology.


```{r Glowing in the dark 2, echo = FALSE, results='asis'}

tail <- c(0, 0, 0, 1, 1, 1, 1)
gitd <- c("-", "-", "-", "{01}","{01}",0,0)
elec <- c("-", "-", "-", "{01}","{01}",0,0)

unobserved <- matrix(c(tail, gitd, elec), byrow=TRUE, ncol=length(tail))
colnames(unobserved) <- LETTERS[seq_along(tail)]
rownames(unobserved) <- c("Tail: (0), absent; (1), present",
                        "Tail with glow-in-the-dark pigment: (-), inapplicable; (0), absent; (1), present",
                        "Tail with ability to generate electricity: (-), inapplicable; (0), absent; (1), present")
kable(unobserved, capiton="Coding")
```

Note that each of the unobserved characters provides evidence against independent origins of the tail, preferring instead independent losses:

```{R unobserved character 2, echo=FALSE, fig.height=3.2, fig.width=8}
par(mfrow=c(1, 2), mar=c(0.2, 0.2, 0.2, 0.2), oma=c(1,0,0,0), cex=0.8)
better <- ape::read.tree(text="(((F, G), C), (A, (B, (D, E))));")
worse  <- ape::read.tree(text="(((F, C), G), (A, (B, (D, E))));")
col <- "---{01}{01}00"

quickPlot(better, col, "")
mtext("Tail with glow-in-the-dark pigment: (-), inapplicable; (0), absent; (1), present",
      side=1, line=0, outer=TRUE)
quickPlot(worse, col, "")

```

Thus the simple matrix presented above sees both of these trees as equally parsimonious -- three losses of a single-origin tail that lacks two unlikely attributes is considered as likely as one independent gain of a similar tail.  

This behaviour is desired if the similarity between the tails requires an evoltuionary explanation.  But the absence of these features does not seem any more difficult to explain if the tails do not have a common ancestor.

The solution here is to deploy a different character coding strategy, coding absences as absences.  That way, absence CAN be inherited from a common ancestor, in whcih the a compelx-feature-of-the-tail (eyespots, glow-inthe-dark pigment) was absent (and the tail was absent too).

```{r Glowing in the dark 3, echo = FALSE, results='asis'}

tail <- c(0, 0, 0, 1, 1, 1, 1)
gitd <- c(0, 0,0, "{01}","{01}",0,0)
elec <- c(0,0,0, "{01}","{01}",0,0)

unobserved <- matrix(c(tail, gitd, elec), byrow=TRUE, ncol=length(tail))
colnames(unobserved) <- LETTERS[seq_along(tail)]
rownames(unobserved) <- c("Tail: (0), absent; (1), present",
                        "Tail with glow-in-the-dark pigment: (-), inapplicable; (0), absent; (1), present",
                        "Tail with ability to generate electricity: (-), inapplicable; (0), absent; (1), present")
kable(unobserved, capiton="Coding")
```

This can be handled by the Fitch algorithm, and works well in simple cases:
```{R unobserved character 3, echo=FALSE, fig.height=3, fig.width=8}
par(mfrow=c(1, 2), mar=c(0.2, 0.2, 0.2, 0.2), oma=c(1,0,0,0), cex=0.8)
better <- ape::read.tree(text="(((F, G), C), (A, (B, (D, E))));")
worse  <- ape::read.tree(text="(((F, C), G), (A, (B, (D, E))));")
col <- "000{01}{01}00"

quickPlot(better, col, "", na=FALSE)
mtext("Tail with glow-in-the-dark pigment: (-), inapplicable; (0), absent; (1), present",
      side=1, line=0, outer=TRUE)
quickPlot(worse, col, "", na=FALSE)

```

The behaviour only becomes questionable when a tail is secondarily lost, then re-gained, as the loss of a tail seems like it should be a single evolutionary step, but also causes the loss of all contingent characters, which must then "reevolve" as though they had never existed:

```{R loss and gain, echo=FALSE}
par(mfrow=c(1, 1), mar=c(0.2, 0.2, 0.2, 0.2), oma=c(1,0,0,0))
imbal <- ape::read.tree(text="(A, (B, (C, (D, (E, (F, G))))));")
tail <- "1100011"
eyespots <- "1100011"

quickPlot(imbal, eyespots, "", na=FALSE)
mtext("Tail eyespots: (0), absent; (1), present", side=1, line=0, outer=TRUE)


```

Perhaps there are cases -- as might be seen in phenotypic plasticity -- where a tail might be lost, and then re-activate preexisting genes when it evolves again?  This starts to require an explicit model of evolution, however, which is somewhat beyond the remit of parsimony.

### Recommendation
- Neomorphic characters should probably be coded as absent everywhere they are absent, whether this is because there's no tail or because there's a tail without the complex feature.

### Ambiguity

Should ? be scored as (01) or (-01)?

If you're coding a neomorphic character as transformational, then you encounter problems.

```{R Untitled 4, echo=FALSE, fig.height=3, fig.width=6}
par(mfrow=c(1, 2), mar=c(0.2, 0.2, 0.2, 0.2), oma=c(1,0,0,0), cex=0.8)
better <- ape::read.tree(text="(((F, G), C), (A, (B, (D, E))));")
worse  <- ape::read.tree(text="(((F, C), G), (A, (B, (D, E))));")
tail <- "0001111"
col <- "---{01}{01}00"

quickPlot(better, col)
quickPlot(worse, col)

mtext(side=1, line=0, "Tail with glow-in-the-dark pigment: (-), inapplicable; (0), absent; (1), present", cex=0.8, outer=TRUE)

```


### Difficulties
Here are some marginal cases where discretion is required.
Here are some trees that show why we would code things our way
this is why you need to look at your data carefully and see whether you like what your mode of coding is implying!
