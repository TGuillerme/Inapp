--- 
title: "Inapplicable data"
author: "Martin Brazeau (m.brazeau@imperial.ac.uk), Thomas Guillerme (guillert@tcd.ie) and Martin Smith (martin.smith@durham.ac.uk)"
date: "`r Sys.Date()`"
site: bookdown::bookdown_site
output: bookdown::gitbook
documentclass: book
bibliography: [../References.bib, packages.bib]
csl: https://raw.githubusercontent.com/citation-style-language/styles/master/apa-old-doi-prefix.csl
link-citations: yes
github-repo: TGuillerme/Inapp
description: "Inapplicable data in a parsimony setting"
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Inapplicable data in a parsimony setting {-}

This document `r if(knitr::is_latex_format()) "(also available as an [HTML webpage](https://rawgit.com/TGuillerme/Inapp/master/inst/gitbook/_book/index.html))"` provides a detailed explanation of the algorithm for handling
inapplicable data proposed by @Brazeau2018.

We first discuss how the [Fitch algorithm](#fitch) works and introduce
the [problems](#problems) that it encounters in the face of inapplicable character states.

We then introduce our [solution](#solution), a new [algorithm](#algorithm), implemented in
various [software packages](#software), and discuss its
implications for the coding of [characters](#coding) and [ambiguity](#ambiguity).

We close with some [example](#examples) trees that demonstrate how our algorithm behaves in more complicated cases.

<!--chapter:end:index.Rmd-->

---
title: "The Fitch Algorithm"
author: "Thomas Guillerme; Martin R. Smith"
---

```{r, echo = FALSE, message=FALSE}
library('Inapp'); library('ape')
setMargins <- function () par(mar=rep(0.2, 4))
markChanges <- function (edges, labels='X') edgelabels(frame='none', edge=edges, labels, font=2)
col.tips.nodes = c("#fc8d59", "#eeeeeed0", "#7fbf7be0", "#af8dc3e0")
redBlue <- colours <- c(Inapp::brewer[[2]], 'grey')
deltran <- '<span style="font-variant:small-caps;">DelTran</span>'
acctran <- '<span style="font-variant:small-caps;">AccTran</span>'
choose1 <- "[01]=>1"
```

# The Fitch algorithm {#fitch}

This algorithm was proposed by Fitch [-@Fitch1971] and is implemented in phylogenetic software that employs maximum parsimony [@swofford2001paup; @Goloboff2016] and probabilistic methods [@Ronquist2012mrbayes; @Stamatakis2014].
The simple and elegant procedure and entails going down the tree to count the number of transformations, then going back up the tree to finalise the ancestral state reconstructions.

The way the algorithm goes up and down depends on the software, but often employs a _traversal_: a recursive function that can visit all tips and nodes in a logical fashion.
For example, consider the following tree:

```{r, echo = FALSE, fig.width=5, fig.height=4, fig.cap="A five-tip tree"}
setMargins()
tree <- ape::read.tree(text = "(((a, b), (c, d)), e);")
tree$node.label <- c("n4", "n3", "n1", "n2")
plot(tree)
nodelabels(tree$node.label)
```

A downpass traversal will first evaluate the first cherry (or pair of taxa) (`A` below), then save the results in `n1` and evaluate the second pair of tips/nodes (`B`), saving the results in `n2`, proceeding until all the nodes and tips have been visited.

```{r, echo = FALSE, fig.width=5, fig.height=4, fig.cap="Downpass traversal"}
setMargins()
plot(tree)
nodelabels(tree$node.label)

## a
a <- c(4, 1.2)
## b
b <- c(4, 1.8)
## c
c <- c(4, 3.2)
## d
d <- c(4, 3.8)
## e
e <- c(4, 4.8)
## n2
n2_1 <- c(3.2, 3.5)
n2_2 <- c(2.8, 3.3)
## n1
n1_1 <- c(3.2, 1.5)
n1_2 <- c(2.8, 1.7)
## n3
n3_1 <- c(1.2, 2.5)
n3_2 <- c(0.8, 2.7)
## n4
n4 <- c(0.2, 3.75)

## First cherry
arrows(a[1], a[2], n1_1[1], n1_1[2]-0.025, length = 0.05)
arrows(b[1], b[2], n1_1[1], n1_1[2]+0.025, length = 0.05)
points(3.8, 1.5, cex = 3)
text(3.8, 1.5, "A", cex = 1)
## Second cherry
arrows(d[1], d[2], n2_1[1], n2_1[2]+0.025, length = 0.05)
arrows(c[1], c[2], n2_1[1], n2_1[2]-0.025, length = 0.05)
points(3.8, 3.5, cex = 3)
text(3.8, 3.5, "B", cex = 1)
## Third
arrows(n1_2[1], n1_2[2], n3_1[1], n3_1[2]-0.025, length = 0.05)
arrows(n2_2[1], n2_2[2], n3_1[1], n3_1[2]+0.025, length = 0.05)
points(2.5, 2.5, cex = 3)
text(2.5, 2.5, "C", cex = 1)
## Fourth
arrows(n3_2[1], n3_2[2], n4[1], n4[2]-0.025, length = 0.05)
arrows(e[1], e[2], n4[1], n4[2]+0.025, length = 0.05)
points(0.7, 3.5, cex = 3)
text(0.7, 3.5, "D", cex = 1)
```

An uppass traversal works identically but in the other direction, going from the nodes towards the tips.

```{r, echo = FALSE, fig.width=5, fig.height=4, fig.cap="Uppass traversal"}
setMargins()
plot(tree)
nodelabels(tree$node.label)

## First cherry
arrows(n1_1[1], n1_1[2]-0.025, a[1], a[2], length = 0.05)
arrows(n1_1[1], n1_1[2]+0.025, b[1], b[2], length = 0.05)
points(3.8, 1.5, cex = 3)
text(3.8, 1.5, "D", cex = 1)
## Second cherry
arrows(n2_1[1], n2_1[2]+0.025, d[1], d[2], length = 0.05)
arrows(n2_1[1], n2_1[2]-0.025, c[1], c[2], length = 0.05)
points(3.8, 3.5, cex = 3)
text(3.8, 3.5, "C", cex = 1)
## Third
arrows(n3_1[1], n3_1[2]-0.025, n1_2[1], n1_2[2], length = 0.05)
arrows(n3_1[1], n3_1[2]+0.025, n2_2[1], n2_2[2], length = 0.05)
points(2.5, 2.5, cex = 3)
text(2.5, 2.5, "B", cex = 1)
## Fourth
arrows(n4[1], n4[2]-0.025, n3_2[1], n3_2[2], length = 0.05)
arrows(n4[1], n4[2]+0.025, e[1], e[2], length = 0.05)
points(0.7, 3.5, cex = 3)
text(0.7, 3.5, "A", cex = 1)
```

In both traversals, the sequence in which nodes are visited (i.e. which cherry to pick first in a downpass traversal, or whether to continue left or right in an uppass traversal) is arbitrary, provided that all tips and nodes are eventually visited.

Now let's consider a more complex tree `((((a, b), c), d), (e, (f, (g, h))));` with a binary character distributed `((((1, 0), 0), 1), (1, (0, (0, 1))))`:


```{r, echo = FALSE, fig.width = 6, fig.height = 5}
tree <- ape::read.tree(text = "((((a, b), c), d), (e, (f, (g, h))));")
char <- c(1,0,0,1,1,0,0,1)

## Plotting the tree and characters
setMargins()
plot(tree, adj = 0.5)
tiplabels(char, cex = 1, bg = Inapp::brewer[[2]][char + 1], adj = 1)
nodelabels(paste0("n", 9:15), bg = "bisque")

```

We can use the `Inapp` package to apply the Fitch algorithm for this character on this tree.

```{r, echo=TRUE}
## Loading the Inapp package
library(Inapp)

## The tree
tree <- read.tree(text = "((((a, b), c), d), (e, (f, (g, h))));")

## The character
character <- "10011001"

## Applying the Fitch algorithm
matrix <- apply.reconstruction(tree, character, method = "Fitch", passes = 2)
```

## Downpass

The downpass is quite simple and follows these rules for the two possible cases in the traversal [@Fitch1971]:

 1. If the two considered tips or nodes have _at least one state in common_, set the node to be these states in *common*.
 2. Else, if there is _nothing in common_ between the to tips or nodes, set the node to be the *union* of the two states.

For example, node `n15` is case 2 because there is _nothing in common_ between the tips `h` and `g` (states `1` and `0` respectively). Node `n14` is case 1 because there is _at least one state in common_ between the tip `f` and the node `n15` (state `0`).

> Important: when the case 2 is encountered, a transformation is implied in the descendants of the considered node. The score of the tree is incremented by +1.

In the following example, nodes that are in case 1 are in white and nodes in case 2, which imply a transformation (i.e. that adds to the tree score), are in green.


```{r, fig.width = 7.1, fig.height = 7.1, fig.cap="Node reconstructions after downpass"}
## Plotting the first downpass
plot.states.matrix(matrix, passes = 1, counts = 2, show.labels = c(1,2))
tiplabels(char, cex = 1, bg = Inapp::brewer[[2]][char + 1], adj = 1)
```

## Uppass

The score of the tree is known after the downpass, but the states of some nodes might not yet be properly resolved.
For example, parsimonious reconstructions exist that reconstruct node `n14` as state `1`, as opposed to the `0` presently reconstructed. 
The present reconstruction seemingly indicates a change from state 1 to state 0 in an ancestor of `n14`, and a subsequent change from state 0 to state 1 in the ancestor of `h`, but an alternative reconstruction is equally parsimonious: `n13`, `n14` and `n15` may all have state `1`, with a change from state `1` to state `0` in each of the two lineages leading to `f` and `g`.

The uppass traversal employs the following rules [@Fitch1971]:

 1. If the current node and its ancestor have _all states in common_, the node is already resolved.
 2. If there is _at least one state in common_ between both left and right tips or nodes directly descended from the current node, resolve the node as being _the states in common_ between its ancestor and both his descendants.
 3. If there is _there are no states in common_ between its descendants, resolve the node as being _the states in common_ between the ancestor and the current node.


For example, node `n13` is already resolved (it has all its states in common with the ancestor - case 1).
Node `n14` has not all its states in common with its ancestor but its two descendants (`n15` and `f`) have at least one state in common (`0`).
This node is thus solved to be the states in common between both descendants (`01`) and its ancestor (`01` as well).

```{r, fig.width = 7.1, fig.height = 7.1, fig.cap="Node reconstructions after uppass"}
## Plotting the first uppass
plot.states.matrix(matrix, passes = 1:2, counts = 2,
                   show.labels = c(1, 2), col.states=TRUE)
```

More complex cases can be studied in the Inapp App (running in your favourite web browser) by switching the **`Reconstruction method`** to **`Normal Fitch`**.

```{r, eval = FALSE}
## Running the Inapp App
runInapp()
```

## Resolving ambiguous resolutions

In certain cases, it is necessary to go further and discriminate between the equally-parsimonious reconstructions provided by the Fitch algorithm.
A number of approaches have been proposed concerning which resolution of ambiguous
nodes is preferable.

The two most familiar approaches to resolving ambiguous node are the Accelerated Transformation (`r acctran`) and Delayed Transformation (`r deltran`) approaches
[@Farris1970;@Swofford1987].

The `r acctran` approach reconstructs transformations as occurring as close to the root as possible; the `r deltran`, as far from the root as possible.

In this case, the ambiguous resolution of the root leaves two options for the latter:

(ref:fig-cap-trans) Node reconstructions after `r acctran` or `r deltran` optimizations

```{r, echo = FALSE, fig.width = 7.1, fig.height = 7.1, fig.cap="(ref:fig-cap-trans)"}
par(mfrow=c(2, 2), mar=rep(1, 4))

tree <- read.tree(text = "((((a, b), c), d), (e, (f, (g, h))));")
tree$tip.label <- paste("_", tree$tip.label)
char <- c(1,0,0,1,1,0,0,1)

edge_col <- Inapp::brewer[[2]][c(2,2,1,  2,1,1,2,
                                 2,2,2,  1,1,1,2)]

graphics::plot(tree, show.tip.label = TRUE, main='AccTran',
               type = "phylogram", use.edge.length = TRUE, cex = 1, adj = 0,
               edge.color = edge_col, edge.width = 2,
               x.lim=c(-0.5, 8), y.lim=c(0.5, 8.5))

node_labels <- paste(paste("Acc:", sep = ""), c(1,1,0,0,1,0,0))
node_labels <- paste(paste("n", 9:15, "\n", sep = ""), node_labels, sep = "")

ape::nodelabels(node_labels, cex = 0.9, bg = col.tips.nodes[c(2,3,2,3,3,2,3)])

tiplabels(char, cex = 1, bg = colours[char + 1], adj = 1)
markChanges(c(2, 4, 10, 14))

edge_col <- redBlue[c(2, 2, 2, 2, 1, 1, 2, 2, 2, 2, 1, 2, 1, 2)]

graphics::plot(tree, show.tip.label = TRUE, main='DelTran',
               type = "phylogram", use.edge.length = TRUE, cex = 1, adj = 0,
               edge.color = edge_col, edge.width = 2,
               x.lim=c(-0.5, 8), y.lim=c(0.5, 8.5))

node_labels <- paste(paste("Del:", sep = ""), rep(1, 7))
node_labels <- paste(paste("n", 9:15, "\n", sep = ""), node_labels, sep = "")

ape::nodelabels(node_labels, cex = 0.9, bg = col.tips.nodes[c(2,3,2,3,3,2,3)])

tiplabels(char, cex = 1, bg = colours[char + 1], adj = 1)
markChanges(c(5, 6, 11, 13))

plot(1, type="n", axes=F, xlab="", ylab="")
#edge_col <- Inapp::brewer[[2]][3-c(2,2,1,1,  1,1,2,
#                                 2,2,2,1,  1,1,2)]
#
#graphics::plot(tree, show.tip.label = TRUE, main='AccTran',
#               type = "phylogram", use.edge.length = TRUE, cex = 1, adj = 0,
#               edge.color = edge_col, edge.width = 2)
#
#node_labels <- paste(paste("Acc:", sep = ""), 1-c(1,1,0,0,1,0,0))
#node_labels <- paste(paste("n", 9:15, "\n", sep = ""), node_labels, sep = "")
#
#ape::nodelabels(node_labels, cex = 0.9, bg = col.tips.nodes[c(2,3,2,3,3,2,3)])
#
#tiplabels(char, cex = 1, bg = colours[char + 1], adj = 1)
#edgelabels(frame='none', edge=c(2, 4, 10, 14), "X", col=col.tips.nodes[3])


edge_col <- redBlue[c(1, 1, 1, 2, 1, 1, 2, 1, 2, 1, 1, 1, 1, 2)]

graphics::plot(tree, show.tip.label = TRUE, main='Acc/DelTran',
               type = "phylogram", use.edge.length = TRUE, cex = 1, adj = 0,
               edge.color = edge_col, edge.width = 2,
               x.lim=c(-0.5, 8), y.lim=c(0.5, 8.5))

node_labels <- paste(paste("Del:", sep = ""), rep(0, 7))
node_labels <- paste(paste("n", 9:15, "\n", sep = ""), node_labels, sep = "")

ape::nodelabels(node_labels, cex = 0.9, bg = col.tips.nodes[c(2,3,2,3,3,2,3)])

tiplabels(char, cex = 1, bg = colours[char + 1], adj = 1)
markChanges(c(4, 7, 9, 14))

```

If the states `0` and `1` represent states of a transformational character -- 
whether an organism's tail is red or blue, say -- then there is no reason to prefer
any of the equally-parsimonious reconstructions, as none implies any more homology
than any other.

With neomorphic characters, however, state `0` stands for the absence of a character
-- for example, a tail --
and state `1` its presence.  On one view, a reconstruction that minimises the number
of times that such a character evolves attributes more similarity to homology than 
an equally parsimonious reconstruction in which said character is gained multiple times
independently.

### Maximising homology

Neither `r acctran` nor `r deltran` is guaranteed to maximise homology [@Agnarsson2008]. 
In this particular case, the `r deltran` reconstruction maximises homology.  If the
character denotes the presence or absence of a tail, then this reconstruction invokes the presence of a tail in the common ancestor of all taxa, meaning that the tails present in
tips `a`, `d`, `e` and `h` are homologous with one another.
The `r acctran` reconstruction, in contrast, identifies a loss of a tail
at nodes 11 and 14, with a tail evolving independently in tips `a` and `h`. 
Under this reconstruction, the tails of `a` and `h` are not homologous with each other, or with the tails of `d` and `e`.
(The alternative `r deltran` approach, which could arguably be described as `r acctran` instead, invokes four independent origins of the character and clearly does not maximise its homology.)

Where we wish to maximise homology, we modify the Fitch uppass such that any node
whose final state reconstruction would be ambiguous is instead reconstructed as present when that node is encountered.
This approach maximises homology in the problematic trees presented by 
Agnarsson & Miller [-@Agnarsson2008; "A&M" below]:

```{r, echo = FALSE, fig.width = 7.1, fig.height = 4, fig.cap="Homology-maximising character optimisations"}
par(mfrow=c(1, 2), mar=rep(0.75, 4))
tree <- read.tree(text = "(H, (G, (F, (E, (D, (C, (B, A)))))));")
tree$tip.label <- paste("_", tree$tip.label)
char <- c(0,0,1,1,1,0,1,0)

edge_col <- Inapp::brewer[[2]][c(1,1,1,rep(2, 7), 1, 2, 2, 1)]

graphics::plot(tree, show.tip.label = TRUE, main='A&M fig. 2',
               type = "phylogram", use.edge.length = TRUE, cex = 1, adj = 0,
               edge.color = edge_col, edge.width = 2, direction='upwards',
               x.lim = c(0.7200000, length(char) + 0.5),
               y.lim = c(-0.5, length(char) + 0.5))


down_labels <- paste("1:", c(0, 1, '01')[c(1, 3, 2, 2, 3, 1, 3)])
up_labels <- paste("2:",   c(0,0,1,1,1,choose1,1)) # n14 informs n15
#node_labels <- paste(paste("n", 9:15, sep = ""), down_labels, up_labels, sep = "\n")
node_labels <- paste(down_labels, up_labels, sep = "\n")

ape::nodelabels(node_labels, cex = 0.9, bg = col.tips.nodes[c(2,3,2,2,3,2,3)])

tiplabels(char, cex = 1, bg = colours[char + 1], adj = 1)
markChanges(c(4, 11, 14), c('0->1', '1->0', '1->0'))
# Check that this is how our algorithm works with the following lines:
#toInapp <- function (x) rev(c('-', '0')[x + 1])
#vignettePlot(tree, toInapp(char), passes=1:2, legend.pos='none')
#vignettePlot(tree, rev(char), na=FALSE, passes=1:2, legend.pos='none')

tree <- read.tree(text = "(J, (I, (H, (G, (F, (E, (D, (C, (B, A)))))))));")
tree$tip.label <- paste("_", tree$tip.label)
char <- c(0,0,1,0,1,1,1,0,1,0)

edge_col <- Inapp::brewer[[2]][c(1,1,1,2, 2, 2,1,2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 1)]

graphics::plot(tree, show.tip.label = TRUE, main='A&M fig. 3',
               type = "phylogram", use.edge.length = TRUE, cex = 1, adj = 0,
               edge.color = edge_col, edge.width = 2, direction='upwards',
               x.lim = c(0.7200000, length(char) + 0.5),
               y.lim = c(-0.5, length(char) + 0.5))

down_labels <- paste("1:", c(0, 1, '01')[c(1,3,2,3,2,2,3,1,3)])
up_labels <- paste("2:",   c(0,0, choose1, rep(1, length(char) - 6), choose1, 1))
#node_labels <- paste(paste("n", 9:15, sep = ""), down_labels, up_labels, sep = "\n")
node_labels <- paste(down_labels, up_labels, sep = "\n")

ape::nodelabels(node_labels, cex = 0.9, bg = col.tips.nodes[c(2,3,2,3,2,2,3,2,3)])

tiplabels(char, cex = 1, bg = colours[char + 1], adj = 1)
#edgelabels()
markChanges(c(4, 7, 15, 18), c('0->1', rep('1->0', 3)))


# Check that this is how our algorithm works with the following lines:
#vignettePlot(tree, toInapp(char), passes=1:2, legend.pos='none')
#vignettePlot(tree, rev(char), na=FALSE, passes=1:2, legend.pos='none')


```

This approach is also robust to missing entries:

```{r, echo = FALSE, fig.width = 7.1, fig.height = 4, fig.cap="Homology maximisation with missing entries"}
par(mfrow=c(1, 2), mar=rep(0.75, 4))
tree <- read.tree(text = "(F, (E, (D, (C, (B, A)))));")
tree$tip.label <- paste("_", tree$tip.label)
char <- c(0,0, '?', 1, 1, 1)

edge_col <- redBlue[c(1,1,1,rep(2, 11))]

graphics::plot(tree, show.tip.label = TRUE, main='A&M fig. 4a',
               type = "phylogram", use.edge.length = TRUE, cex = 1, adj = 0,
               edge.color = edge_col, edge.width = 2, direction='upwards',
               x.lim = c(0.7200000, length(char) + 0.5),
               y.lim = c(-0.5, length(char) + 0.5))

down_labels <- paste("1:", c(0, 1, '01')[c(1, 3, 2, 2, 2)])
up_labels <- paste("2:",   c(0, 0, 1, 1, 1))
node_labels <- paste(down_labels, up_labels, sep = "\n")

ape::nodelabels(node_labels, cex = 0.9, bg = col.tips.nodes[c(2,3,2,2,2)])

tiplabels(char, cex = 1, bg = colours[c(1,1,3,2,2,2)], adj = 1)
markChanges(4, '0->1')
# Check that this is how our algorithm works with the following lines:
#vignettePlot(tree, c(2,2,2, '?', '-', '-'), passes=1:2, legend.pos='none')
#vignettePlot(tree, rev(char), na=FALSE, passes=1:2, legend.pos='none')

char <- c(0,0,'?', 1, 0, 1)
edge_col <- Inapp::brewer[[2]][c(1,1,1,2,2, 2, 2, 2, 1, 2)]

graphics::plot(tree, show.tip.label = TRUE, main='A&M fig. 4b',
               type = "phylogram", use.edge.length = TRUE, cex = 1, adj = 0,
               edge.color = edge_col, edge.width = 2, direction='upwards',
               x.lim = c(0.7200000, length(char) + 0.5),
               y.lim = c(-0.5, length(char) + 0.5))

down_labels <- paste("1:", c(0, 1, '01')[c(1,3,2,2,3)])
up_labels <- paste("2:",   c(0, 0, choose1, 1, 1))
node_labels <- paste(down_labels, up_labels, sep = "\n")

ape::nodelabels(node_labels, cex = 0.9, bg = col.tips.nodes[c(2,3,2,2,3)])

tiplabels(char, cex = 1, bg = colours[c(1,1,3,2,1,2)], adj = 1)
markChanges(c(4, 9), c('0->1', rep('1->0', 1)))


# Check that this is how our algorithm works with the following lines:
#vignettePlot(tree, c(2, '-', 2, '?', '-', '-'), passes=1:2, legend.pos='none')
#vignettePlot(tree, rev(char), na=FALSE, passes=1:2, legend.pos='none')

```

<!--chapter:end:01_Fitch.Rmd-->

---
title: "Inapplicable data with the Fitch algorithm"
author: "Martin R. Smith"
---

```{r, echo=FALSE, message=FALSE}
library('Inapp')
library('ape')
ap <- c("Absent", "Present")
rb <- c("Red", "Blue")
redBlue <- TreeSearch::brewer[[2]]
orb <- c('', rb)

yesCol <- "#7fbf7be0"
noCol <- "#fc8d5960"

setPar <- function (mfrow=c(1, 2)) par(mfrow=mfrow, mar=c(0.2, 0.2, 1, 0.2), oma=c(0,0,0,0), cex=0.7)
```

# Problems with the Fitch algorithm {#problems}

The Fitch algorithm [@Fitch1971] counts changes in a character.
It assumes that the character is applicable throughout the tree.
This assumption does not lead to error if:

- The character is inapplicable in fewer than three tips; or

- In the trees being considered, applicable and inapplicable tokens occur
  in distinct regions of the tree [@Maddison1993].


## Red tails, blue tails
Maddison [-@Maddison1993] provided the following example to demonstrate
the problem encountered by the Fitch algorithm when inapplicable
characters were present.


Consider the following tree, each node of which is supported by a number of
characters.  Tail colour (illustrated; 0 = red, 1 = blue) has not yet been 
considered, but has the potential to resolve the polytomy on the left hand side (bold).

```{r, echo=FALSE, fig.height=5, fig.width=7.1}
par(mar=rep(0.2, 4))
treeUnresolved <- ape:::read.tree(text="(((((A, B, C, D), e), f), g), (h, (i, (j, (K, (L, (M, N)))))));")
treeUnresolved$edge.length <- rep(1, dim(treeUnresolved$edge)[1])
edgeWidths <- rep(2, dim(treeUnresolved$edge)[1])
edgeWidths[5:8] <- 4
plot(treeUnresolved, direction='upwards', use.edge.length=TRUE, show.tip.label=FALSE,
     edge.width = edgeWidths)
c0 <- Inapp::brewer[[2]][1]
c1 <- Inapp::brewer[[2]][2]
cX <- "#cccccc"
tiplabels(c(0, 1, 0, 1, rep('-', 6), 1, 1, 0, 0), bg=c(c0, c1, c0, c1, rep(cX, 6), c1, c1, c0, c0))
     
```

In the bold region, tail colour should group the red-tailed tips together, and the blue-tailed tips together,
but does not establish whether the ancestor of the left-hand tail-bearing clade had a red or blue tail.

```{r, echo=FALSE, fig.width=6, fig.height=4, fig.cap="Possible resolutions for bold region of tree. Good resolutions imply one change; bad ones, two."}
setPar(c(2, 3))
pair <- ape::read.tree(text="(((a, b), (c, d)));")
walk <- ape::read.tree(text="((a, (b, (c, d))));")
c0011<- c(0, 0, 1, 1)
c0101 <- c(0, 1, 0, 1)
pair$edge.length <- walk$edge.length <- rep(1, 8)

plot(pair, direction='upwards', use.edge.length=TRUE, show.tip.label=FALSE,
     edge.width=2, main = "Good")
tiplabels(c0011, bg=redBlue[c0011 + 1])
plot(walk, direction='upwards', use.edge.length=TRUE, show.tip.label=FALSE,
     edge.width=2, main='Equally good')
tiplabels(c0011, bg=redBlue[c0011 + 1])
plot(walk, direction='upwards', use.edge.length=TRUE, show.tip.label=FALSE,
     edge.width=2, main='Equally good')
tiplabels(rev(c0011), bg=redBlue[2 - c0011])
plot(pair, direction='upwards', use.edge.length=TRUE, show.tip.label=FALSE,
     edge.width=2, main = "Bad")
tiplabels(c0101, bg=redBlue[c0101 + 1])
plot(walk, direction='upwards', use.edge.length=TRUE, show.tip.label=FALSE,
     edge.width=2, main='Equally Bad')
tiplabels(c0101, bg=redBlue[c0101 + 1])
plot(walk, direction='upwards', use.edge.length=TRUE, show.tip.label=FALSE,
     edge.width=2, main='Equally Bad')
tiplabels(rev(c0101), bg=redBlue[2 - c0101])
```

## Reductive coding

Under reductive coding, the tail and its colour are described in two character statements:

> Tail: (0), absent; (1), present.
>
> Tail, colour: (0), red; (1), blue; (?), inapplicable.

Consider the following two trees, each of which receives a score of two for the first
character (presence of tail).  The score of the second character (tail colour)
is not as desired.

The Fitch algorithm will prefer trees in which the left-hand tail-bearing clade
has a blue tail, simply because the right-hand tail-bearing clade ancestrally did.

```{r, echo=FALSE, fig.height=9, fig.width=7.1}
par(mar=rep(0.2, 4), mfrow=c(2, 1), cex=0.8)
treeA <- ape::read.tree(text="(((((((A, B), C), D), e), f), g), (h, (i, (j, (K, (L, (M, N)))))));")
treeB <- ape::read.tree(text="(((((A, (B, (C, D))), e), f), g), (h, (i, (j, (K, (L, (M, N)))))));")
vignettePlot(treeA, '0011------1100', na=FALSE, state.labels=rb)     
vignettePlot(treeB, '0011------1100', na=FALSE, state.labels=rb)
```

Notice the additional step reconstructed at the root node: the Fitch algorithm
reconstructs a change in tail colour in a taxon that doesn't have a tail!

This reconstruction is not logically consistent.

### An exception

If the parent character can parsimoniously be reconstructed as present at every internal node in a single unbroken region of a tree, and nowhere else, then reductive coding does work successfully.  Reductive coding may therefore be appropriate if only a subset of all possible trees are under consideration, and is always (i.e. for all trees) appropriate if a character exhibits fewer than three inapplicable tokens.

## Inapplicable as an extra state

An alternative is to code the inapplicable token as an extra state:

> Tail: (0), absent; (1), present.
>
> Tail, colour: (0), red; (1), blue; (2), inapplicable.

This seems to resolve the problem case that we encountered with reductive coding:

```{r, echo=FALSE, fig.height=9, fig.width=7.1}
par(mar=rep(0.2, 4), mfrow=c(2, 1), cex=0.8)
treeA <- ape::read.tree(text="(((((((A, B), C), D), e), f), g), (h, (i, (j, (K, (L, (M, N)))))));")
treeB <- ape::read.tree(text="(((((A, (B, (C, D))), e), f), g), (h, (i, (j, (K, (L, (M, N)))))));")
vignettePlot(treeA, '00112222221100', na=FALSE, state.labels=c(rb, 'Inapplicable'))     
vignettePlot(treeB, '00112222221100', na=FALSE, state.labels=c(rb, 'Inapplicable'))     
```

Both trees now receive the same score for the 'tail colour' character, which 
contributes four steps.  Two of these steps, however, correspond to steps that have
already been counted in the parent character, reflecting the two gains of a tail.

Although this reconstruction is logically consistent, the gain (or loss) of the tail
is now reflected in two characters -- characters are not independent of one another.

The outcome is that each ontologically dependent character serves to increase
the weight of its parent character.  The loss of a tail, for example, would
incur a cost of one step in the tail character and one step in each 
ontologically dependent character, even though it represents a single
evolutionary event.

## A single multi-state character

A different approach is to use a single character to denote both the 
presence and the colour of the tail:

> Tail: (0), absent; (1), present, red; (2), present, blue.

This seems to resolve the problem case that we encountered with reductive coding:

```{r, echo=FALSE, fig.height=9, fig.width=7.1}
par(mar=rep(0.2, 4), mfrow=c(2, 1), cex=0.8)
treeA <- ape::read.tree(text="(((((((A, B), C), D), e), f), g), (h, (i, (j, (K, (L, (M, N)))))));")
treeB <- ape::read.tree(text="(((((A, (B, (C, D))), e), f), g), (h, (i, (j, (K, (L, (M, N)))))));")
vignettePlot(treeA, '11220000002211', na=FALSE, state.labels=c('Absent', 'Present, red', 'Present, blue'))     
vignettePlot(treeB, '11220000002211', na=FALSE, state.labels=c('Absent', 'Present, red', 'Present, blue'))     
```

However, we now have a situation where the gain/loss of a tail is afforded the same weight 
as a change in tail colour.  We ought to prefer a tree where the tail evolved once
(and changed colour) to one where it evolved twice (being a different colour each time).

```{r, echo=FALSE, fig.width=6, fig.height=5}
par(mar=rep(0.2, 4), mfrow=c(2, 1), cex=0.8)
simpleTree <- ape::read.tree(text="((((a, b), c), e), (f, g));")
vignettePlot(simpleTree, "110022", na=FALSE)
nodelabels("+ Tail\n", c(7, 9), pos=3, bg=NA, frame='no', font=2)
text(4, 4.1, "Two gains of tail", cex=1.2)

vignettePlot(simpleTree, "112200", na=FALSE)
nodelabels("+ Tail\n", 8, pos=3, bg=NA, frame='no', font=2)
text(4, 4.1, "One gain of tail (preferable)", cex=1.2)

```

## Sankoff matrices

It would be possible to establish a Sankoff matrix [@Sankoff1975;@Sankoff1983]
such that a change between absent and red or absent and blue cost more than 
a change between red and blue, but this effectively up-weights the tail character,
and it's not clear that this is desirable -- or how much this extra weight
should be [@Maddison1993].

### Symmetric

Consider a character with three ontologically dependent characters:

> Presence: Absent / present
>
> Colour: Red / blue
>
> Covering: Scaly / hairy
>
> Shape: Straight / curly

This could be coded as a single transformation series using a Sankoff matrix:

```{r, echo = FALSE, results='asis'}
dots <- rep('.', 3)
state <- c(0:3, dots, 8)
costs <- matrix(c(
  c(0, 4, 4, 4, dots, 4),
  c(4, 0, 1, 1, dots, 3),
  c(4, 1, 0, 2, dots, 2),
  c(4, 1, 2, 0, dots, 2),
  c(rep('.', 4), 0, rep('.', 3)),
  c(rep('.', 5), 0, rep('.', 2)),
  c(rep('.', 6), 0, rep('.', 1)),
  c(4, 3, 2, 2, dots, 0)) , byrow=TRUE, ncol=length(state))
costNames <- c("(0), absent", 
                     "(1), present, red, scaly, straight",
                     "(2), present, red, scaly, curly",
                     "(3), present, red, hairy, straight",
                     dots,
                     "(8), present, blue, hairy, curly")
sankoffCaption <- "Tail: Cost to go from left state to top state:"
colnames(costs) <-  state
rownames(costs) <- costNames
knitr::kable(costs, caption=sankoffCaption)

```

The first thing to note is that each additional ontologically depedent character
generates disproportionately more complexity in the Sankoff matrix.

Even if this additional complexity could be handled, the underlying issue remains
that losing a tail, which arguably corresponds to a single evolutionary
event, is allocated a large cost (here, 4) that grows in line with the number of 
ontogenetically dependant characters.

### Gain and loss asymmetric

At the cost of symmetry, one could argue that the loss of a tail requires a single
transformation, whereas the gain requires the addition of a tail and the "setting"
of each ontologically dependent character, rendering an asymmetric Sankoff
matrix that nevertheless respects triangular inequality [@Wheeler1993]:

```{r, echo = FALSE, results='asis'}
costs <- matrix(c(
  c(0, 4, 4, 4, dots, 4),
  c(1, 0, 1, 1, dots, 3),
  c(1, 1, 0, 2, dots, 2),
  c(1, 1, 2, 0, dots, 2),
  c(rep('.', 4), 0, rep('.', 3)),
  c(rep('.', 5), 0, rep('.', 2)),
  c(rep('.', 6), 0, rep('.', 1)),
  c(1, 3, 2, 2, dots, 0)) , byrow=TRUE, ncol=length(state))
colnames(costs) <-  c('(0)', '(1)', '(2)', '(3)', '.', '.', '.', '(8)')
rownames(costs) <- costNames
knitr::kable(costs, caption=sankoffCaption)

```

Here, though, we encounter a new problem: reconstructions involving very many losses 
are preferred to those involving a single gain.

```{r, echo=FALSE, fig.height=7.2, fig.width=6.6}
setPar(c(2, 1))
par(mar=c(0.2, 0.2, 4.2, 0.2))
sankTree <- ape::read.tree(text="(((((a, b), c), dX), eX), (fX, (gX, (p, (q, r)))));")
#vignettePlot(sankTree, '1110000888', na=FALSE, legend='none', blankNodes=TRUE)
sankTree$edge.length <- rep(1, dim(sankTree$edge)[1])
c1 <- brewer[[3]][1]
c0 <- brewer[[3]][2]
c8 <- brewer[[3]][3]
plot(sankTree, show.tip.label=FALSE, direction='upwards', edge.width=2,
     edge.col= c(c0, c0, c1, c1, c1, c1, c1, rep(c0, 6), rep(c8, 5)))
tiplabels(c(1,1,1,0,0,0,0,8,8,8), bg=c(rep(c1, 3),
                                       rep(c0, 4),
                                       rep(c8, 3)))
legend('bottomleft', bty='n', bg = NULL, pch=15, col="#7fbf7be0", pt.cex=1.8,
      legend = "Two gains: cost = 8") 
nodelabels(c("0->1 (+4)", "0->8 (+4)"), node=c(13, 17), bg="#7fbf7b00", pos=3, frame='no', col="#7fbf7be0", font=2)

plot(sankTree, show.tip.label=FALSE, direction='upwards', edge.width=2,
     edge.col= c(rep(c1, 7), c0, c0, c8, c0, c8, c0, rep(c8, 5)))
edgelabels()
tiplabels(c(1,1,1,0,0,0,0,8,8,8), bg=c(rep(c1, 3),
                                       rep(c0, 4),
                                       rep(c8, 3)))
legend('bottomleft', bty='n', bg = NULL, pch=15, col="#af8dc3e0", pt.cex=1.8,
      legend = "Four losses: cost = 7") 
nodelabels(c("1->8 (+3)", rep("1->0 (+1)",  2), rep("8->0 (+1)", 2)), node=c(11:13, 16:17), 
           bg="#af8dc300", pos=3, frame='no', col="#af8dc3e0", font=2)
```

## Why counting steps cannot work

The failure of the Sankoff approach illustrates a more general problem:
if the only thing that is counted is the number of steps, then trees that 
imply multiple gains and losses of a principal character are not adequately penalised.

To illustrate this point, consider counting only transitions between applicable states
(i.e. steps), but not transitions from the applicable state to the inapplicable state:

```{r, echo=FALSE, fig.width=6, fig.height=5, fig.cap="Tail colour optimization"}
setPar(c(1,1))
tree <- ape::read.tree(text="((((a, b), c), d), (e, (f, ((g, h), (i, j)))));")
vignettePlot(tree, '11----1122', passes=1:2, legend.pos='none',
            state.labels=orb, counts=2)

nodelabels(node=c(13, 16), pch=15, col=noCol, cex=7)

legend('bottomleft', bty='n',
       c('State change: +1 step', 'Change from inapplicable to applicable: +0 steps'),
       pch=15, pt.cex=1.5, col=c(yesCol, noCol))
```

The number of steps can be minimized by maximizing the number of independent gains of a parent character.

```{r, echo=FALSE, fig.width=7.1, fig.height=2.8}
comb15 <- ape::read.tree(text="(((((a, c), d), e), f), (g, (i, (j, (v, (w, (x, (y, z))))))));")
comb5i <- ape::read.tree(text="(((((vv, c), d), yy), f), (g, (xx, (j, (k, (ww, (m, (n, zz))))))));")

char <- '0000000011111'
sub1 <- '--------12222'
sub2 <- '--------11222'
sub3 <- '--------11122'
sub4 <- '--------11122'
sub5 <- '--------11112'

setPar(c(1, 2))
Compare <- function (char.states, char.label, states.labels, top=FALSE) {
    vignettePlot(comb15, char.states, na=!top, 
                 counts=2, passes=4 - (2 * top),
                 legend.pos='none', state.labels=states.labels)
    legend('topleft', char.label, bty='n')
    legend('bottomleft', pch=15, pt.cex=1.5, col=yesCol, bty='n', "+1 step")
    if (top) title('Single gain of tail (total score = 6)')
    
    vignettePlot(comb5i, char.states, na=!top, 
                 counts=2,  passes=4 - (2 * top),
                 legend.pos='none', state.labels=states.labels)
    if (!top)  legend('bottomleft', pch=1 , pt.cex=1.5, col=yesCol, bty='n', "+0 steps") 
    if (top) legend('bottomleft', pch=15, pt.cex=1.5, col=yesCol, bty='n', "+5 steps") 
    if (top) title('Five gains of tail (total score = 5)')
        
}

Compare(char, 'Tail, presence', ap, TRUE)
Compare(sub1, 'Tail, colour', orb)
Compare(sub2, 'Tail, covering', c("", "Scaly", "Hairy"))
Compare(sub3, 'Tail, shape', c("", "Straight", "Curly"))
Compare(sub4, 'Tail, margin', c("", "Smooth", "Serrated"))
Compare(sub5, 'Tail, poison barbs', c("", "Absent", "Present"))


```

## Conclusion

No coding mechanism can generate consistent and logically meaningful tree scores
when employing the Fitch algorithm.  A new algorithm is needed: one that counts
homoplasies instead of steps.
  

<!--chapter:end:02_problems.Rmd-->

---
title: "The solution: Count homologies"
author: "Martin R. Smith; Thomas Guillerme; Martin D. Brazeau"
---

# A solution {#solution}

```{r, echo=FALSE, message=FALSE}
library('ape')
library('Inapp')
ap<-c('Absent', 'Present')
rb <- c('Red', 'Blue')
orb <- c('', rb)
ia <- c('Inapplicable', 'Applicable')

setPar <- function (mfrow=c(1, 2)) par(mfrow=mfrow, mar=c(0.2, 0.2, 1, 0.2), oma=c(0,0,0,0), cex=0.7)

leafy <- '#7fbf7be0'
lilac <- '#af8dc3e0'

tree12 <- ape::read.tree(text='((((((a, b), c), d), E), F), (G, (H, (i, (j, (k, l))))));')
```

## Minimising homoplasy

A solution can be found if the goal of parsimony is recast not in terms of minimising the number of steps, but instead of minimising the amount of homoplasy in a tree.

De Laet has made this point before [@DeLaet2005; -@DeLaet2015], suggesting that a tree's score should be calculated as 

> Total score = Number of steps + Number of (additional) regions.

Practically, because the number of unavoidable regions is a function of a dataset and not of a tree, one could alternatively count 

> Total score = Number of steps + Number of regions

which would be a constant number larger than the total score generated just counting additional regions; the absolute value of the score is not meaningful in itself and is not comparable between datasets, so the calculation method does not affect tree search.

The tree below gives an example of a tree in which a character in applicable in two regions (one more than the minimum possible, one) and one state change. 

```{r, echo=FALSE, fig.width=6, fig.height=5}
setPar(c(1,1))
vignettePlot(tree12, '1100----0000', na=TRUE, passes=0, state.labels=rb)
#nodelabels(node=17, pch=15, col='#7fbf7be0', cex=2.5)
#nodelabels(node=c(16, 21), pch=15, col='#af8dc3e0', cex=2.5)

edgelabels(edge=5, pch=15, col=leafy, cex=2.5)
edgelabels(edge=c(3, 16), pch=15, col=lilac, cex=2.5)

```

This score denotes two evolutionary observations that cannot be attributed to inheritance from a common ancestor: the blueness of tail in the blue tailed taxa (as the common ancestor inherited a red tail), and the redness of tail in the second region of the tree (as the common ancestor of all tail-bearing taxa did not itself have a tail, so tail colour could no be inherited).


### What does it take to denote separate regions?

It takes three inapplicable nodes (including tips) to force two regions of the tree to be separrated by an inapplicable region.

This can be estabilshed by imagining the Fitch optimisation of a separate character

> Applicability of the character of interest: (0), inapplicable; (1), applicable

In the case of tail colour, this applicability character has the same distribution as the presence / absence of the tail, but this is not necessarily the case (there may be a range of reasons to code a character as inapplicable).

In the tree shown above, the Fitch algorithm identifies two regions where the applicability character is unambiguously 'applicable':

```{r, echo=FALSE, fig.width=6, fig.height=5}
setPar(c(1,1))
vignettePlot(tree12, '111100001111', na=FALSE, passes=1:2, state.labels=ia, legend.pos='none')
```

If one of the inapplicable tips had instead been ambiguous, then the same distribution would arise:

```{r, echo=FALSE, fig.width=6, fig.height=5}
setPar(c(1,1))
vignettePlot(tree12, '111100?01111', na=FALSE, passes=1:2, state.labels=ia, legend.pos='none')
```

But if two were ambiguous, then the root of the tree could be parsimoniously reconstructed as 'applicable' -- with the two inapplicable tips becoming inapplicable in the branches that led to them:

```{r, echo=FALSE, fig.width=6, fig.height=5}
setPar(c(1,1))
vignettePlot(tree12, '1111?0?01111', na=FALSE, passes=1:2, state.labels=ia, legend.pos='none')
```

This reconstruction maximises the inferred homology between tails, and so increases the opportunity to attribute shared colours in the tail to common ancestry.  As such, our algorithm chooses to interpret this region as applicable whereever it parsimoniously can.

Note that the three inapplicable tips necessary to define an inapplicable region must be in a contiguous region of the tree, separated from one another only by taxa whose applicability is ambiguous, in order for two applicable regions to be reconstructed as separate.

### How this fixes the problem

This overcomes the problem where steps could be avoided by inferring multiple innovations of a character:

```{r, echo=FALSE, fig.width=7.1, fig.height=2.8, fig.cap="Reconstructions of tail presence and five contingent characters (only two shown)"}
comb15 <- ape::read.tree(text="(((((a, c), d), e), f), (g, (i, (j, (v, (w, (x, (y, z))))))));")
comb5i <- ape::read.tree(text="(((((vv, c), d), yy), f), (g, (xx, (j, (k, (ww, (m, (n, zz))))))));")

char <- '0000000011111'
sub1 <- '--------12222'
sub2 <- '--------11222'
sub3 <- '--------11122'
sub4 <- '--------11122'
sub5 <- '--------11112'

setPar(c(1, 2))
par(oma=c(3,0,0,0))
Compare <- function (char.states, char.label, states.labels, top=FALSE) {
    vignettePlot(comb15, char.states, na=!top, 
                 passes=4 - (2 * top),
                 legend.pos='none', state.labels=states.labels)
    legend('topleft', char.label, bty='n')
    legend('bottomleft', pch=15, pt.cex=1.5, col=leafy, bty='n', "+1 step")
    if (top) title('Single gain of tail (total score = 6)')
    
    vignettePlot(comb5i, char.states, na=!top, 
                 passes=4 - (2 * top),
                 legend.pos='none', state.labels=states.labels)
    if (!top)legend('bottomleft', pch=15, pt.cex=1.5, col=lilac, bty='n', "+4 regions") 
    if (top) legend('bottomleft', pch=15, pt.cex=1.5, col=leafy, bty='n', "+5 steps") 
    if (top) title('Five gains of tail (total score = 25)')
        
}

Compare(char, 'Tail, presence', ap, TRUE)
Compare(sub1, 'Tail, colour', orb)
Compare(sub2, 'Tail, covering', c("", "Scaly", "Hairy"))
mtext("\n... and for three more characters", outer=TRUE, side=1)
#Compare(sub3, 'Tail, shape', c("", "straight", "curly"))
#Compare(sub4, 'Tail, margin', c("", "smooth", "serrated"))
#Compare(sub5, 'Tail, poison barbs', c("", "absent", "present"))


```

On the other hand, if taxa either have a blue, scaly, straight tail or a red, smooth, curly tail, then the fact that the tails have so little in common means that it wouldn't be entirely surprising if the two different tail types evolved twice.  This scenario thus incurs a cost of only one step (for the additional origin of the tail) more than if the tail evolved once, and change all its attributes:

```{r, echo=FALSE, fig.width=8, fig.height=8, fig.cap="Reconstructions of tail presence and five contingent characters (only two shown)"}
comb15 <- ape::read.tree(text="(((((a, c), d), e), f), (g, (i, (j, (v, (w, (x, (y, z))))))));")
comb5i <- ape::read.tree(text="(((((xx, yy), zz), a), b), (c, (d, (e, (f, (g, (h, (vv, ww))))))));")

char <- '0000000011111'
sub1 <- '--------11222'

setPar(c(3, 2))
par(oma=c(3,0,0,0))
Compare <- function (char.states, char.label, states.labels, top=FALSE) {
    vignettePlot(comb15, char.states, na=!top, 
                 passes=4 - (2 * top),
                 legend.pos='none', state.labels=states.labels)
    legend('topleft', char.label, bty='n')
    legend('bottomleft', pch=15, pt.cex=1.5, col=leafy, bty='n', "+1 step")
    if (top) title('Single gain of tail (total score = 6)')
    
    vignettePlot(comb5i, char.states, na=!top, 
                 passes=4 - (2 * top),
                 legend.pos='none', state.labels=states.labels)
    if (!top)legend('bottomleft', pch=15, pt.cex=1.5, col=lilac, bty='n', "+1 region") 
    if (top) legend('bottomleft', pch=15, pt.cex=1.5, col=leafy, bty='n', "+2 steps") 
    if (top) title('Two gains of tail (total score = 7)')
        
}

Compare(char, 'Tail, presence', ap, TRUE)
Compare(sub1, 'Tail, colour', orb)
Compare(sub2, 'Tail, covering', c("", "Scaly", "Hairy"))
mtext("\n... and for three more characters", outer=TRUE, side=1)
#Compare(sub3, 'Tail, shape', c("", "straight", "curly"))
#Compare(sub4, 'Tail, margin', c("", "smooth", "serrated"))
#Compare(sub5, 'Tail, poison barbs', c("", "absent", "present"))


```

### Summary

This is the desired behaviour.  But how do we count this in practice?

In brief, we evaluate for each tip whether the character in question is applicable, inapplicable, or ambiguous (could be either), and use the standard Fitch algorithm on this applicability data to reconstruct the state of each internal node, reconstructing ambiguous nodes on the uppass as applicable.

This done, we conduct a second Fitch-like pass on the tree, in which we count transformations if they occur at nodes in which the character has been reconstructed as applicable.  Additional regions are also counted on this downpass, by counting nodes that are ancestral to an inapplicable region of the tree that itself leads to an as-yet-uncounted applicable region.


## Algorithmic implementation {#algorithm}

Consider a tree with 12 taxa and the following multi-state characters with inapplicable data `23--1??--032`; say the character is "colour of the tail" ranging from 0 to 3 (four colours).
Four taxa in our example have no tail (hence the inapplicable data `-`) and for two taxa, the data is missing (`?`- we don't known the colour of the tail or even whether the taxa have a tail or not).

```{r, echo = FALSE, fig.width = 7.1, fig.height = 7.1}
tree <- read.tree(text = "((((((1,2),3),4),5),6),(7,(8,(9,(10,(11,12))))));")
character <- "23--1??--032"

## Plotting the tree
plot(tree, adj = 0.5)
tiplabels(c("2","3","-","-","1","?","?","-","-","0","3","2"), cex = 1, bg = "orange", adj = 1)
nodelabels(paste0("n", 13:23), bg = "bisque")
```

We can use the `Inapp` package to apply our four-pass inapplicable algorithm to this character on this tree.

```{r}
## Loading the Inapp package
library(Inapp)

## The tree
tree <- read.tree(text = "((((((1,2),3),4),5),6),(7,(8,(9,(10,(11,12))))));")

## The character
character <- "23--1??--032"

## Applying the NA algorithm
matrix <- apply.reconstruction(tree, character, method = "NA")
```

Here is what is happening:

### Passes 1 & 2

The first two passes are a standard Fitch algorithm applied the the parent character of the studied character (see [Fitch algorithm](#fitch)) with a special rule for the inapplicable state (`-`).

For the first pass (first downpass):
 
 * If state in common between the two descendants is the inapplicable state, but that both have also applicable states, set the node's state to be the union between the descendants states (rather than their state in common).
 * If there is no state in common between the descendants and both descendants have applicable states, remove the inapplicable state from their union (rather than simply setting the nodal state to their union).

For the second pass (first uppass):

 * If the focal node has both applicable and inapplicable states, set it to be the inapplicable state only if its ancestor has also only the inapplicable state, else remove the inapplicable state.
 * If the focal node has only an inapplicable state and it's ancestor has not only the inapplicable state, set it to be the union between it's descendants states if their are both applicable, else, leave it as the inapplicable state.

```{r, fig.width = 7.1, fig.height = 7.1, fig.cap = "Inapplicable reconstruction after two passes"}
## Plotting the NA two first passes
plot(matrix, passes = c(1,2), counts = 0, 
     legend.pos = 'none', show.labels = c(1, 2))
```

The parent character can be considered as a binary character "presence (`1`) or absence (`0`) of a tail" that would be `11001??00111`.
The character would be reconstructed as:

```{r, fig.width = 7.1, fig.height = 7.1, fig.cap = "Fitch reconstruction of the parent character"}
## The parent character
parent_character <- "11001??00111"

## Applying the Fitch algorithm
matrix_parent <- apply.reconstruction(tree, parent_character, method = "Fitch")
plot(matrix_parent, passes = 1:2, legend.pos='none', show.labels = c(1, 2))
```

As you can see, both reconstructions are identical: nodes with no tail are denoted as `0` in the case of the "parent character" and as `-` for our current character.
Note however that contrary to the Fitch algorithm, there is no tree score counting in our algorithm for the two first passes.
Indeed, in the case of the Fitch reconstruction of the "parent character", the gain or losses of a tail are counted but not the changes in states for the subtending character (the tree score is 3 in Fitch, 5 in our case).

### Pass 3

The third pass further resolves ambiguities at nodal states.
If the node is applicable, the standard Fitch downpass comparisons between the descendants are applied (see [Fitch algorithm](#fitch)) but with the rules relative to the inapplicable state described for the first downpass above.

During this pass, we can also count the tree score.
This score is composed of both:
 
 * the change in states (e.g. the change in the colour of the tail)
 * the change between applicable and inapplicable regions (e.g. the change in the parent character: a gain or a loss of the tail)

The changes of states are calculated the same way as Fitch **for the applicable states only**:

 * If there is no state in common between both node's descendants and that the node, and its descendants have a least one applicable state, increment the tree score.

```{r, fig.width = 7.1, fig.height = 7.1, fig.cap="State changes"}
plot(matrix, passes = c(1,2,3), counts = 2, show.labels = c(1, 2))
```

For example, for node `n23`, there is no state in common between the tip `12` (`2`) and `11` (`3`), the tree score is incremented at this node (case `1` above).
Note, however, that for node `n21`, there is no state in common between node `n22` (`023`) and tip `9` (`-`) but the score is not incremented since it does not concern applicable states only.
In other words, there is no change in state at the node `n21` from the tail having a colour 0, 2 or 3 to the tail not being present (`-`) but rather a change in the parent character between presence and absence of the tail (present is `023` and absent is `-`).

#### Tracking applicable regions

To know whether any node leads to a region of applicable states we can use a "tracker" for each node that tells us at any moment whether descendants of a node contain applicable data or not.
When a node is inapplicable and has a descendant whose lineage leads to applicable regions, an extra applicable region is implied by the tree.
In other words, following our "colour of the tail" character, extra applicable regions imply independent appearances of the tail somewhere in the node's descendants.

The tracker is initialised during the *second pass* (first uppass) and is updated during the *third pass* (second downpass).
The tracker works as follows for each node's left and right descendants:
 
 * If the descendant state is applicable or leads to an applicable region, then the node leads to an applicable region; else, it does not. 

The trackers are initialised for each node during the first uppass and then propagated back down the tree during the second downpass.

Using these trackers, we can then increment the tree score for all changes that imply a new applicable region.
The switch to or from an inapplicable and applicable region are counted as follows:

  * If the node is inapplicable and both descendants lead to regions of applicable states, increment the region count.
  * If the node is applicable, but has an inapplicable descendant that leads to a region of applicable states, increment the region count.


```{r, fig.width = 7.1, fig.height = 7.1, fig.cap="Counting applicable regions"}
plot(matrix, passes = c(1,2,3), counts = 1, show.labels = c(1, 2))
```

For example, node `n15` is solved as inapplicable but both his descendants lead to two independent applicable regions (tip `5` with the state `1` and node `n18` with the states `1` and `2`).
This implies an independent change in the parent character (in our example, tail is absent at node `n15` but evolves independently at tip `5` and node `n18`).
Conversely, node `n21` is solved as inapplicable but not both his descendants lead to independent applicable regions.
This node does thus not imply an independent change in the parent character.

> Note that the number of applicable regions for a character is always at least 1 (unless every taxa has the inapplicable state) and therefore, we only count the *additional* regions.


Combining both scores -- the number of changes in character states and the number of additional applicable regions -- we get indeed a total tree score of 5 for this character on this tree.

```{r, fig.width = 7.1, fig.height = 7.1}
## Plotting the NA two first passes
plot(matrix, passes = c(1,2,3), counts = c(1,2), show.labels = c(1,2))
```

Using the first three passes is enough to get the tree score (while taking into account inapplicable data!) but does not solve all ancestral reconstructions.
A fourth pass (second uppass) might be necessary to finalise the node states reconstructions.

### Pass 4

In the example above, the node `n23` is still not correctly solved after the third pass.
It could conceivably be state 0 (with transformations to states `2` and `3` occurring on the branches leading to tips 11 and 12 respectively).
As such, its final state reconstruction should be `023`.
To reach the correct final reconstructions, we apply a final pass of the algorithm.
This algorithm, similarly to the second pass of the Fitch algorithm is used to solve ambiguities in the ancestral nodes reconstructions (although the score of the tree is already known).
It follows these rules and only applies to nodes and ancestors that have at least one applicable token for themselves and their ancestor(nodes that are inapplicable are already solved):

 * If there is a state _in common_ between the node and its ancestor or between the ancestor and the states _in common_ of its descendants, resolve the node to be this state in common.
 * If there is nothing in common between the node and its ancestor or between its descendants, solve the node as either:
    1. being the ancestors state if the any of the descendants' have at least one inapplicable state but no state in common with the ancestor.
    2. being the union of the ancestor's and the descendants' states if the any of the descendants have at least one inapplicable and have at least one state in common with the ancestor.
    3. being the union of the ancestor's and the current node states the descendants have no inapplicable state.

```{r, fig.width = 7.1, fig.height = 7.1}
plot(matrix, passes = c(1,2,3,4), counts = c(1,2), show.labels = c(1,2))#, col.states=TRUE)
```

## Software implementation {#software}

This algorithm has been implemented in two `R` packages.  [Inapp](https://github.com/TGuillerme/Inapp) provides an interactive 
visualization of how the score of a user-specified tree is calculated for any
character under different approaches to inapplicable data. This package was used to generate many of the figures in this document.

[TreeSearch](https://github.com/ms609/TreeSearch) allows for parsimony tree
searches with the inapplicable algorithm [@Brazeau2018].  
It includes heuristic search options that make it possible to search reasonable-sized matrices, and includes an option for equal or implied weighting.

TreeSearch is a front-end to the [morphylib](https://github.com/mbrazeau/morphylib) 
`C` library, which will eventually implemented in the standalone [Morphy](http://www.morphyproject.org/) program for rapid phylogenetic searches.

<!--chapter:end:03_ourSolution.Rmd-->

---
title: "Implications for character coding"
author: "Martin R. Smith"
---


```{r, message=FALSE, include=FALSE}
library('knitr'); library('Inapp')
quickPlot <- function (tree, character, na=TRUE, legend.pos='bottomleft') {
  tree$edge.length <- rep(1, dim(tree$edge)[1])
  reconstruction <- apply.reconstruction(tree, character, 
                            method=if(na) "NA" else 'Fitch',
                            match.tip.char=TRUE)
  dev.new(); plot(tree, direction='upwards'); corners <- par('usr'); dev.off()
  plot(reconstruction,
       passes=if(na) 1:4 else 1:2, counts=1:2, 
       direction='upwards', legend.pos=legend.pos,
       col.states=TRUE, use.edge.length=TRUE, 
       x.lim=c(-3, corners[2]), y.lim=c(-1, corners[4]+0.1))
}
setPar <- function (mfrow=c(1, 2)) par(mfrow=mfrow, mar=c(0.2, 0.2, 0.66, 0.2), oma=c(1,0,0,0), cex=0.7)

ap <- c("Absent", "Present")
rb <- c("Red", "Blue")
bw <- c('', 'Black', 'White')
```

# Coding data {#coding}

The availability of our algorithm has some implications for how investigators
might choose to code characters. 

## Multiple dependencies

It's not a problem to have characters dependent on characters that are dependent
on characters.  Consider the following characters, whose descriptions are written in order to emphasize their heirarchical nature [following the recommendations of @Sereno2007]:

> 1. Appendages: (0), absent; (1), present.
>
> 2. Appendages, termination: (0), blunt; (1), sucker; (2), claw.
>
> 3. Appendages, suckers, morphology: (0), round; (1), polygonal.
>
> 4. Appendages, claws, morphology: (0), smooth; (1), serrated.

The included taxa may or may not bear appendages; if they do, then the 
appendages may end either with either claws or suckers, or neither (but not both).
Claws come in two flavours, smooth and serrated; suckers come in two shapes,
rounded and polygonal.

 - If character 1 (appendages) is absent, then characters 2--4 are inapplicable.
Otherwise, charcter 2 (appendage termination) must take one of the three applicable values.

 - If character 2 (termination) has state 0 (blunt), then characters 3 and 4 
(morphology of sucker / claw) are inapplicable.

 - If character 2 (termination) has state 1 (sucker), then character 3
(sucker morphology) is applicable and character 4 (claw morphology) is inapplicable.

 - If character 2 (termination) has state 2 (claw), then character 3 
(sucker morphology) is inapplicable and character 4 (claw morphology) is 
applicable.

A sample character matrix might look like this:

```{r, echo=FALSE, asis=TRUE}
nNone <- 3
c1 <- c(rep(0, nNone), rep(1, 10))
c2 <- c(rep('-', nNone), rep(1, 2), rep(2, 4), rep(3, 4))
c3 <- c(rep('-', nNone + 2), 1, 1, 2, 2, rep('-', 4))
c4 <- c(rep('-', nNone + 2 + 4), 1, 1, 2, 2)
mDep <- matrix(c(c1, c2, c3, c4), byrow=TRUE, ncol=length(c1))
colnames(mDep) <- LETTERS[seq_along(c1)]
rownames(mDep) <- c("Appendages: (0), absent; (1), present.",
                    "Appendage termination: (1), blunt; (2), sucker; (3), claw.",
                    "Sucker morphology: (1), smooth; (2), serrated.", 
                    "Claw morphology: (1), round; (2), polygonal.")
knitr::kable(mDep, caption="Heirarchichal characters")
```

Which would plot on a tree thus:

```{r, echo=FALSE, fig.width=7.1, fig.height=2.8}
goodtree <- ape::read.tree(text="(a, (b, (c, ((d, e), ((f, (g, (h, i))), ((j, k), (l, m)))))));")
badtree <- ape::read.tree(text="(A, (C, (B, ((D, E), ((F, (J, (K, I))), ((G, H), (L, M)))))));")
par(mfrow=c(1, 2), cex=0.7, mar=c(0, 0.2, 0.6, 0.2), oma=c(0, 0, 2, 0))

Contrast <- function (character, char.label, states.labels, y=0, header=FALSE) {
    vignettePlot(goodtree, character, na=!header, 
                 legend.pos='topleft', state.labels=states.labels, passes = 4 - (2 * header))
    text(14, y, char.label, pos=2)
    ape::tiplabels(LETTERS[1:13], frame='none', adj=c(0.5, -1.5))
    if (header) title("An optimal tree")
    vignettePlot(badtree, character, na=!header, 
                 legend.pos='topleft', state.labels=states.labels, passes = 4 - (2 * header))
    text(14, y, char.label, pos=2)
    ape::tiplabels(badtree$tip.label, frame='none', adj=c(0.5, -1.5))
    if (header) title("A suboptimal tree")
    
}

Contrast('0001111111111', "Appendages:", ap, header=TRUE, y=0.8)
Contrast('---0011112222', "Appendage termination:", c("Blunt", "Claw", "Sucker"), y=2.3)
Contrast('-----1122----', "Claw morphology:", c('', "Smooth", "Serrated"), y=1.6)
Contrast('---------1122', "Sucker morphology:", c('', "Round", "Polygonal"), y=1.6)
mtext("Appendage condition", outer=TRUE)

```

There's no limit to the depth of recursion: one could add a further character 

>  5. Appendages, claws, serrations, spacing: (1), regular; (2), irregular.
 
that would be inapplicable in all taxa that lacked serrated claws.

```{r, echo=FALSE, fig.width=8, fig.height=4}
setPar(c(1, 2))
Contrast('-------11----', "Serration spacing:", c('', "Regular", "Irregular"), y=0.2)
```

To readers familiar with standard Fitch parsimony, it will be surprising to notice that the two trees receive a different score for this invariant character.  When our algorithm is employed, invariant characters that contain inapplicable tokens can inform parsimony.

## Invariant characters can inform parsimony

Consider a situation in which every tail in the observed taxa is blue  -- but
the same complex molecular machinery is responsible for this blue colouration in 
every taxon.

If its underlying mechanism is considered biologically and evolutionarily meaningful, then 
a systematist might opt to include tail colour as an additional character, even
though it is invariant in the taxa of interest.  Reconstructions that attribute this
common colouration to common ancestry will be more parsimonious than those that do not.

```{r, echo = FALSE, results='asis'}
tail <- c(0, 0, 0, 0, 1, 1, 1, 1)
col <- c(rep('-', 4), rep(1, 4))
bcol <- c(1,1, 2,2,2,2, 1,1)
blueTails <- matrix(c(tail, col, bcol), byrow=TRUE, ncol=length(tail))
colnames(blueTails) <- LETTERS[seq_along(tail)]
rownames(blueTails) <- c("Tail: (0), absent; (1), present",
                         "Tail colour: (1), blue; (-), inapplicable",
                         "Body colour: (1), black; (2), white")
kable(blueTails, caption="An invariant character, tail colour, contributes as much to tree score as a variable one, body colour.")
```

Let's compare two trees.  The first groups taxa based on the presence of tails; the other
groups taxa based on body colour.  


```{r, echo=FALSE, fig.height=3, fig.width=8}
tailTree <- ape::read.tree(text="((((A:1, B:1), C), D:1):1, (E:1, (F:1, (G, H))));")
bodyTree <- ape::read.tree(text="((((F, E), C), D), (A, (B, (G, H))));")
tail <- "00001111"
col <- "----1111"
bcol <- "11222211"

par(mfrow=c(1, 2), mar=c(0, 0.2, 1.2, 0.2), oma=c(0, 0, 2, 0), cex=0.8)
vignettePlot(tailTree, tail, FALSE, main="Single tail gain\nTotal score: 3", cex.main=0.8, passes=2, state.labels=ap)
vignettePlot(bodyTree, tail, FALSE, main="Single body colour change\nTotal score: 4", cex.main=0.8, passes=2, state.labels = ap)
mtext("Tail presence", outer=TRUE)


vignettePlot(tailTree, col, passes=4, state.labels = rb)
vignettePlot(bodyTree, col, passes=4, state.labels = rb)
mtext("Tail colour", outer=TRUE)

vignettePlot(tailTree, bcol, FALSE, passes=4, state.labels = bw)
vignettePlot(bodyTree, bcol, FALSE, passes=4, state.labels = bw)
mtext("Body colour", outer=TRUE)
```

Where the tail has a single origin (one step), blue colouration also evolves once (zero steps), but body colour must change twice (two steps; total score = three).  But where body colour changes only once (one step), the tail necessarily arises twice (two steps), meaning two independent origins of its distinctive blue colouration (one extra homoplasy; total score = four)

If the invariant tail colour character had not been included, both trees would have the same score, and there would be nothing to choose between them.  As such, the inclusion or exclusion of invariant characters must be carefully evaluated: if there is a case that an invariant (ontologically dependent) character implies an exclusive common ancestry between those taxa that share it, then it should be included; if not, then it should be excluded.

## Variable but 'parsimony uninformative' characters can inform parsimony {#puip}

The same effect of course follows if a character has an additional state that is only observed in one taxon.

```{r, echo = FALSE, results='asis'}
tail <- c(0, 0, 0, 0, 1, 1, 1, 1, 1)
col <- c(rep('-', 4), rep(1, 4), '**2**')
bcol <- c(1,1, 2,2,2,2, 1,1, 1)
blueTails <- matrix(c(tail, col, bcol), byrow=TRUE, ncol=length(tail))
colnames(blueTails) <- LETTERS[seq_along(tail)]
rownames(blueTails) <- c("Tail: (0), absent; (1), present",
                         "Tail colour: (1), red; (2), blue; (-), inapplicable",
                         "Body colour: (1), black; (2), white")
kable(blueTails, caption="Tail colour is variable but 'parsimony uninformative'")
```

Any tree that implies that blueness evolves multiple times will incur an additional penalty that would not have been encountered had the tail colour character been omitted.


```{r, echo=FALSE, fig.height=3.5, fig.width=8, fig.cap="Tail colour"}
tailTree <- ape::read.tree(text="((((A, B), C), D), (E, (F, (G, (I, H)))));")
bodyTree <- ape::read.tree(text="((((F, E), C), D), (A, (B, (G, (I, H)))));")
#tail <- "000011111"
col <- "----11112"
#bcol <- "112222111"

par(mfrow=c(1, 2), mar=c(0, 0.2, 0.2, 0.2), oma=c(0, 0, 2, 0), cex=0.7)
vignettePlot(tailTree, col, passes=4, legend.pos='topleft', state.labels = c("", rb))
vignettePlot(bodyTree, col, passes=4, legend.pos='topleft', state.labels = c("", rb))
#mtext("Tail colour", outer=TRUE)
```

## This may not be desirable in neomorphic characters

The more general rule is that any tree that reconstructs the same state arising twice,
independently, in an ontologically dependent character will incur a penalty relative to one that reconstructs that same state arising once.

With transformational characters, this is often a desideratum -- as discussed above.

In certain neomorphic characters, however, it may not be desirable to penalise trees in which the _absence_ of a character arises multiple times.

Let us imagine that there is a biological reason to believe that tails in a particular
group lacked poisoned barbs when they first evolved: that is, poisoned barbs are an 
evolutionary innovation that can only be added to a tail once a tail is already present.

```{r, echo = FALSE, results='asis'}
tail <- c(0, 0, 0, 1, 1, 1, 1, 1, 1)
eyespot <- c("-", "-", "-", 0,0,0,0,1,1)

tailEyes <- matrix(c(tail, eyespot), byrow=TRUE, ncol=length(tail))
colnames(tailEyes) <- LETTERS[seq_along(tail)]
rownames(tailEyes) <- c("Tail: (0), absent; (1), present",
                        "Tail, poison barbs: (-), inapplicable; (0), absent; (1), present")
kable(tailEyes, caption="A neomorphic character, poison barbs, present in some but not all tails")
```

### Three scenarios
```{r, echo=FALSE, fig.height=8, fig.width=6}
# Scenarios setup
scenPar <- function () {setPar(c(1, 1)); par(mar=c(1, 0.2, 0.6, 0.2), oma=c(0,1,1,1))}
eap <- c("No poison barbs", "Poison barbs")
splitSpots <- ape::read.tree(text="(((H, C), A), (B, (D, (E, (G, (F, H))))));")
naysHaveIt <- ape::read.tree(text="((((H, I), C), A), (B, (D, (E, (G, F)))));", legend.pos='topleft')
eyesHaveIt <- ape::read.tree(text="(((((H, I), G), C), A), (B, (D, (E, F))));")
#tail <- "000111111"
col <- "---000011"
```

The presence of poison barbs obviously contains grouping information -- a reconstruction that attribute the presence of posion barbs to a single evolutionary gain in a common ancestor is parsimonious with respect to that character (even if it is less parsimonious with respect to another -- e.g. the presence or absence of a tail).

```{r, echo=FALSE, fig.width=6, fig.height=3, fig.cap="One tail with barbs, one without"}
scenPar()
vignettePlot(naysHaveIt, col, state.labels = eap, passes=4)
```

Consider a reconstruction in which a tail evolved twice, and barbs evolved twice.  Here, the duplicate origin of barbs (as well as the duplicate origin of the tail) makes this reconstruction less parsimonious.

```{r, echo=FALSE, fig.width=6, fig.height=3, fig.cap="Two barb appearances"}
scenPar()
vignettePlot(splitSpots, col, state.labels = eap, passes=4)
```

But what about a situation in which a tail evolved twice, and lacked barbs each time it evolved?  Coding this character as transformational penalises the duplicate origin of the state "no poison barbs", making this reconstruction less parsimonious.

If we expect a tail, when it evolves, to lack barbs, then the second origin of "no barbs" does not represent a homoplasy: it's not a feature that has evolved twice, but rather an observation that something has _not_ evolved twice.

The absence of poison barbs in the two ancestral tail-bearers has been inherited from a common ancestor that did not itself bear tail barbs (by virtue, in this instance, of not bearing a tail).  This second non-origination should not, therefore, be penalized in this situation.

```{r, echo=FALSE, fig.width=6, fig.height=3, fig.cap="Two barbless appearances: second absence is penalized"}
scenPar()
vignettePlot(eyesHaveIt, col, state.labels = eap, passes=4)
ape::nodelabels(node=10, cex=7, pch=1, col='#ee4444')
```

This problem has arisen because the inapplicable token has been used in a character that is, in fact, applicable.  

The statement "A tail is absent; the tail is red" is not logically consistent, which is why the inapplicable token is necessary.  In contrast, the statement "A tail is absent; tail barbs are absent" _is_ logically consistent, and the inapplicable token is not necessary.  Instead, the 'absence' token should be employed instead of the inapplicable:


```{r, echo=FALSE, fig.width=6, fig.height=3, fig.cap="Two barbless appearances"}
setPar()
vignettePlot(eyesHaveIt, '000011111', state.labels = ap, passes=2, main="Tail")
vignettePlot(eyesHaveIt, '000000011', state.labels = eap, passes=4, main="Tail with poison barbs")
```


The point here is that the inapplicable token ought only to be used in tips where a character description literally does not apply.  As an example, De Laet [-@DeLaet2017] contends that the character  "Tail: absent/present" is inapplicable in an angiosperm.  We disagree.  Angiosperms do not have tails.  "Tail" should be coded as absent in angiosperms.


One way to emphasize this distinction in character matrices is to reserve the `0` token to denote absence, and denoting states of transformational characters using the positive integers:


```{r, echo = FALSE, results='asis'}
tail <- c(0, 0, 0, 1, 1, 1, 1, 1, 1)
eyespot <- c(0,0,0, 0,0,0,0,1,1)
colour <- c(rep('-', 3), rep(1, 3), rep(2, 3))

tailEyes <- matrix(c(tail, eyespot, colour), byrow=TRUE, ncol=length(tail))
colnames(tailEyes) <- LETTERS[seq_along(tail)]
rownames(tailEyes) <- c("Tail: (0), absent; (1), present",
                        "Tail, poison barbs: (0), absent; (1), present",
                        "Tail, colour: (-), inapplicable; (1), red; (2), blue")
kable(tailEyes, caption="Recommended coding: state 0 reserved for absence; states 1 and 2 used for (transformational) tail colour character.")
```

<!--
#### Evaluation
It is possible that a researcher might feel uncomfortable grouping taxa on the basis of the non-occurrence of a complex feature that did not occur in their common ancestor.  Putting this another way, it is not clear that the fact that a feature has not evolved in two instances represents a homoplasy.  The absence of eyespots in a tail is not an evolutionary innovation -- it is an inheritance from a common ancestor that did not have eyespots (and did not have a tail).-->

One implication of this coding strategy is that the loss of a tail (a single evolutionary event) causes the loss of all contingent characters -- characters are not independent.

```{r, echo=FALSE, fig.width=6, fig.height=4, fig.cap="Presence of a tail and presence of poison barbs will have the same distribution if all tails have poison barbs.  Loss and subsequent re-gain of a tail implies the same loss and re-gain of barbs."}
par(mfrow=c(1, 2), mar=c(0.2, 0.2, 0.2, 0.2), cex=0.8)
imbal <- ape::read.tree(text="(A, (B, (C, (D, (E, (F, G))))));")
tail <- "1100011"
eyespots <- "1100011"

vignettePlot(imbal, eyespots, na=FALSE, legend.pos='topleft', state.labels = ap)
text(3.4, 0.2, "Tail", pos=4, cex=1.25, font=2)
vignettePlot(imbal, eyespots, na=FALSE, legend.pos='topleft', state.labels = ap)
text(3.4, 0.2, "Poison barbs", pos=4, cex=1.2, font=2)
```

If a poisoned tail was present in a lineage, then lost, then re-gained, would one expect the re-gained tail to also re-gain its poisoned barbs?  One could spend some time evaluating whether this behaviour has a biological underpinning, or whether it is desirable -- is a reconstruction that invokes the loss of a complex tail more parsimonious than one that invokes the loss of a simple tail?

Indeed, it would be straightforwards to construct an algorithm that does not penalise losses where the loss corresponds to the inferred loss of a parent character.

The underlying issue, however, is that both parsimony and the Mk model assume character independence; it is perhaps more fruitful to focus effort on developing models of evolution that take proper account of character non-independence.

### Does absence contain phylogenetic information?

In some cases, the absence of a feature (e.g. serrations) may represent a transformational character and should thus be coded as such.  But this decision is significant, and merits careful thought.  A researcher may or may not be justified in including properties of a tail that occur in only one, or even in none, of the taxa of interest, for if absence is informative for parsimony, then such characters will influence tree topology: [parsimony uninformative characters inform
parsimony](#puip).


```{r, echo = FALSE, results='asis'}
tail <- c(0, 0, 0, 1, 1, 1, 1)
serr <- c("-", "-", "-", "{12}","{12}", 1, 1)
gitd <- c("-", "-", "-", "{12}","{12}", 1, 1)
elec <- c("-", "-", "-", "{12}","{12}", 1, 1)

unobserved <- matrix(c(tail, serr, gitd,  elec), byrow=TRUE, ncol=length(tail))
colnames(unobserved) <- LETTERS[seq_along(tail)]
rownames(unobserved) <- c("Tail: (0), absent; (1), present",
                          "Tail, margin: (-), inapplicable; (1), smooth; (2), serrated",
                        "Tail, glow-in-the-dark pigment: (-), inapplicable; (1), absent; (2), present",
                        "Tail, ability to generate electricity: (-), inapplicable; (1), absent; (2), present")
kable(unobserved, caption="Absences treated as transformational characters")
```

Note that each of the unobserved (i.e. always-absent) characters provides evidence against independent origins of the tail, in favour of independent losses:

```{r, echo=FALSE, fig.height=3.2, fig.width=8}
setPar(c(1, 2))
par(oma=c(1,1,3,1))
better <- ape::read.tree(text="(((F, G), C), (A, (B, (D, E))));")
worse  <- ape::read.tree(text="(((F, C), G), (A, (B, (D, E))));")
col <- "---{12}{12}11"

vignettePlot(better, col, legend.pos='topleft', state.labels = c(0, ap),
             passes=4, main='Two tail origins', cex.main=0.8)
mtext("Tail, glow-in-the-dark pigment: (-), inapplicable; (1), absent; (2), present",
      side=3, line=0, outer=TRUE)
vignettePlot(worse, col, legend.pos='topleft', state.labels = c(0, ap), 
             passes=4, main='Three tail losses', cex.main=0.8)

```

Under the simple matrix presented above, the left-hand tree receives a score of five (two independent gains of the tail, plus the three ontologically dependent characters with an additional step each), whereas the right-hand tree scores but three (three independent losses of the tail; no steps in the ontologically dependent characters), making it more parsimonious. 

If the three ontologically-dependent characters were coded as 'absent' (instead of inapplicable) when the tail was absent, then the left-hand tree would be preferred (with a score of 2 vs. 3).

The two trees are equally parsimonious (both scoring three) if tail margin is treated as a trasnformational character (inapplicable when tail absent) and the other characters are treated as neomorphic (absent when tail absent).


```{r, echo = FALSE, results='asis'}

tail <- c(0, 0, 0, 1, 1, 1, 1)
gitd <- c(0, 0,0, "{01}","{01}",0,0)
elec <- c(0,0,0, "{01}","{01}",0,0)

unobserved <- matrix(c(tail, serr, gitd, elec), byrow=TRUE, ncol=length(tail))
colnames(unobserved) <- LETTERS[seq_along(tail)]
rownames(unobserved) <- c("Tail: (0), absent; (1), present",
                          "Tail, margin: (1), smooth; (2), serrated",
                        "Tail, glow-in-the-dark pigment: (-), inapplicable; (0), absent; (1), present",
                        "Tail, ability to generate electricity: (-), inapplicable; (0), absent; (1), present")
kable(unobserved, caption="Recommended coding: Absences treated as neomorphic characters were appropriate")
```

<!--chapter:end:04_codingData.Rmd-->

---
title: "Coding ambiguous taxa"
author: "Martin R. Smith"
---

```{r, message=FALSE, include=FALSE}
library('knitr'); library('Inapp')
setPar <- function (mfrow=c(1, 2)) par(mfrow=mfrow, mar=c(0.2, 0.2, 1, 0.2), oma=c(0,0,0,0), cex=0.7)

ap <- c("Absent", "Present")
rb <- c("Red", "Blue")
```

# Coding ambiguity {#ambiguity}

Ambiguous data does not pose a problem for the algorithm, but the nature of the
ambiguity must be considered when scoring a character.

## Principal character ambiguous

If it's not clear whether or not a taxon has a tail, then tail colour should be 
coded as `?`, denoting that any possible token (including the inapplicable token)
may be the most parsimonious for the tail.

In trees in which the tail can be reconstructed as present, the ambiguous tip
will be reconstructed as having a tail of the appropriate colour:

```{r, echo=FALSE, fig.width=8, fig.height=4}
setPar()
hasTail   <- ape::read.tree(text="((a, (b, (c, d))), (e, ((f, (g, X)), (h, i))));")
lacksTail <- ape::read.tree(text="((a, (b, (X, (c, d)))), (e, ((f, g), (h, i))));")
tail <- "000001111?"
col  <- "-----0011?"

vignettePlot(hasTail, tail, legend.pos='topleft', na=FALSE, main="Tail", state.labels = ap)
vignettePlot(hasTail, col, legend.pos='topleft', main="Tail colour", state.labels = rb)

```

In trees in which the tail cannot be reconstructed as present without inferring
a homoplasious origin, the tail colour will be reconstructed as inapplicable:

```{r, echo=FALSE, fig.width=8, fig.height=4}
setPar()
vignettePlot(lacksTail, tail, legend.pos='topleft', na=FALSE, main="Tail", state.labels = ap)
vignettePlot(lacksTail, col, legend.pos='topleft', main="Tail colour", state.labels = rb)
```

## Principal character known

If a taxon is known to have a tail, there are two scenarios for ontologically
dependent transformational characters:

### Subordinate character has finite states

If the subordinate character must take one of a finite set of values, then the
unobserved property of the tail is known to belong to these values and should be 
coded accordingly.

For example:

> Tail: (0), absent; (1), present
>
> Tail margin: (0), smooth; (1), serrated.
  
Assume that the tail margin must either be smooth or serrated, and there is no 
reason to assume that either state is ancestral (i.e. the character is strictly
transformational).  Tail margin should then be coded as `{01}`: i.e. the tail
is known to have taken one of the two states 0 or 1.

### Subordinate character may have unobserved states

A more complicated situation arises where a subordinate character may have 
unobserved states, as with 

> Tail colour: (0), red; (1), blue.
  
A taxon that is known to have a tail, but whose tail colour is uncertain, should 
generally be coded as `?`.

Coding it as `{01}` would be appropriate if the tail was 
known to certainly be homologous with other tails in the dataset, in which case
it would be most parsimonious to assume that the tail colour is the same colour
as the ancestor of the tip, which was necessarily either red or blue.

```{r, echo=FALSE, fig.width=4, fig.height=4}
setPar(c(1, 1))
vignettePlot(ape::read.tree(text="(a, (b, (c, (d, (e, (f, (g, (h, (i1, i2)))))))));"),
             '---00011{01}{01}', legend.pos='topleft', state.labels = rb, passes=4)
```

But if, as will more often be the case, homology of the tails is not known 
_a priori_, then it is possible that this taxon has a tail 
that is not homologous with any other tail whose colour has been observed.

In this case, coding the tail colour as `{01}` denotes that the tail is the same 
colour as a tail that has already been observed.  This means that the independent
origin of the tail also represents an independent
origin of this particular colour -- and hence an instance of homoplasy.

```{r, echo=FALSE, fig.width=4, fig.height=4}
setPar(c(1, 1))
vignettePlot(ape::read.tree(text="((a, (i1, i2)), (b, (c, (d, (e, (f, (g, h)))))));"),
             '---00011{01}{01}', legend.pos='topleft', state.labels = rb, passes=4)
```

Coding the tail colour as `?` allows the possibility that the independently-evolved
tail has a different colour to the tails already observed -- green, perhaps.
Reconstructing the tail colour as a colour that has not already been observed 
avoids an instance of homoplasy, and is therefore more parsimonious.

In the case that the unknown tail evolved independently and was green, the original
character formulation -- which only provides tokens for red and blue tails -- 
cannot be applied and is thus inapplicable.  Our algorithm will thus reconstruct
tail colour as being inapplicable in such a taxon.

```{r, echo=FALSE, fig.width=4, fig.height=4}
setPar(c(1, 1))
vignettePlot(ape::read.tree(text="((a, (i1, i2)), (b, (c, (d, (e, (f, (g, h)))))));"),
             '---00011??', legend.pos='topleft', state.labels = rb, passes=4)
```

## Recommendation 

We therefore recommend the following coding schema for ambiguous tips where the
tail is known to be present, ambiguous, or known to be absent:

```{r, echo=FALSE, asis=TRUE}
mDep <- matrix(c("1", "?", "0",
                 "{01}", "?", "-",
                 "?", "?", "-"), byrow=TRUE, ncol=3)
colnames(mDep) <- c('Present', 'Unknown', 'Absent')
rownames(mDep) <- c("Tail: (0), absent; (1), present.",
                    "Tail margin: (0), smooth; (1), serrated.",
                    "Tail colour: (0), red; (1), blue.")
knitr::kable(mDep, caption="Recommended coding for unknown contingent characters")
```

"Tail margin" represents a character that can only take the states observed (smooth or serrated), whereas tail colour represents a character that may take an unobserved state (e.g. green).

<!--chapter:end:05_ambiguousData.Rmd-->

---
title: "Worked examples"
author: "Martin R. Smith"
---

```{r, message=FALSE, include=FALSE}
library('Inapp')
library('ape')
labelRow <- function(text) text(-3, 9, text, font=2, pos=4, cex=1.2)
goloPar <- function () par(mfrow=c(1, 2), mar=c(0.5, 0.2, 0.6, 0.2), oma=c(0, 0, 2, 0), cex=0.5)
goloPlot <- function (tai, clr, nodeLabels=FALSE) {
    goloPar()
    vignettePlot(comb, tai, legend.pos='topleft', FALSE, passes=2, state.labels=ap)
    vignettePlot(comb, clr, legend.pos='topleft', passes=4, state.labels = rb)
    if (nodeLabels) {
        text((1:15) - 1 , 1:15, LETTERS[1:15])
        text((1:14) + 2.5 , (1:14) - 0.5, 1:14)
    }
}
ap <- c('Absent', 'Present')
rb <- c('Red', 'Blue')
oap <- c('', ap)
orb <- c('', rb)
```

# Examples {#examples}

This vignette describes how the algorithm approaches some example trees.
We follow the example of a tail coded using two characters:

> Tail: (0), absent; (1), present;
>
> Tail colour: (0), red; (1), blue.

## Some caterpillars

First we'll address some pectinate "caterpillar" trees, in which eight 
taxa have tails (and eight do not), four of which are red, four of which are blue.

```{r, echo=FALSE}
comb <- ape::read.tree(text="(A, (B, (C, (D, (E, (F, (G, (H, (I, (J, (K, (L, (M, (N, (O, P)))))))))))))));")
clr1 <- "--------00001111"
tai1 <- "0000000011111111"
clr2 <- "0000--------1111"
tai2 <- "1111000000001111"
clrA <- "000011--------11"
taiA <- "1111110000000011"
clrB <- "00---00--11---11"
taiB <- "1100011001100011"
clrC <- "0-0--00--11---11"
taiC <- "1010011001100011"
clrD <- "0-0-0-0-1-1-1-1-"
taiD <- "1010101010101010"
clrE <- "00----0011----11"
taiE <- "1100001111000011"
```

An optimal tree with this character invokes a single origin of the tail, and a single
change in tail colour, thus incurring a score of two.  Here is one example:

```{r, echo = FALSE, fig.height=4, fig.width=7.1, fig.cap='An optimal tree: Total score 2'}
goloPlot(tai1, clr1)
```

If we insist that the tail evolves twice, then the best score is accomplished
by reconstructing a different colour of tail in each of the two regions
in which the tail is present.  On a caterpillar tree, this means the loss of a 
tail that has one colour, and an independent innovation in a tail-less taxon
of a tail that has a different colour:

```{r, echo = FALSE, fig.height=4, fig.width=7.1, fig.cap='Two tail innovations: Total score 2 (best possible)'}
goloPlot(tai2, clr2)
```

Under the parsimony criterion, it is considered less optimal if a tail, when it re-evolves, happens to independently re-evolve a colour that has already been observed --
"blueness" has evolved twice on the following tree, meaning that 
the second innovation of "blueness" represents an instance of homoplasy.

```{r, echo = FALSE, fig.height=4, fig.width=7.1, fig.cap='Tree A: Total score 4'}
goloPlot(taiA, clrA)
```

## Three equally suboptimal alternatives
The following three trees differ in the number of innovations of the tail that
are implied, and the number of changes in tail colour.  All are equally parsimonious.

Under the first, our algorithm reconstructs the tail as ancestrally present, 
being lost on edge 2, gained on edge 5, lost in tips H and I, lost on edge 11,
and gained on edge 14 (a total of six homoplasies).  It further reconstructs 
independent, homoplastic origins of tail redness on edge 5, tail blueness on 
edge 14, and a change in tail colour from red to blue somewhere between edges 
7 and 9 (three homoplasies).

```{r, echo = FALSE, fig.height=4, fig.width=7.1, fig.cap='Tree B: Total score 9',}
goloPlot(taiB, clrB, TRUE)
```


In the second, our algorithm reconstructs the tail as ancestrally present, 
being lost in tips B, D, E, H, and I, and on edge 11, before being independently
gained on edge 14 (a total of seven homoplasies).  
It further reconstructs an independent, homoplastic origins of tail  blueness on 
edge 14, and a change in tail colour from red to blue somewhere between edges 7 and 9 (two homoplasies).

```{r, echo = FALSE, fig.height=4, fig.width=7.1, fig.cap='Tree C: Total score 9'}
goloPlot(taiC, clrC, TRUE)
```


The third configuration reconstructs the tail as ancestrally present, 
being lost in tips B, D, F, H, J, L, N and P (a total of eight homoplastic losses).
It further reconstructs a single change in tail colour from red to blue 
on edge 8.

```{r, echo = FALSE, fig.height=4, fig.width=7.1, fig.cap='Tree D: Total score 9'}
goloPlot(taiD, clrD, TRUE)
```


## A better caterpillar tree

The tree below obtains a better score than any of the previous three: it implies
a loss of the tail at edge 2, a gain at edge 6, a loss at edge 10, and a gain at
edge 14; it invokes a homoplastic origin of redness at edge 6, one of blueness
at edge 14, and a change in colour at edge 8, for a combined score of 7.

```{r, echo = FALSE, fig.height=4, fig.width=7.1, fig.cap='Tree E: Total score 7'}
goloPlot(taiE, clrE, TRUE)
```

## De Laet's caterpillars

```{r, echo=FALSE}
combH <- ape::read.tree(text="(A, (B, (C, (D, (E, (F, (G, H)))))));")
```

De Laet [-@DeLaet2017] identifies a corner case in which our algorithm [@Brazeau2018] will not reconstruct every equally-parsimonious character reconstruction.  Below is a simplified version of his example:

```{r, echo=FALSE, asis=TRUE}
tail <- "011?0011"
clr2 <- "-11?--22"
mDep <- matrix(strsplit(paste0(tail, clr2, collapse=''), '')[[1]], byrow=TRUE, nrow=2)
colnames(mDep) <- LETTERS[1:ncol(mDep)]
rownames(mDep) <- c("Tail: (0), absent; (1), present.",
                    "Tail, colour: (1), red; (2),blue.")
knitr::kable(mDep, caption="Coding")
```

When optimising tail colour, we reconstruct the tail as present at all internal nodes, with independent losses of the tail in each of the three tailless taxa (i.e. edges 1, 9, 11). 

```{r, echo=FALSE, fig.width=8, fig.height=4}
goloPar()
vignettePlot(combH, tail, legend.pos='topleft', FALSE, passes=2,
             main='Tail', state.labels = ap)
edgelabels(cex=1.6, frame='none')
tiplabels(cex=1.6, frame='none', LETTERS[1:8], adj=c(2.5, 0.5))
vignettePlot(combH, clr2, legend.pos='topleft', passes=4,
             main='Tail colour', state.labels=orb)

```

The Fitch algorithm identifies other reconstructions as equally parsimonious: for example, a tail may have been lost on edge 6 and re-gained on edge 12.  This also incurs three steps for the tail character, and (in De Laet's parlance) attributes three similarities to common ancestry: the presence of a tail in tips B and C, the absence of the tail in tips E and F, and the presence of a tail in tips G and H.

We prefer reconstructions that attribute the presence of a feature to common ancestry where possible -- a philosophy that shares something with Dollo's contention that it is easier to lose a feature than to gain it.  On a pragmatic level, this maximises the opportunity for subsidiary traits of the tail to be attributed to common ancestry.

In this particular case, there is an equally-parsimonious character reconstruction that our algorithm excludes, which invokes two gains (and one loss) of the tail:

```{r, echo=FALSE, fig.width=8, fig.height=4}
goloPar()

vignettePlot(combH, "011?0011", legend.pos='topleft', FALSE, passes=0,
             main='Tail', state.labels = ap)
edgelabels(cex=1.6, frame='none')
nodelabels(pch=16, cex=6, col='#58a691a7')
nodelabels(c('01', 1, 1,'01',0, 0, 1), cex=1.6, frame='none')

tiplabels(cex=1.6, frame='none', LETTERS[1:8], adj=c(2.5, 0.5))
vignettePlot(combH, "-11?--22", legend.pos='topleft', passes=0,
             main='Tail colour', state.labels=orb)
nodelabels(pch=16, cex=6, col='#58a691a7')
nodelabels(c("-1", "1", 1, '-1', rep("-", 2), 2), cex=1.6, frame='none')

```

This has no effect on tree scoring, but may be relevant if complete internal nodal reconstructions are desired.

<!--chapter:end:06_examples.Rmd-->

---
title: "References"
---

`r if (knitr::is_html_output()) '# References {-}'`

<!--chapter:end:07_references.Rmd-->

