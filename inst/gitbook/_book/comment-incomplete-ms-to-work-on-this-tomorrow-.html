<!DOCTYPE html>
<html >

<head>

  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Inapplicable data</title>
  <meta name="description" content="Inapplicable data in a parsimony setting">
  <meta name="generator" content="bookdown 0.7 and GitBook 2.6.7">

  <meta property="og:title" content="Inapplicable data" />
  <meta property="og:type" content="book" />
  
  
  <meta property="og:description" content="Inapplicable data in a parsimony setting" />
  <meta name="github-repo" content="TGuillerme/Inapp" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Inapplicable data" />
  
  <meta name="twitter:description" content="Inapplicable data in a parsimony setting" />
  

<meta name="author" content="Martin Brazeau (m.brazeau@imperial.ac.uk), Thomas Guillerme (guillert@tcd.ie) and Martin Smith (martin.smith@durham.ac.uk)">


<meta name="date" content="2018-03-07">

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  
  
<link rel="prev" href="the-fitch-algorithm.html">
<link rel="next" href="a-solution.html">
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />









<style type="text/css">
div.sourceLine, a.sourceLine { display: inline-block; min-height: 1.25em; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; }
@media print {
code.sourceCode { white-space: pre-wrap; }
div.sourceLine, a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource div.sourceLine, .numberSource a.sourceLine
  { position: relative; }
pre.numberSource div.sourceLine::before, .numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: absolute; left: -5em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em; }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; color: #aaaaaa;  padding-left: 4px; }
@media screen {
a.sourceLine::before { text-decoration: underline; color = initial; }
}
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.bn { color: #40a070; } /* BaseN */
code span.fl { color: #40a070; } /* Float */
code span.ch { color: #4070a0; } /* Char */
code span.st { color: #4070a0; } /* String */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.ot { color: #007020; } /* Other */
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.fu { color: #06287e; } /* Function */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code span.cn { color: #880000; } /* Constant */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.ss { color: #bb6688; } /* SpecialString */
code span.im { } /* Import */
code span.va { color: #19177c; } /* Variable */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.op { color: #666666; } /* Operator */
code span.bu { } /* BuiltIn */
code span.ex { } /* Extension */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.at { color: #7d9029; } /* Attribute */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>

<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="./">Inapplicable data in a parsimony setting</a></li>

<li class="divider"></li>
<li class="chapter" data-level="1" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i><b>1</b> Inapplicable data in a parsimony setting</a><ul>
<li class="chapter" data-level="1.1" data-path="index.html"><a href="index.html#the-packages"><i class="fa fa-check"></i><b>1.1</b> The packages</a></li>
</ul></li>
<li class="chapter" data-level="2" data-path="the-fitch-algorithm.html"><a href="the-fitch-algorithm.html"><i class="fa fa-check"></i><b>2</b> The Fitch algorithm</a><ul>
<li class="chapter" data-level="2.1" data-path="the-fitch-algorithm.html"><a href="the-fitch-algorithm.html#downpass"><i class="fa fa-check"></i><b>2.1</b> Downpass</a></li>
<li class="chapter" data-level="2.2" data-path="the-fitch-algorithm.html"><a href="the-fitch-algorithm.html#uppass"><i class="fa fa-check"></i><b>2.2</b> Uppass</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="comment-incomplete-ms-to-work-on-this-tomorrow-.html"><a href="comment-incomplete-ms-to-work-on-this-tomorrow-.html"><i class="fa fa-check"></i><b>3</b> [Comment:] Incomplete; MS to work on this tomorrow.</a><ul>
<li class="chapter" data-level="3.1" data-path="comment-incomplete-ms-to-work-on-this-tomorrow-.html"><a href="comment-incomplete-ms-to-work-on-this-tomorrow-.html#optimizing-ambiguous-characters-characters"><i class="fa fa-check"></i><b>3.1</b> Optimizing ambiguous characters characters</a></li>
<li class="chapter" data-level="3.2" data-path="comment-incomplete-ms-to-work-on-this-tomorrow-.html"><a href="comment-incomplete-ms-to-work-on-this-tomorrow-.html#problems-with-the-fitch-algorithm"><i class="fa fa-check"></i><b>3.2</b> Problems with the Fitch algorithm</a><ul>
<li class="chapter" data-level="3.2.1" data-path="comment-incomplete-ms-to-work-on-this-tomorrow-.html"><a href="comment-incomplete-ms-to-work-on-this-tomorrow-.html#red-tails-blue-tails"><i class="fa fa-check"></i><b>3.2.1</b> Red tails, blue tails</a></li>
<li class="chapter" data-level="3.2.2" data-path="comment-incomplete-ms-to-work-on-this-tomorrow-.html"><a href="comment-incomplete-ms-to-work-on-this-tomorrow-.html#why-reductive-coding-doesnt-work"><i class="fa fa-check"></i><b>3.2.2</b> Why Reductive coding doesn’t work</a></li>
<li class="chapter" data-level="3.2.3" data-path="comment-incomplete-ms-to-work-on-this-tomorrow-.html"><a href="comment-incomplete-ms-to-work-on-this-tomorrow-.html#why-extra-state-coding-doesnt-work"><i class="fa fa-check"></i><b>3.2.3</b> Why Extra State coding doesn’t work</a></li>
<li class="chapter" data-level="3.2.4" data-path="comment-incomplete-ms-to-work-on-this-tomorrow-.html"><a href="comment-incomplete-ms-to-work-on-this-tomorrow-.html#why-a-single-multi-state-character-doesnt-work"><i class="fa fa-check"></i><b>3.2.4</b> Why a single multi-state character doesn’t work</a></li>
<li class="chapter" data-level="3.2.5" data-path="comment-incomplete-ms-to-work-on-this-tomorrow-.html"><a href="comment-incomplete-ms-to-work-on-this-tomorrow-.html#sankoff-matrices"><i class="fa fa-check"></i><b>3.2.5</b> Sankoff matrices</a></li>
<li class="chapter" data-level="3.2.6" data-path="comment-incomplete-ms-to-work-on-this-tomorrow-.html"><a href="comment-incomplete-ms-to-work-on-this-tomorrow-.html#conclusion"><i class="fa fa-check"></i><b>3.2.6</b> Conclusion</a></li>
</ul></li>
<li class="chapter" data-level="3.3" data-path="comment-incomplete-ms-to-work-on-this-tomorrow-.html"><a href="comment-incomplete-ms-to-work-on-this-tomorrow-.html#the-problem-with-counting-steps"><i class="fa fa-check"></i><b>3.3</b> The problem with counting steps</a></li>
</ul></li>
<li class="chapter" data-level="4" data-path="a-solution.html"><a href="a-solution.html"><i class="fa fa-check"></i><b>4</b> A solution</a><ul>
<li class="chapter" data-level="4.1" data-path="a-solution.html"><a href="a-solution.html#minimising-homoplasy"><i class="fa fa-check"></i><b>4.1</b> Minimising homoplasy</a><ul>
<li class="chapter" data-level="4.1.1" data-path="a-solution.html"><a href="a-solution.html#what-does-it-take-to-denote-separate-regions"><i class="fa fa-check"></i><b>4.1.1</b> What does it take to denote separate regions?</a></li>
<li class="chapter" data-level="4.1.2" data-path="a-solution.html"><a href="a-solution.html#how-this-fixes-the-problem"><i class="fa fa-check"></i><b>4.1.2</b> How this fixes the problem</a></li>
<li class="chapter" data-level="4.1.3" data-path="a-solution.html"><a href="a-solution.html#summary"><i class="fa fa-check"></i><b>4.1.3</b> Summary</a></li>
</ul></li>
<li class="chapter" data-level="4.2" data-path="a-solution.html"><a href="a-solution.html#implementation"><i class="fa fa-check"></i><b>4.2</b> Implementation</a><ul>
<li class="chapter" data-level="4.2.1" data-path="a-solution.html"><a href="a-solution.html#passes-1-2"><i class="fa fa-check"></i><b>4.2.1</b> Passes 1 &amp; 2</a></li>
<li class="chapter" data-level="4.2.2" data-path="a-solution.html"><a href="a-solution.html#pass-3"><i class="fa fa-check"></i><b>4.2.2</b> Pass 3</a></li>
<li class="chapter" data-level="4.2.3" data-path="a-solution.html"><a href="a-solution.html#pass-4"><i class="fa fa-check"></i><b>4.2.3</b> Pass 4</a></li>
</ul></li>
<li class="chapter" data-level="4.3" data-path="a-solution.html"><a href="a-solution.html#coding-data"><i class="fa fa-check"></i><b>4.3</b> Coding data</a><ul>
<li class="chapter" data-level="4.3.1" data-path="a-solution.html"><a href="a-solution.html#multiple-dependencies"><i class="fa fa-check"></i><b>4.3.1</b> Multiple dependencies</a></li>
<li class="chapter" data-level="4.3.2" data-path="a-solution.html"><a href="a-solution.html#invariant-characters-can-inform-parsimony"><i class="fa fa-check"></i><b>4.3.2</b> Invariant characters can inform parsimony</a></li>
<li class="chapter" data-level="4.3.3" data-path="a-solution.html"><a href="a-solution.html#variable-but-parsimony-uninformative-characters-can-inform-parsimony"><i class="fa fa-check"></i><b>4.3.3</b> Variable but ‘parsimony uninformative’ characters can inform parsimony</a></li>
</ul></li>
<li class="chapter" data-level="4.4" data-path="a-solution.html"><a href="a-solution.html#this-may-not-be-desirable-in-neomorphic-characters"><i class="fa fa-check"></i><b>4.4</b> This may not be desirable in neomorphic characters</a></li>
<li class="chapter" data-level="4.5" data-path="a-solution.html"><a href="a-solution.html#coding-ontologically-dependent-neomorphic-characters"><i class="fa fa-check"></i><b>4.5</b> Coding ontologically dependent neomorphic characters</a><ul>
<li class="chapter" data-level="4.5.1" data-path="a-solution.html"><a href="a-solution.html#neomorphic-and-transformational-characters"><i class="fa fa-check"></i><b>4.5.1</b> Neomorphic and transformational characters</a></li>
<li class="chapter" data-level="4.5.2" data-path="a-solution.html"><a href="a-solution.html#three-trees"><i class="fa fa-check"></i><b>4.5.2</b> Three trees</a></li>
<li class="chapter" data-level="4.5.3" data-path="a-solution.html"><a href="a-solution.html#recommendation"><i class="fa fa-check"></i><b>4.5.3</b> Recommendation</a></li>
</ul></li>
<li class="chapter" data-level="4.6" data-path="a-solution.html"><a href="a-solution.html#ambiguity"><i class="fa fa-check"></i><b>4.6</b> Ambiguity</a><ul>
<li class="chapter" data-level="4.6.1" data-path="a-solution.html"><a href="a-solution.html#ambiguity-when-parent-character-ambiguous"><i class="fa fa-check"></i><b>4.6.1</b> Ambiguity when parent character ambiguous</a></li>
<li class="chapter" data-level="4.6.2" data-path="a-solution.html"><a href="a-solution.html#ambiguity-when-parent-character-known"><i class="fa fa-check"></i><b>4.6.2</b> Ambiguity when parent character known</a></li>
<li class="chapter" data-level="4.6.3" data-path="a-solution.html"><a href="a-solution.html#recommendation-1"><i class="fa fa-check"></i><b>4.6.3</b> Recommendation</a></li>
</ul></li>
<li class="chapter" data-level="4.7" data-path="a-solution.html"><a href="a-solution.html#examples"><i class="fa fa-check"></i><b>4.7</b> Examples</a><ul>
<li class="chapter" data-level="4.7.1" data-path="a-solution.html"><a href="a-solution.html#some-caterpillars"><i class="fa fa-check"></i><b>4.7.1</b> Some caterpillars</a></li>
<li class="chapter" data-level="4.7.2" data-path="a-solution.html"><a href="a-solution.html#three-equally-suboptimal-alternatives"><i class="fa fa-check"></i><b>4.7.2</b> Three equally suboptimal alternatives</a></li>
<li class="chapter" data-level="4.7.3" data-path="a-solution.html"><a href="a-solution.html#a-better-caterpillar-tree"><i class="fa fa-check"></i><b>4.7.3</b> A better caterpillar tree</a></li>
<li class="chapter" data-level="4.7.4" data-path="a-solution.html"><a href="a-solution.html#de-laets-caterpillars"><i class="fa fa-check"></i><b>4.7.4</b> De Laet’s caterpillars</a></li>
</ul></li>
</ul></li>
<li class="divider"></li>
<li><a href="https://github.com/TGuillerme/Inapp/" target="blank">Project GitHub page</a></li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Inapplicable data</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="comment-incomplete-ms-to-work-on-this-tomorrow." class="section level1">
<h1><span class="header-section-number">3</span> [Comment:] Incomplete; MS to work on this tomorrow.</h1>
<div id="optimizing-ambiguous-characters-characters" class="section level2">
<h2><span class="header-section-number">3.1</span> Optimizing ambiguous characters characters</h2>
<p>A number of approaches have been proposed concerning which resolution of ambiguous
nodes is preferable.</p>
<p>The two most familiar approaches to resolving ambiguous node are the Accelerated Transformation
(<span class="smallcaps">AccTran</span>) and Delayed Transformation
(<span class="smallcaps">DelTran</span>) approaches.</p>
<p>The <span class="smallcaps">AccTran</span> approach reconstructs transformations as occurring as close to the root as possible; the <span class="smallcaps">DelTran</span>, as far from the root as possible.</p>
<p>In this case, the ambiguous resolution of the root leaves two options for the latter:</p>
<p><img src="Inapplicable_data_files/figure-html/unnamed-chunk-11-1.png" width="681.6" /></p>
<p>If the states <code>0</code> and <code>1</code> represent states of a transformational character –
whether an organism’s tail is red or blue, say – then there is no reason to prefer
any of the equally-parsimonious reconstructions, as none implies any more homology
than any other.</p>
<p>With neomorphic characters, however, state <code>0</code> stands for the absence of a character
– for example, a tail –
and state <code>1</code> its presence. On one view, a reconstruction that minimises the number
of times that such a character evolves attributes more similarity to homology than
an equally parsimonious reconstruction in which said character is gained multiple times
independently.</p>
<p>In this particular case, the <span class="smallcaps">DelTran</span> reconstruction maximises homology. If the
character denotes the presence or absence of a tail, then this reconstruction invokes the presence of a tail in the common ancestor of all taxa, meaning that the tails present in
tips <code>a</code>, <code>d</code>, <code>e</code> and <code>h</code> are homologous with one another.
The <span class="smallcaps">AccTran</span> reconstruction, in contrast, identifies a loss of a tail
at nodes 11 and 14, with a tail evolving independently in tips <code>a</code> and <code>h</code>.
Under this reconstruction, the tails of <code>a</code> and <code>h</code> are not homologous with each other,
or with the tails of <code>d</code> and <code>e</code>.
(The alternative <span class="smallcaps">DelTran</span> approach, which could arguably be described as <span class="smallcaps">AccTran</span> too,
invokes four independent origins of the character and clearly does not maximise its homology.)</p>
<p>Neither <span class="smallcaps">AccTran</span> nor <span class="smallcaps">DelTran</span> is guaranteed to maximise homology <span class="citation">(Agnarsson &amp; Miller, <a href="#ref-Agnarsson2008">2008</a>)</span>.</p>
<p>Where we wish to maximise homology, we modify the Fitch uppass such that any node
whose final state reconstruction is ambiguous is instead reconstructed as present.</p>
<p>We can show that this maximises homology in the problematic trees presented by
Agnarsson &amp; Miller [<span class="citation">(<a href="#ref-Agnarsson2008">2008</a>)</span>; “A&amp;M”]:</p>
<p><img src="Inapplicable_data_files/figure-html/unnamed-chunk-12-1.png" width="681.6" /></p>
<p>And this approach is robust to missing entries:</p>
<p><img src="Inapplicable_data_files/figure-html/unnamed-chunk-13-1.png" width="681.6" /></p>

</div>
<div id="problems-with-the-fitch-algorithm" class="section level2">
<h2><span class="header-section-number">3.2</span> Problems with the Fitch algorithm</h2>
<p>The Fitch algorithm counts changes in a character.
It assumes that the character is applicable throughout the tree.
This assumption does not lead to error if:</p>
<ul>
<li><p>The character is inapplicable in fewer than three tips; or</p></li>
<li><p>In the trees being considered, applicable and inapplicable tokens occur
in distinct regions of the tree <span class="citation">(Maddison, <a href="#ref-Maddison1993">1993</a>)</span>.</p></li>
</ul>
<div id="red-tails-blue-tails" class="section level3">
<h3><span class="header-section-number">3.2.1</span> Red tails, blue tails</h3>
<p>Maddison <span class="citation">(<a href="#ref-Maddison1993">1993</a>)</span> provided the following example to demonstrate
the problem encountered by the Fitch algorithm when inapplicable
characters were present.</p>
<p>Consider the following tree, each node of which is supported by a number of
characters. Tail colour (illustrated; 0 = red, 1 = blue) has not yet been
considered, but has the potential to resolve the polytomy on the left hand side (bold).</p>
<p><img src="Inapplicable_data_files/figure-html/unnamed-chunk-15-1.png" width="768" /></p>
<p>Tail colour should group the red-tailed tips together, and the blue-tailed tips together,
but does not establish whether the ancestor of the left-hand tail-bearing clade
had a red or blue tail.</p>
</div>
<div id="why-reductive-coding-doesnt-work" class="section level3">
<h3><span class="header-section-number">3.2.2</span> Why Reductive coding doesn’t work</h3>
<p>Under reductive coding, the tail and its colour are described in two character statements:</p>
<blockquote>
<p>Tail: (0), absent; (1), present.</p>
<p>Tail, colour: (0), red; (1), blue; (?), inapplicable.</p>
</blockquote>
<p>Consider the following two trees, each of which receives a score of two for the first
character (presence of tail). The score of the second character (tail colour)
is not as desired.</p>
<p>The Fitch algorithm will prefer trees in which the left-hand tail-bearing clade
has a blue tail, simply because the right-hand tail-bearing clade ancestrally did.</p>
<p><img src="Inapplicable_data_files/figure-html/unnamed-chunk-16-1.png" width="768" /></p>
<p>Notice the additional step reconstructed at the root node: the Fitch algorithm
reconstructs a change in tail colour in a taxon that doesn’t have a tail!</p>
<p>This reconstruction is not logically consistent.</p>
<div id="an-exception" class="section level4">
<h4><span class="header-section-number">3.2.2.1</span> An exception</h4>
<p>If the parent character can parsimoniously be reconstructed as present at every internal node in a single unbroken region of a tree, and nowhere else, then reductive coding does work successfully. Reductive coding may therefore be appropriate if only a subset of all possible trees are under consideration, and is always (i.e. for all trees) appropriate if a character exhibits fewer than three inapplicable tokens.</p>
</div>
</div>
<div id="why-extra-state-coding-doesnt-work" class="section level3">
<h3><span class="header-section-number">3.2.3</span> Why Extra State coding doesn’t work</h3>
<p>An alternative is to code the inapplicable token as an extra state:</p>
<blockquote>
<p>Tail: (0), absent; (1), present.</p>
<p>Tail, colour: (0), red; (1), blue; (2), inapplicable.</p>
</blockquote>
<p>This seems to resolve the problem case that we encountered with reductive coding:</p>
<p><img src="Inapplicable_data_files/figure-html/unnamed-chunk-17-1.png" width="768" /></p>
<p>Both trees now receive the same score for the ‘tail colour’ character, which
contributes four steps. Two of these steps, however, correspond to steps that have
already been counted in the parent character, reflecting the two gains of a tail.</p>
<p>Although this reconstruction is logically consistent, the gain (or loss) of the tail
is now reflected in two characters – characters are not independent of one another.</p>
<p>The outcome is that each ontologically dependent character serves to increase
the weight of its parent character. The loss of a tail, for example, would
incur a cost of one step in the tail character and one step in each
ontologically dependent character, even though it represents a single
evolutionary event.</p>
</div>
<div id="why-a-single-multi-state-character-doesnt-work" class="section level3">
<h3><span class="header-section-number">3.2.4</span> Why a single multi-state character doesn’t work</h3>
<p>A different approach is to use a single character to denote both the
presence and the colour of the tail:</p>
<blockquote>
<p>Tail: (0), absent; (1), present, red; (2), present, blue.</p>
</blockquote>
<p>This seems to resolve the problem case that we encountered with reductive coding:</p>
<p><img src="Inapplicable_data_files/figure-html/unnamed-chunk-18-1.png" width="768" /></p>
<p>However, we now have a situation where the gain/loss of a tail is afforded the same weight
as a change in tail colour. We ought to prefer a tree where the tail evolved once
(and changed colour) to one where it evolved twice (being a different colour each time).</p>
<p><img src="Inapplicable_data_files/figure-html/unnamed-chunk-19-1.png" width="768" /></p>
</div>
<div id="sankoff-matrices" class="section level3">
<h3><span class="header-section-number">3.2.5</span> Sankoff matrices</h3>
<p>It would be possible to establish a Sankoff matrix
such that a change between absent and red or absent and blue cost more than
a change between red and blue, but this effectively up-weights the tail character,
and it’s not clear that this is desirable – or how much this extra weight
should be <span class="citation">(Maddison, <a href="#ref-Maddison1993">1993</a>)</span>.</p>
<div id="symmetric" class="section level4">
<h4><span class="header-section-number">3.2.5.1</span> Symmetric</h4>
<p>Consider a character with three ontologically dependent characters:</p>
<blockquote>
<p>Presence: Absent / present</p>
<p>Colour: Red / blue</p>
<p>Covering: Scaly / hairy</p>
<p>Shape: Straight / curly</p>
</blockquote>
<p>This could be coded as a single transformation series using a Sankoff matrix:</p>
<table>
<caption><span id="tab:unnamed-chunk-20">Table 3.1: </span>Tail: Cost to go from left state to top entry:</caption>
<thead>
<tr class="header">
<th></th>
<th align="left">0</th>
<th align="left">1</th>
<th align="left">2</th>
<th align="left">3</th>
<th align="left">.</th>
<th align="left">.</th>
<th align="left">.</th>
<th align="left">8</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>(0), absent</td>
<td align="left">0</td>
<td align="left">4</td>
<td align="left">4</td>
<td align="left">4</td>
<td align="left">.</td>
<td align="left">.</td>
<td align="left">.</td>
<td align="left">4</td>
</tr>
<tr class="even">
<td>(1), present, red, scaly, straight</td>
<td align="left">4</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">.</td>
<td align="left">.</td>
<td align="left">.</td>
<td align="left">3</td>
</tr>
<tr class="odd">
<td>(2), present, red, scaly, curly</td>
<td align="left">4</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">2</td>
<td align="left">.</td>
<td align="left">.</td>
<td align="left">.</td>
<td align="left">2</td>
</tr>
<tr class="even">
<td>(3), present, red, hairy, straight</td>
<td align="left">4</td>
<td align="left">1</td>
<td align="left">2</td>
<td align="left">0</td>
<td align="left">.</td>
<td align="left">.</td>
<td align="left">.</td>
<td align="left">2</td>
</tr>
<tr class="odd">
<td>.</td>
<td align="left">.</td>
<td align="left">.</td>
<td align="left">.</td>
<td align="left">.</td>
<td align="left">0</td>
<td align="left">.</td>
<td align="left">.</td>
<td align="left">.</td>
</tr>
<tr class="even">
<td>.</td>
<td align="left">.</td>
<td align="left">.</td>
<td align="left">.</td>
<td align="left">.</td>
<td align="left">.</td>
<td align="left">0</td>
<td align="left">.</td>
<td align="left">.</td>
</tr>
<tr class="odd">
<td>.</td>
<td align="left">.</td>
<td align="left">.</td>
<td align="left">.</td>
<td align="left">.</td>
<td align="left">.</td>
<td align="left">.</td>
<td align="left">0</td>
<td align="left">.</td>
</tr>
<tr class="even">
<td>(8), present, blue, hairy, curly</td>
<td align="left">4</td>
<td align="left">3</td>
<td align="left">2</td>
<td align="left">2</td>
<td align="left">.</td>
<td align="left">.</td>
<td align="left">.</td>
<td align="left">0</td>
</tr>
</tbody>
</table>
<p>The first thing to note is that each additional ontologically depedent character
generates disproportionately more complexity in the Sankoff matrix.</p>
<p>Even if this additional complexity could be handled, the underlying issue remains
that losing a tail, which arguably corresponds to a single evolutionary
event, is allocated a large cost (here, 4) that grows in line with the number of
ontogenetically dependant characters.</p>
</div>
<div id="gain-and-loss-asymmetric" class="section level4">
<h4><span class="header-section-number">3.2.5.2</span> Gain and loss asymmetric</h4>
<p>At the cost of symmetry, one could argue that the loss of a tail requires a single
transformation, whereas the gain requires the addition of a tail and the “setting”
of each ontologically dependent character, rendering an asymmetric Sankoff
matrix that nevertheless respects triangular inequality:</p>
<table>
<caption><span id="tab:unnamed-chunk-21">Table 3.2: </span>Tail: Cost to go from left to top entry:</caption>
<thead>
<tr class="header">
<th></th>
<th align="left">0</th>
<th align="left">1</th>
<th align="left">2</th>
<th align="left">3</th>
<th align="left">.</th>
<th align="left">.</th>
<th align="left">.</th>
<th align="left">8</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>(0), absent</td>
<td align="left">0</td>
<td align="left">4</td>
<td align="left">4</td>
<td align="left">4</td>
<td align="left">.</td>
<td align="left">.</td>
<td align="left">.</td>
<td align="left">4</td>
</tr>
<tr class="even">
<td>(1), present, red, scaly, straight</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">.</td>
<td align="left">.</td>
<td align="left">.</td>
<td align="left">3</td>
</tr>
<tr class="odd">
<td>(2), present, red, scaly, curly</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">2</td>
<td align="left">.</td>
<td align="left">.</td>
<td align="left">.</td>
<td align="left">2</td>
</tr>
<tr class="even">
<td>(3), present, red, hairy, straight</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">2</td>
<td align="left">0</td>
<td align="left">.</td>
<td align="left">.</td>
<td align="left">.</td>
<td align="left">2</td>
</tr>
<tr class="odd">
<td>.</td>
<td align="left">.</td>
<td align="left">.</td>
<td align="left">.</td>
<td align="left">.</td>
<td align="left">0</td>
<td align="left">.</td>
<td align="left">.</td>
<td align="left">.</td>
</tr>
<tr class="even">
<td>.</td>
<td align="left">.</td>
<td align="left">.</td>
<td align="left">.</td>
<td align="left">.</td>
<td align="left">.</td>
<td align="left">0</td>
<td align="left">.</td>
<td align="left">.</td>
</tr>
<tr class="odd">
<td>.</td>
<td align="left">.</td>
<td align="left">.</td>
<td align="left">.</td>
<td align="left">.</td>
<td align="left">.</td>
<td align="left">.</td>
<td align="left">0</td>
<td align="left">.</td>
</tr>
<tr class="even">
<td>(8), present, blue, hairy, curly</td>
<td align="left">1</td>
<td align="left">3</td>
<td align="left">2</td>
<td align="left">2</td>
<td align="left">.</td>
<td align="left">.</td>
<td align="left">.</td>
<td align="left">0</td>
</tr>
</tbody>
</table>
<p>Here, though, we encounter a new problem: reconstructions involving very many losses
are preferred to those involving a single gain.</p>
<p><img src="Inapplicable_data_files/figure-html/unnamed-chunk-22-1.png" width="768" /></p>
</div>
</div>
<div id="conclusion" class="section level3">
<h3><span class="header-section-number">3.2.6</span> Conclusion</h3>
<p>No coding mechanism can generate consistent and logically meaningful tree scores
when employing the Fitch algorithm. The inapplicable state needs treating
differently from other states. A <a href="OurSolution.html">new algorithm</a> is needed.</p>

</div>
</div>
<div id="the-problem-with-counting-steps" class="section level2">
<h2><span class="header-section-number">3.3</span> The problem with counting steps</h2>
<p>If a new algorithm is called for, how should it work?</p>
<p>One promising approach is to count transitions between applicable states, but not transitions from the applicable state to the inapplicable state:</p>
<p><img src="Inapplicable_data_files/figure-html/unnamed-chunk-24-1.png" width="576" /></p>
<p>The problem here is that the number of steps can be minimized by maximizing the number of independent gains of a parent character.</p>
<p><img src="Inapplicable_data_files/figure-html/unnamed-chunk-25-1.png" width="768" /></p>
<p>Algorithms that count steps will always be afflicted by a form of this issue. The solution is to count not steps, but homoplasies.</p>

</div>
</div>
<h3>References</h3>
<div id="refs" class="references">
<div id="ref-Agnarsson2008">
<p>Agnarsson, I., &amp; Miller, J. A. (2008). Is <span class="smallcaps">AccTran</span> better than <span class="smallcaps">DelTran</span>? <em>Cladistics</em>, <em>24</em>(6), 1032–1038. doi:<a href="https://doi.org/10.1111/j.1096-0031.2008.00229.x">10.1111/j.1096-0031.2008.00229.x</a></p>
</div>
<div id="ref-Maddison1993">
<p>Maddison, W. P. (1993). Missing data versus missing characters in phylogenetic analysis. <em>Systematic Biology</em>, <em>42</em>(4), 576–581. doi:<a href="https://doi.org/10.1093/sysbio/42.4.576">10.1093/sysbio/42.4.576</a></p>
</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="the-fitch-algorithm.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="a-solution.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"google": false,
"linkedin": false,
"weibo": false,
"instapper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": "https://github.com/TGuillerme/Inapp/inst/gitbook/edit/master/01a_Optimization.Rmd",
"text": "Edit"
},
"download": ["Inapplicable_data.pdf"],
"toc": {
"collapse": "subsection"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:" && /^https?:/.test(src))
      src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
