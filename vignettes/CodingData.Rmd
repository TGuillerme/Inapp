---
title: "Implications for character coding"
author: "Martin R. Smith"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
bibliography: ../inst/REFERENCES.bib
csl: https://raw.githubusercontent.com/citation-style-language/styles/master/apa-old-doi-prefix.csl
vignette: >
  %\VignetteIndexEntry{6. Implications for characters}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{R initialize, message=FALSE, include=FALSE}
library('knitr'); library('Inapp')
quickPlot <- function (tree, character, na=TRUE, legend.pos='bottomleft') {
  tree$edge.length <- rep(1, dim(tree$edge)[1])
  reconstruction <- apply.reconstruction(tree, character, 
                            method=if(na) "NA" else 'Fitch',
                            match.tip.char=TRUE)
  dev.new(); plot(tree, direction='upwards'); corners <- par('usr'); dev.off()
  plot(reconstruction,
       passes=if(na) 1:4 else 1:2, counts=1:2, 
       direction='upwards', legend.pos=legend.pos,
       col.states=TRUE, use.edge.length=TRUE, 
       x.lim=c(-3, corners[2]), y.lim=c(-1, corners[4]+0.1))
}
setPar <- function (mfrow=c(1, 2)) par(mfrow=mfrow, mar=c(0.2, 0.2, 0.66, 0.2), oma=c(1,0,0,0), cex=0.7)

ap <- c("Absent", "Present")
rb <- c("Red", "Blue")
```

# Inapplicable data in a parsimony setting

This is one of a [series](Index.html) of vignettes that works through the inapplicable algorithm proposed by Brazeau _et al._ [-@ThisStudy].

We assume that you'll already have read the [description](OurAlgorithm.html) of our algorithm.

## How this algorithm weights against multiple innovations

We discussed in an [earlier vignette](FailedSolutions.html) that, if we only 
penalise transformations between states in subsidiary characters, 
trees that imply multiple origins of the parent character receive much lower scores
than those in which the parent character evolves once (but its subsidiary characteristics
change multiple times).

Our algorithm counterbalances this by, in effect, imposing a cost for each additional
origin of the parent character.  At first blush, this sounds like it is weighting
against multiple innovations of the parent character -- but this isn't so; it
weights against multiple independent innovations of the SAME state (i.e. homoplasy),
but if a red tail evolved here and a blue tail evolved there, then two innovations of the 
tail imposes a cost of one (additional region) for tail colour, whereas a single innovation of the tail would also impose a cost of one (transformation) for tail colour.
The additional origin of the tail can

- This has a side-effect that we'll study with an invariant character

## Multiple dependencies

It's not a problem to have characters dependent on characters that are dependent
on characters.  Consider the following character heirarchy:

  1. Appendages: (0), absent; (1), present.
  2. Appendage termination: (0), blunt; (1), claw; (2), sucker.
  3. Claw morphology: (0), smooth; (1), serrated.
  4. Sucker morphology: (0), round; (1), polygonal.

The included taxa may or may not bear appendages; if they do, then the 
appendages may end either with either claws or suckers, or neither (but not both).
Claws come in two flavours, smooth and serrated; suckers come in two shapes,
rounded and polygonal.

If character 1 (appendages) is absent, then characters 2--4 are inapplicable.
Otherwise, charcter 2 (appendage termination) must take one of the three applicable values.

If character 2 (termination) has state 0 (blunt), then characters 3 and 4 
(morphology of claw / sucker) are inapplicable.

If character 2 (termination) has state 1 (claw), then character 3
(claw morphology) is applicable and character 4 (sucker morphology) is inapplicable.

If character 2 (termination) has state 2 (sucker), then character 3 
(claw morphology) is inapplicable and character 4 (sucker morphology) is 
applicable.

A sample character matrix might look like this:

```{R Multiple dependencies, echo=FALSE, asis=TRUE}
nNone <- 3
c1 <- c(rep(0, nNone), rep(1, 10))
c2 <- c(rep('-', nNone), rep(0, 2), rep(1, 4), rep(2, 4))
c3 <- c(rep('-', nNone + 2), 0, 0, 1, 1, rep('-', 4))
c4 <- c(rep('-', nNone + 2 + 4), 0, 0, 1, 1)
mDep <- matrix(c(c1, c2, c3, c4), byrow=TRUE, ncol=length(c1))
colnames(mDep) <- LETTERS[seq_along(c1)]
rownames(mDep) <- c("Appendages: (0), absent; (1), present.",
                    "Appendage termination: (0), blunt; (1), claw; (2), sucker.",
                    "Claw morphology: (0), smooth; (1), serrated.", 
                    "Sucker morphology: (0), round; (1), polygonal.")
kable(mDep, capiton="Coding")
```

Which would plot on a tree thus:

```{R Multiple dependencies trees, echo=FALSE, fig.width=8, fig.height=16}
goodtree <- ape::read.tree(text="(a, (b, (c, ((d, e), ((f, (g, (h, i))), ((j, k), (l, m)))))));")
badtree <- ape::read.tree(text="(A, (C, (B, ((D, E), ((F, (J, (K, I))), ((G, H), (L, M)))))));")
par(mfrow=c(4, 2), cex=0.7, mar=c(0, 0.2, 0.6, 0.2), oma=c(0, 0, 2, 0))

Contrast <- function (character, char.label, states.labels, y=0, header=FALSE) {
    vignettePlot(goodtree, character, na=!header, 
                 legend.pos='topleft', state.labels=states.labels)
    text(14, y, char.label, pos=2)
    ape::tiplabels(LETTERS[1:13], frame='none', adj=c(0.5, -1.5))
    if (header) title("An optimal tree")
    vignettePlot(badtree, character, na=!header, 
                 legend.pos='topleft', state.labels=states.labels)
    text(14, y, char.label, pos=2)
    ape::tiplabels(badtree$tip.label, frame='none', adj=c(0.5, -1.5))
    if (header) title("A suboptimal tree")
    
}

Contrast('0001111111111', "Appendages:", c('absent', 'present'), header=TRUE)
Contrast('---0011112222', "Appendage termination:", c("blunt", "claw", "sucker"), y=1.5)
Contrast('-----0011----', "Claw morphology:", c("smooth", "serrated"), y=0.5)
Contrast('---------0011', "Sucker morphology:", c("round", "polygonal"), y=0.5)
mtext("Appendage condition", outer=TRUE)

```



## A parsimony uninformative character that informs parsimony!

- All tails are blue.  Let's say that they are all blue for some complex molecular reason, such that it is most parsimonious if "blueness" has a single evolutionary origin.

```{r tail colour characters, echo = FALSE, results='asis'}
tail <- c(0, 0, 0, 0, 1, 1, 1, 1)
col <- c(rep('-', 4), rep(1, 4))
bcol <- c(1,1, 2,2,2,2, 1,1)
blueTails <- matrix(c(tail, col, bcol), byrow=TRUE, ncol=length(tail))
colnames(blueTails) <- LETTERS[seq_along(tail)]
rownames(blueTails) <- c("Tail: (0), absent; (1), present",
                         "Tail colour: (-), inapplicable; (1), blue",
                         "Body colour: (1), black; (2), white")
kable(blueTails, capiton="Coding")
```

- This complex molecular reason is grounds to suspect that the tails have a common ancestor
- More formally, we wish to attribute this complex molecular reason to common ancestry, rather than homoplasy
- Thus "blueness" represents a separate character that has the same distribution as tails (or a sbuset thereof, if some tails are of uncertain colour)

Let's compare two trees.  One groups taxa based on the presence of tails; the other
groups taxa based on body colour.

```{R invariant yet informative, echo=FALSE, fig.height=3, fig.width=8}
tailTree <- ape::read.tree(text="((((A:1, B:1):1, C:1):1, D:1):1, (E:1, (F:1, (G:1, H:1):1):1):1);")
bodyTree <- ape::read.tree(text="((((F, E), C), D), (A, (B, (G, H))));")
tail <- "00001111"
col <- "----1111"
bcol <- "11222211"

par(mfrow=c(1, 2), mar=c(0, 0.2, 0.2, 0.2), oma=c(0, 0, 2, 0), cex=0.8)
quickPlot(tailTree, tail, FALSE)
quickPlot(bodyTree, tail, FALSE)
mtext("Tail presence", outer=TRUE)


quickPlot(tailTree, col)
quickPlot(bodyTree, col)
mtext("Tail colour", outer=TRUE)

quickPlot(tailTree, bcol, FALSE)
quickPlot(bodyTree, bcol, FALSE)
mtext("Body colour", outer=TRUE)
```

- So the tree on the left, which reconstructs a single origin of the tail, a single origin of a blue tail colouration, and two changes in body colour, is preferred to the tree on the right, which reconstructs a single change in body colour but two origins of the tail, and two origins of blue colouration on the tail.

- We should include this character if it's meaningful.  But not if it's not (e.g. number of base pairs in a tail).


## Neomorphic and transformational characters

Researchers should be aware that our algorithm treats nemorphic characters as though they are transformational; that is, "absence" of a feature is seen as equally informative as "presence".  In some cases, this may be desirable: For example, it is not difficult to argue that "serrated margin on tail: present / absent" behaves as a transformational character, as a tail must have a margin of some sort, and "serratedness" is a property of the margin.  

In other cases, this may not be desirable.  As an example, consider a complex character, such as the eyespots on the tail of a peacock.  

```{r tail eyespot characters, echo = FALSE, results='asis'}

tail <- c(0, 0, 0, 1, 1, 1, 1, 1, 1)
eyespot <- c("-", "-", "-", 0,0,0,0,1,1)

tailEyes <- matrix(c(tail, eyespot), byrow=TRUE, ncol=length(tail))
colnames(tailEyes) <- LETTERS[seq_along(tail)]
rownames(tailEyes) <- c("Tail: (0), absent; (1), present",
                        "Tail eyespots: (-), inapplicable; (0), absent; (1), present")
kable(tailEyes, capiton="Coding")
```

The presence of tail eyespots obviously contains grouping information, but it is less obvious whether the absence of such complex features should convey grouping information.  This decision ought to be defended for individual characters by individual researchers, but researchers should be aware of the implications of their chosen coding strategy. 

```{R tail spot alternatives, echo=FALSE, fig.height=8, fig.width=4}
par(mfrow=c(3, 1), mar=c(0.2, 0.2, 0.2, 0.2), oma=c(1,1,1,1))
splitSpots <- ape::read.tree(text="(((H, C), A), (B, (D, (E, (G, (F, H))))));")
naysHaveIt <- ape::read.tree(text="((((H, I), C), A), (B, (D, (E, (G, F)))));")
eyesHaveIt <- ape::read.tree(text="(((((H, I), G), C), A), (B, (D, (E, F))));")
#tail <- "000111111"
col <- "---000011"


quickPlot(naysHaveIt, col)
mtext("One tail spotted, one not", cex=0.8)
quickPlot(splitSpots, col)
mtext("Two spot appearances", cex=0.8)
quickPlot(eyesHaveIt, col)
mtext("Two non-spotted appearances", cex=0.8)

```

All of these trees imply two independent origins of the tail.  Their score differs only with respect to the eyespots character.


The fisrt tree has the minimum possible score for the eyespots character.  (A score of one would also be obtained if the tail evolved once, and a single transformation occurred between 0 and 1 -- but we are only considering trees where the tail evolved twice.)  

The next tree has a score of two for the eyespots character, which is obviously correct: Eye spots, a complex character, have evolved twice independently, which is not as parsimonious.

The final tree also has a score of two for the eyespots character: even though eyespots have only evolved once, just as in the first tree.  The score of two occurs because the "absence of eyespots" has evolved twice.  

It is possible that a researcher might feel uncomfortable grouping taxa on the basis of the non-occurrence of a complex feature that did not occur in their common ancestor.  Putting this another way, it is not clear that the fact that a feature has not evolved in two instances represents a homoplasy.  The absence of eyespots in a tail is not an evolutionary innovation -- it is an inheritance from a common ancestor that did not have eyespots (and did not have a tail).

A researcher that argues that the absence of a feature contains phylogenetic information must surely include all properties of a tail that are only observed in a single taxon (because the absence of that feature in other taxa also contains grouping information).  A researcher may also include all properties of a tail that do not occur in any of the taxon in interest, for these too will influence tree topology.


```{r Glowing in the dark 2, echo = FALSE, results='asis'}

tail <- c(0, 0, 0, 1, 1, 1, 1)
gitd <- c("-", "-", "-", "{01}","{01}",0,0)
elec <- c("-", "-", "-", "{01}","{01}",0,0)

unobserved <- matrix(c(tail, gitd, elec), byrow=TRUE, ncol=length(tail))
colnames(unobserved) <- LETTERS[seq_along(tail)]
rownames(unobserved) <- c("Tail: (0), absent; (1), present",
                        "Tail with glow-in-the-dark pigment: (-), inapplicable; (0), absent; (1), present",
                        "Tail with ability to generate electricity: (-), inapplicable; (0), absent; (1), present")
kable(unobserved, capiton="Coding")
```

Note that each of the unobserved characters provides evidence against independent origins of the tail, preferring instead independent losses:

```{R unobserved character 2, echo=FALSE, fig.height=3.2, fig.width=8}
par(mfrow=c(1, 2), mar=c(0.2, 0.2, 0.2, 0.2), oma=c(1,0,0,0), cex=0.8)
better <- ape::read.tree(text="(((F, G), C), (A, (B, (D, E))));")
worse  <- ape::read.tree(text="(((F, C), G), (A, (B, (D, E))));")
col <- "---{01}{01}00"

quickPlot(better, col)
mtext("Tail with glow-in-the-dark pigment: (-), inapplicable; (0), absent; (1), present",
      side=1, line=0, outer=TRUE)
quickPlot(worse, col)

```

Thus the simple matrix presented above sees both of these trees as equally parsimonious -- three losses of a single-origin tail that lacks two unlikely attributes is considered as likely as one independent gain of a similar tail.  

This behaviour is desired if the similarity between the tails requires an evoltuionary explanation.  But the absence of these features does not seem any more difficult to explain if the tails do not have a common ancestor.

The solution here is to deploy a different character coding strategy, coding absences as absences.  That way, absence CAN be inherited from a common ancestor, in whcih the a compelx-feature-of-the-tail (eyespots, glow-inthe-dark pigment) was absent (and the tail was absent too).

```{r Glowing in the dark 3, echo = FALSE, results='asis'}

tail <- c(0, 0, 0, 1, 1, 1, 1)
gitd <- c(0, 0,0, "{01}","{01}",0,0)
elec <- c(0,0,0, "{01}","{01}",0,0)

unobserved <- matrix(c(tail, gitd, elec), byrow=TRUE, ncol=length(tail))
colnames(unobserved) <- LETTERS[seq_along(tail)]
rownames(unobserved) <- c("Tail: (0), absent; (1), present",
                        "Tail with glow-in-the-dark pigment: (-), inapplicable; (0), absent; (1), present",
                        "Tail with ability to generate electricity: (-), inapplicable; (0), absent; (1), present")
kable(unobserved, capiton="Coding")
```

This can be handled by the Fitch algorithm, and works well in simple cases:
```{R unobserved character 3, echo=FALSE, fig.height=3, fig.width=8}
par(mfrow=c(1, 2), mar=c(0.2, 0.2, 0.2, 0.2), oma=c(1,0,0,0), cex=0.8)
better <- ape::read.tree(text="(((F, G), C), (A, (B, (D, E))));")
worse  <- ape::read.tree(text="(((F, C), G), (A, (B, (D, E))));")
col <- "000{01}{01}00"

quickPlot(better, col, na=FALSE)
mtext("Tail with glow-in-the-dark pigment: (-), inapplicable; (0), absent; (1), present",
      side=1, line=0, outer=TRUE)
quickPlot(worse, col, na=FALSE)

```

The behaviour only becomes questionable when a tail is secondarily lost, then re-gained, as the loss of a tail seems like it should be a single evolutionary step, but also causes the loss of all contingent characters, which must then "reevolve" as though they had never existed:

```{R loss and gain, echo=FALSE, fig.width=4, fig.height=4}
par(mfrow=c(1, 1), mar=c(0.2, 0.2, 0.2, 0.2), oma=c(1,0,0,0), cex=0.8)
imbal <- ape::read.tree(text="(A, (B, (C, (D, (E, (F, G))))));")
tail <- "1100011"
eyespots <- "1100011"

quickPlot(imbal, eyespots, na=FALSE, legend.pos='topleft')
mtext("Tail eyespots: (0), absent; (1), present", side=1, line=0, outer=TRUE)


```

Perhaps there are cases -- as might be seen in phenotypic plasticity -- where a tail might be lost, and then re-activate preexisting genes when it evolves again?  This starts to require an explicit model of evolution, however, which is somewhat beyond the remit of parsimony.

### Recommendation
- Neomorphic characters should probably be coded as absent everywhere they are absent, whether this is because there's no tail or because there's a tail without the complex feature.

### Ambiguity

Care must be taken when coding ambiguous data.

#### Ambiguity when parent character ambiguous

If it's not clear whether or not a taxon has a tail, then tail colour should be 
coded as `?`, denoting that any possible token (including the inapplicable token)
may be the most parsimonious for the tail.

In trees in which the tail can be reconstructed as present, the ambiguous tip
will be reconstructed as having a tail of the appropriate colour:

```{R fully amb, echo=FALSE, fig.width=8, fig.height=3}
setPar()
hasTail   <- ape::read.tree(text="((a, (b, (c, d))), (e, ((f, (g, X)), (h, i))));")
lacksTail <- ape::read.tree(text="((a, (b, (X, (c, d)))), (e, ((f, g), (h, i))));")
tail <- "000001111?"
col  <- "-----0011?"

vignettePlot(hasTail, tail, legend.pos='topleft', na=FALSE, main="Tail", state.labels = ap)
vignettePlot(hasTail, col, legend.pos='topleft', main="Tail colour", state.labels = rb)

```

In trees in which the tail cannot be reconstructed as present without inferring
a homoplasious origin, the tail colour will be reconstructed as inapplicable:

```{R fully amb - absent, echo=FALSE< fig.width=8, fig.height=3}
setPar()
vignettePlot(lacksTail, tail, legend.pos='topleft', na=FALSE, main="Tail", state.labels = ap)
vignettePlot(lacksTail, col, legend.pos='topleft', main="Tail colour", state.labels = rb)
```

#### Ambiguity when parent character known



If you're coding a neomorphic character as transformational, then you encounter problems.

```{R Untitled 4, echo=FALSE, fig.height=3, fig.width=6}
setPar()
better <- ape::read.tree(text="(((F, G), C), (A, (B, (D, E))));")
worse  <- ape::read.tree(text="(((F, C), G), (A, (B, (D, E))));")
tail <- "0001111"
col <- "---{01}{01}00"

vignettePlot(better, col)
vignettePlot(worse, col)

mtext(side=1, line=0, "Tail with glow-in-the-dark pigment: (-), inapplicable; (0), absent; (1), present", cex=0.8, outer=TRUE)

```


### Difficulties
<mark>Here are some marginal cases where discretion is required.</mark>

<mark>Here are some trees that show why we would code things our way
this is why you need to look at your data carefully and see whether you like what your mode of coding is implying!</mark>

## References
