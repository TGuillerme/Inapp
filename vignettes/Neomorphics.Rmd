---
title: "Coding ontologically dependent neomorphic characters"
author: "Martin R. Smith"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
bibliography: ../inst/REFERENCES.bib
csl: https://raw.githubusercontent.com/citation-style-language/styles/master/apa-old-doi-prefix.csl
vignette: >
  %\VignetteIndexEntry{7. Neomorphic characters}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

## Neomorphic and transformational characters

Researchers should be aware that our algorithm treats nemorphic characters as though they are transformational; that is, "absence" of a feature is seen as equally informative as "presence".  In some cases, this may be desirable: For example, it is not difficult to argue that "serrated margin on tail: present / absent" behaves as a transformational character, as a tail must have a margin of some sort, and "serratedness" is a property of the margin.  

In other cases, this may not be desirable.  As an example, consider a complex character, such as the eyespots on the tail of a peacock.  

```{r tail eyespot characters, echo = FALSE, results='asis'}

tail <- c(0, 0, 0, 1, 1, 1, 1, 1, 1)
eyespot <- c("-", "-", "-", 0,0,0,0,1,1)

tailEyes <- matrix(c(tail, eyespot), byrow=TRUE, ncol=length(tail))
colnames(tailEyes) <- LETTERS[seq_along(tail)]
rownames(tailEyes) <- c("Tail: (0), absent; (1), present",
                        "Tail eyespots: (-), inapplicable; (0), absent; (1), present")
kable(tailEyes, capiton="Coding")
```

The presence of tail eyespots obviously contains grouping information, but it is less obvious whether the absence of such complex features should convey grouping information.  This decision ought to be defended for individual characters by individual researchers, but researchers should be aware of the implications of their chosen coding strategy. 

```{R tail spot alternatives, echo=FALSE, fig.height=8, fig.width=4}
par(mfrow=c(3, 1), mar=c(0.2, 0.2, 0.2, 0.2), oma=c(1,1,1,1))
splitSpots <- ape::read.tree(text="(((H, C), A), (B, (D, (E, (G, (F, H))))));")
naysHaveIt <- ape::read.tree(text="((((H, I), C), A), (B, (D, (E, (G, F)))));")
eyesHaveIt <- ape::read.tree(text="(((((H, I), G), C), A), (B, (D, (E, F))));")
#tail <- "000111111"
col <- "---000011"


quickPlot(naysHaveIt, col)
mtext("One tail spotted, one not", cex=0.8)
quickPlot(splitSpots, col)
mtext("Two spot appearances", cex=0.8)
quickPlot(eyesHaveIt, col)
mtext("Two non-spotted appearances", cex=0.8)

```

All of these trees imply two independent origins of the tail.  Their score differs only with respect to the eyespots character.


The fisrt tree has the minimum possible score for the eyespots character.  (A score of one would also be obtained if the tail evolved once, and a single transformation occurred between 0 and 1 -- but we are only considering trees where the tail evolved twice.)  

The next tree has a score of two for the eyespots character, which is obviously correct: Eye spots, a complex character, have evolved twice independently, which is not as parsimonious.

The final tree also has a score of two for the eyespots character: even though eyespots have only evolved once, just as in the first tree.  The score of two occurs because the "absence of eyespots" has evolved twice.  

It is possible that a researcher might feel uncomfortable grouping taxa on the basis of the non-occurrence of a complex feature that did not occur in their common ancestor.  Putting this another way, it is not clear that the fact that a feature has not evolved in two instances represents a homoplasy.  The absence of eyespots in a tail is not an evolutionary innovation -- it is an inheritance from a common ancestor that did not have eyespots (and did not have a tail).

A researcher that argues that the absence of a feature contains phylogenetic information must surely include all properties of a tail that are only observed in a single taxon (because the absence of that feature in other taxa also contains grouping information).  A researcher may also include all properties of a tail that do not occur in any of the taxon in interest, for these too will influence tree topology.


```{r Glowing in the dark 2, echo = FALSE, results='asis'}

tail <- c(0, 0, 0, 1, 1, 1, 1)
gitd <- c("-", "-", "-", "{01}","{01}",0,0)
elec <- c("-", "-", "-", "{01}","{01}",0,0)

unobserved <- matrix(c(tail, gitd, elec), byrow=TRUE, ncol=length(tail))
colnames(unobserved) <- LETTERS[seq_along(tail)]
rownames(unobserved) <- c("Tail: (0), absent; (1), present",
                        "Tail with glow-in-the-dark pigment: (-), inapplicable; (0), absent; (1), present",
                        "Tail with ability to generate electricity: (-), inapplicable; (0), absent; (1), present")
kable(unobserved, capiton="Coding")
```

Note that each of the unobserved characters provides evidence against independent origins of the tail, preferring instead independent losses:

```{R unobserved character 2, echo=FALSE, fig.height=3.2, fig.width=8}
par(mfrow=c(1, 2), mar=c(0.2, 0.2, 0.2, 0.2), oma=c(1,0,0,0), cex=0.8)
better <- ape::read.tree(text="(((F, G), C), (A, (B, (D, E))));")
worse  <- ape::read.tree(text="(((F, C), G), (A, (B, (D, E))));")
col <- "---{01}{01}00"

quickPlot(better, col)
mtext("Tail with glow-in-the-dark pigment: (-), inapplicable; (0), absent; (1), present",
      side=1, line=0, outer=TRUE)
quickPlot(worse, col)

```

Thus the simple matrix presented above sees both of these trees as equally parsimonious -- three losses of a single-origin tail that lacks two unlikely attributes is considered as likely as one independent gain of a similar tail.  

This behaviour is desired if the similarity between the tails requires an evoltuionary explanation.  But the absence of these features does not seem any more difficult to explain if the tails do not have a common ancestor.

The solution here is to deploy a different character coding strategy, coding absences as absences.  That way, absence CAN be inherited from a common ancestor, in whcih the a compelx-feature-of-the-tail (eyespots, glow-inthe-dark pigment) was absent (and the tail was absent too).

```{r Glowing in the dark 3, echo = FALSE, results='asis'}

tail <- c(0, 0, 0, 1, 1, 1, 1)
gitd <- c(0, 0,0, "{01}","{01}",0,0)
elec <- c(0,0,0, "{01}","{01}",0,0)

unobserved <- matrix(c(tail, gitd, elec), byrow=TRUE, ncol=length(tail))
colnames(unobserved) <- LETTERS[seq_along(tail)]
rownames(unobserved) <- c("Tail: (0), absent; (1), present",
                        "Tail with glow-in-the-dark pigment: (-), inapplicable; (0), absent; (1), present",
                        "Tail with ability to generate electricity: (-), inapplicable; (0), absent; (1), present")
kable(unobserved, capiton="Coding")
```

This can be handled by the Fitch algorithm, and works well in simple cases:

```{R unobserved character 3, echo=FALSE, fig.height=3, fig.width=8}
par(mfrow=c(1, 2), mar=c(0.2, 0.2, 0.2, 0.2), oma=c(1,0,0,0), cex=0.8)
better <- ape::read.tree(text="(((F, G), C), (A, (B, (D, E))));")
worse  <- ape::read.tree(text="(((F, C), G), (A, (B, (D, E))));")
col <- "000{01}{01}00"

quickPlot(better, col, na=FALSE)
mtext("Tail with glow-in-the-dark pigment: (-), inapplicable; (0), absent; (1), present",
      side=1, line=0, outer=TRUE)
quickPlot(worse, col, na=FALSE)

```

The behaviour only becomes questionable when a tail is secondarily lost, then re-gained, as the loss of a tail seems like it should be a single evolutionary step, but also causes the loss of all contingent characters, which must then "reevolve" as though they had never existed:

```{R loss and gain, echo=FALSE, fig.width=4, fig.height=4}
par(mfrow=c(1, 1), mar=c(0.2, 0.2, 0.2, 0.2), oma=c(1,0,0,0), cex=0.8)
imbal <- ape::read.tree(text="(A, (B, (C, (D, (E, (F, G))))));")
tail <- "1100011"
eyespots <- "1100011"

quickPlot(imbal, eyespots, na=FALSE, legend.pos='topleft')
mtext("Tail eyespots: (0), absent; (1), present", side=1, line=0, outer=TRUE)


```

Perhaps there are cases -- as might be seen in phenotypic plasticity -- where a tail might be lost, and then re-activate preexisting genes when it evolves again?  This starts to require an explicit model of evolution, however, which is somewhat beyond the remit of parsimony.

### Recommendation
- Neomorphic characters should probably be coded as absent everywhere they are absent, whether this is because there's no tail or because there's a tail without the complex feature.



If you're coding a neomorphic character as transformational, then you encounter problems.

```{R Untitled 4, echo=FALSE, fig.height=3, fig.width=6}
setPar()
better <- ape::read.tree(text="(((F, G), C), (A, (B, (D, E))));")
worse  <- ape::read.tree(text="(((F, C), G), (A, (B, (D, E))));")
tail <- "0001111"
col <- "---{01}{01}00"

vignettePlot(better, col)
vignettePlot(worse, col)

mtext(side=1, line=0, "Tail with glow-in-the-dark pigment: (-), inapplicable; (0), absent; (1), present", cex=0.8, outer=TRUE)

```

