---
title: "Implications for character coding"
author: "Martin R. Smith"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
bibliography: ../inst/REFERENCES.bib
csl: https://raw.githubusercontent.com/citation-style-language/styles/master/apa-old-doi-prefix.csl
vignette: >
  %\VignetteIndexEntry{6. Implications for characters}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{R initialize, message=FALSE, include=FALSE}
library('knitr'); library('Inapp')
quickPlot <- function (tree, character, na=TRUE, legend.pos='bottomleft') {
  tree$edge.length <- rep(1, dim(tree$edge)[1])
  reconstruction <- apply.reconstruction(tree, character, 
                            method=if(na) "NA" else 'Fitch',
                            match.tip.char=TRUE)
  dev.new(); plot(tree, direction='upwards'); corners <- par('usr'); dev.off()
  plot(reconstruction,
       passes=if(na) 1:4 else 1:2, counts=1:2, 
       direction='upwards', legend.pos=legend.pos,
       col.states=TRUE, use.edge.length=TRUE, 
       x.lim=c(-3, corners[2]), y.lim=c(-1, corners[4]+0.1))
}
setPar <- function (mfrow=c(1, 2)) par(mfrow=mfrow, mar=c(0.2, 0.2, 0.66, 0.2), oma=c(1,0,0,0), cex=0.7)

ap <- c("Absent", "Present")
rb <- c("Red", "Blue")
```

# Inapplicable data in a parsimony setting

This is one of a [series](Index.html) of vignettes that works through the inapplicable algorithm proposed by Brazeau _et al._ [-@ThisStudy].

We assume that you'll already have read the [description](OurAlgorithm.html) of our algorithm.


## Multiple dependencies

It's not a problem to have characters dependent on characters that are dependent
on characters.  Consider the following characters, whose descriptions are written in order to emphasize their heirarchical nature [following the recommendations of @Sereno2007]:

  1. Appendages: (0), absent; (1), present.
  2. Appendages, termination: (0), blunt; (1), sucker; (2), claw.
  3. Appendages, suckers, morphology: (0), round; (1), polygonal.
  4. Appendages, claws, morphology: (0), smooth; (1), serrated.

The included taxa may or may not bear appendages; if they do, then the 
appendages may end either with either claws or suckers, or neither (but not both).
Claws come in two flavours, smooth and serrated; suckers come in two shapes,
rounded and polygonal.

If character 1 (appendages) is absent, then characters 2--4 are inapplicable.
Otherwise, charcter 2 (appendage termination) must take one of the three applicable values.

If character 2 (termination) has state 0 (blunt), then characters 3 and 4 
(morphology of sucker / claw) are inapplicable.

If character 2 (termination) has state 1 (sucker), then character 3
(sucker morphology) is applicable and character 4 (claw morphology) is inapplicable.

If character 2 (termination) has state 2 (claw), then character 3 
(sucker morphology) is inapplicable and character 4 (claw morphology) is 
applicable.

A sample character matrix might look like this:

```{R Multiple dependencies, echo=FALSE, asis=TRUE}
nNone <- 3
c1 <- c(rep(0, nNone), rep(1, 10))
c2 <- c(rep('-', nNone), rep(0, 2), rep(1, 4), rep(2, 4))
c3 <- c(rep('-', nNone + 2), 0, 0, 1, 1, rep('-', 4))
c4 <- c(rep('-', nNone + 2 + 4), 0, 0, 1, 1)
mDep <- matrix(c(c1, c2, c3, c4), byrow=TRUE, ncol=length(c1))
colnames(mDep) <- LETTERS[seq_along(c1)]
rownames(mDep) <- c("Appendages: (0), absent; (1), present.",
                    "Appendage termination: (0), blunt; (1), sucker; (2), claw.",
                    "Sucker morphology: (0), smooth; (1), serrated.", 
                    "Claw morphology: (0), round; (1), polygonal.")
knitr::kable(mDep, capiton="Coding")
```

Which would plot on a tree thus:

```{R Multiple dependencies trees, echo=FALSE, fig.width=8, fig.height=16}
goodtree <- ape::read.tree(text="(a, (b, (c, ((d, e), ((f, (g, (h, i))), ((j, k), (l, m)))))));")
badtree <- ape::read.tree(text="(A, (C, (B, ((D, E), ((F, (J, (K, I))), ((G, H), (L, M)))))));")
par(mfrow=c(4, 2), cex=0.7, mar=c(0, 0.2, 0.6, 0.2), oma=c(0, 0, 2, 0))

Contrast <- function (character, char.label, states.labels, y=0, header=FALSE) {
    vignettePlot(goodtree, character, na=!header, 
                 legend.pos='topleft', state.labels=states.labels)
    text(14, y, char.label, pos=2)
    ape::tiplabels(LETTERS[1:13], frame='none', adj=c(0.5, -1.5))
    if (header) title("An optimal tree")
    vignettePlot(badtree, character, na=!header, 
                 legend.pos='topleft', state.labels=states.labels)
    text(14, y, char.label, pos=2)
    ape::tiplabels(badtree$tip.label, frame='none', adj=c(0.5, -1.5))
    if (header) title("A suboptimal tree")
    
}

Contrast('0001111111111', "Appendages:", c('absent', 'present'), header=TRUE)
Contrast('---0011112222', "Appendage termination:", c("blunt", "claw", "sucker"), y=1.5)
Contrast('-----0011----', "Claw morphology:", c("smooth", "serrated"), y=0.5)
Contrast('---------0011', "Sucker morphology:", c("round", "polygonal"), y=0.5)
mtext("Appendage condition", outer=TRUE)

```

There's no limit to the depth of recursion: one could add a further character 

  5. Appendages, claws, serrations, spacing: (0), regular; (1), irregular.
 
that would be inapplicable in all taxa that lacked serrated claws.

```{R, echo=FALSE, fig.width=8, fig.height=4}
setPar(c(1, 2))
Contrast('-------11----', "Serration spacing:", c("regular", "irregular"), y=0.5)
```

If you are surprised that the two trees receive a different score for this invariant character, read on...

## Invariant characters can inform parsimony

Consider a situation in which every tail in the observed taxa is blue  -- but
the same complex molecular machinery is responsible for this blue colouration in 
every taxon.

If its underlying mechanism is considered biologically and evolutionarily meaningful, then 
a systematist might opt to include tail colour as an additional character, even
though it is invariant in the taxa of interest.  Reconstructions that attribute this
common colouration to common ancestry will be more parsimonious than those that do not.

```{r tail colour characters, echo = FALSE, results='asis'}
tail <- c(0, 0, 0, 0, 1, 1, 1, 1)
col <- c(rep('-', 4), rep(1, 4))
bcol <- c(1,1, 2,2,2,2, 1,1)
blueTails <- matrix(c(tail, col, bcol), byrow=TRUE, ncol=length(tail))
colnames(blueTails) <- LETTERS[seq_along(tail)]
rownames(blueTails) <- c("Tail: (0), absent; (1), present",
                         "Tail colour: (1), blue; (-), inapplicable",
                         "Body colour: (1), black; (2), white")
kable(blueTails, capiton="Coding")
```

Let's compare two trees.  The first groups taxa based on the presence of tails; the other
groups taxa based on body colour.  


```{R, echo=FALSE, fig.height=3, fig.width=8}
tailTree <- ape::read.tree(text="((((A:1, B:1):1, C:1):1, D:1):1, (E:1, (F:1, (G:1, H:1):1):1):1);")
bodyTree <- ape::read.tree(text="((((F, E), C), D), (A, (B, (G, H))));")
tail <- "00001111"
col <- "----1111"
bcol <- "11222211"

par(mfrow=c(1, 2), mar=c(0, 0.2, 1.2, 0.2), oma=c(0, 0, 2, 0), cex=0.8)
vignettePlot(tailTree, tail, FALSE, main="Single tail gain\nTotal score: 3", cex.main=0.8, passes=2)
vignettePlot(bodyTree, tail, FALSE, main="Single body colour change\nTotal score: 4", cex.main=0.8, passes=2)
mtext("Tail presence", outer=TRUE)


vignettePlot(tailTree, col, passes=4)
vignettePlot(bodyTree, col, passes=4)
mtext("Tail colour", outer=TRUE)

vignettePlot(tailTree, bcol, FALSE, passes=4)
vignettePlot(bodyTree, bcol, FALSE, passes=4)
mtext("Body colour", outer=TRUE)
```

Where the tail has a single origin (one step), blue colouration also evolves once (zero steps), but body colour must change twice (two steps; total score = three).  But where body colour changes only once (one step), the tail necessarily arises twice (two steps), meaning two independent origins of its distinctive blue colouration (one extra homoplasy; total score = four)

If the invariant tail colour character had not been included, both trees would have the same score, and there would be nothing to choose between them.  As such, the inclusion or exclusion of invariant characters must be carefully evaluated: if there is a case that an invariant (ontologically dependent) character implies an exclusive common ancestry between those taxa that share it, then it should be included; if not, then it should be excluded.

##  Variable but "Parsimony uninformative" characters can inform parsimony

The same effect of course follows if a character has an additional state that is only observed in one taxon.

```{R, echo = FALSE, results='asis'}
tail <- c(0, 0, 0, 0, 1, 1, 1, 1, 1)
col <- c(rep('-', 4), rep(1, 4), 2)
bcol <- c(1,1, 2,2,2,2, 1,1, 1)
blueTails <- matrix(c(tail, col, bcol), byrow=TRUE, ncol=length(tail))
colnames(blueTails) <- LETTERS[seq_along(tail)]
rownames(blueTails) <- c("Tail: (0), absent; (1), present",
                         "Tail colour: (1), blue; (2), red; (-), inapplicable",
                         "Body colour: (1), black; (2), white")
kable(blueTails, capiton="Coding")
```

Any tree that implies that blueness evolves multiple times will incur an additional penalty that would not have been encountered had the tail colour character been omitted.


```{R, echo=FALSE, fig.height=3, fig.width=8}
tailTree <- ape::read.tree(text="((((A, B), C), D), (E, (F, (G, (I, H)))));")
bodyTree <- ape::read.tree(text="((((F, E), C), D), (A, (B, (G, (I, H)))));")
#tail <- "000011111"
col <- "----11112"
#bcol <- "112222111"

par(mfrow=c(1, 2), mar=c(0, 0.2, 0.2, 0.2), oma=c(0, 0, 2, 0), cex=0.8)
vignettePlot(tailTree, col, passes=4, legend.pos='topleft', state.labels = c("", rb))
vignettePlot(bodyTree, col, passes=4, legend.pos='topleft', state.labels = c("", rb))
mtext("Tail colour", outer=TRUE)
```

## This may not be desirable in neomorphic characters

The more general rule is that any tree that reconstructs the same state arising twice,
independently, in an ontologically dependent character will incur a penalty relative to one that reconstructs that same state arising once.

With transformational characters, this is often a desideratum -- as discussed above.

In particular neomorphic characters, however, it will not be desirable to penalise trees in which the absence of a character arises multiple times.

Let us imagine that there is a biological reason to believe that tails in a particular
group lacked poisoned barbs when they first evolved: that is, poisoned barbs are an 
evolutionary innovation that can only be added to a tail once a tail is already present.

```{R, echo = FALSE, results='asis'}
tail <- c(0, 0, 0, 1, 1, 1, 1, 1, 1)
eyespot <- c("-", "-", "-", 0,0,0,0,1,1)

tailEyes <- matrix(c(tail, eyespot), byrow=TRUE, ncol=length(tail))
colnames(tailEyes) <- LETTERS[seq_along(tail)]
rownames(tailEyes) <- c("Tail: (0), absent; (1), present",
                        "Tail barbs: (-), inapplicable; (0), absent; (1), present")
kable(tailEyes, capiton="Coding")
```

### Three scenarios
```{R, echo=FALSE, fig.height=8, fig.width=6}
# Scenarios setup
scenPar <- function () {setPar(c(1, 1)); par(mar=c(1, 0.2, 0.6, 0.2), oma=c(0,1,1,1))}
eap <- c("No poison barbs", "Poison barbs")
splitSpots <- ape::read.tree(text="(((H, C), A), (B, (D, (E, (G, (F, H))))));")
naysHaveIt <- ape::read.tree(text="((((H, I), C), A), (B, (D, (E, (G, F)))));", legend.pos='topleft')
eyesHaveIt <- ape::read.tree(text="(((((H, I), G), C), A), (B, (D, (E, F))));")
#tail <- "000111111"
col <- "---000011"
```

The presence of poison barbs obviously contains grouping information -- a reconstruction that attribute the presence of posion barbs to a single evolutionary gain in a common ancestor is parsimonious with respect to that character (even if it is less parsimonious with respect to another -- e.g. the presence or absence of a tail).

```{R, echo=FALSE, fig.width=6, fig.height=3}
scenPar()
vignettePlot(naysHaveIt, col, state.labels = eap, passes=4, main="One tail with barbs, one without")
```

Consider a reconstruction in which a tail evolved twice, and barbs evolved twice.  Here, the duplicate origin of barbs (as well as the duplicate origin of the tail) makes this reconstruction less parsimonious.

```{R, echo=FALSE, fig.width=6, fig.height=3}
scenPar()
vignettePlot(splitSpots, col, state.labels = eap, passes=4, main="Two barb appearances")
```

But what about a situation in which a tail evolved twice, and lacked barbs each time it evolved?  Coding this character as transformational penalises the duplicate origin of the state "no poison barbs", making this reconstruction less parsimonious.  If we expect a tail, when it evolves, to lack barbs, then the second origin of "no barbs" does not represent a homoplasy: it's not a feature that has evolved twice.  Rather, the absence of poison barbs in the two ancestral tail-bearers has been inherited from a common ancestor that did not itself bear tail barbs (by virtue, as it happens, of not bearing a tail).  This second non-origination should not, therefore, be penalized in this situation.

```{R, echo=FALSE, fig.width=6, fig.height=3}
scenPar()
vignettePlot(eyesHaveIt, col, state.labels = eap, passes=4, main="Two barbless appearances")
```

This problem has arisen because the inapplicable token has been used in a character that is, in fact, applicable.  It makes logical sense to refer to tail poison barbs as absent when the tail is absent, in a way that it does not make logical sense to refer to a tail as being red when a tail is absent.  As such, the 'absence' token should be employed instead of the inapplicable:

```{R, echo = FALSE, results='asis'}
tail <- c(0, 0, 0, 1, 1, 1, 1, 1, 1)
eyespot <- c(0,0,0, 0,0,0,0,1,1)

tailEyes <- matrix(c(tail, eyespot), byrow=TRUE, ncol=length(tail))
colnames(tailEyes) <- LETTERS[seq_along(tail)]
rownames(tailEyes) <- c("Tail: (0), absent; (1), present",
                        "Tail barbs: (0), absent (whether tail present or absent); (1), present")
kable(tailEyes, capiton="Coding")
```

```{R, echo=FALSE, fig.width=6, fig.height=3}
setPar()
par(oma=c(0,0,1.5,0))
vignettePlot(eyesHaveIt, '000011111', state.labels = ap, passes=2, main="Tail")
mtext("Two barbless appearances", outer=TRUE)
vignettePlot(eyesHaveIt, '000000011', state.labels = eap, passes=4, main="Tail with poison barbs")
```

<!--
#### Evaluation
It is possible that a researcher might feel uncomfortable grouping taxa on the basis of the non-occurrence of a complex feature that did not occur in their common ancestor.  Putting this another way, it is not clear that the fact that a feature has not evolved in two instances represents a homoplasy.  The absence of eyespots in a tail is not an evolutionary innovation -- it is an inheritance from a common ancestor that did not have eyespots (and did not have a tail).-->

One implication of this coding strategy is that the loss of a tail (a single evolutionary event) causes the loss of all contintent characters -- characters are not independent.  Whether or not this is desirable could be a matter for debate -- is a reconstruction that invokes the loss of a complex tail more parsimonious than one that invokes the loss of a simple tail?

It would be straightforwards to construct an algorithm that does not penalise losses arising from the loss of a parent character, but perhaps more valuable to think carefully about how existing models of evolution might be adapted to take account of character non-independence.


### Does absence contain phylogenetic information?

In some cases, the absence of a feature (e.g. serrations) may represent a transformational character and should thus be coded as such.  But this decision is an important one and merits careful thought.  A researcher may or may not be justified in including properties of a tail that occur in only one, or even in none, of the taxa of interest, for if absence is informative for parsimony, then such characters will influence tree topology: [parsimony uninformative characters inform
parsimony](CodingData.html).


```{r Glowing in the dark 2, echo = FALSE, results='asis'}
tail <- c(0, 0, 0, 1, 1, 1, 1)
gitd <- c("-", "-", "-", "{01}","{01}",0,0)
elec <- c("-", "-", "-", "{01}","{01}",0,0)

unobserved <- matrix(c(tail, gitd, elec), byrow=TRUE, ncol=length(tail))
colnames(unobserved) <- LETTERS[seq_along(tail)]
rownames(unobserved) <- c("Tail: (0), absent; (1), present",
                        "Tail with glow-in-the-dark pigment: (-), inapplicable; (0), absent; (1), present",
                        "Tail with ability to generate electricity: (-), inapplicable; (0), absent; (1), present")
kable(unobserved, capiton="Coding")
```

Note that each of the unobserved characters provides evidence against independent origins of the tail, preferring instead independent losses:

```{R unobserved character 2, echo=FALSE, fig.height=3.2, fig.width=8}
setPar(c(1, 2))
par(oma=c(1,1,3,1))
better <- ape::read.tree(text="(((F, G), C), (A, (B, (D, E))));")
worse  <- ape::read.tree(text="(((F, C), G), (A, (B, (D, E))));")
col <- "---{01}{01}00"

vignettePlot(better, col, legend.pos='topleft')
mtext("Tail with glow-in-the-dark pigment: (-), inapplicable; (0), absent; (1), present",
      side=3, line=0, outer=TRUE)
vignettePlot(worse, col, legend.pos='topleft')

```

<mark>Thus the simple matrix presented above sees both of these trees as equally parsimonious -- three losses of a single-origin tail that lacks two unlikely attributes is considered as likely as one independent gain of a similar tail.</mark> <!-- I may need to tweak these trees-->

This behaviour is desired if the similarity between the tails requires an evoltuionary explanation.  But the absence of these features does not seem any more difficult to explain if the tails do not have a common ancestor.

The solution here is to deploy a different character coding strategy, coding absences as absences.  That way, absence CAN be inherited from a common ancestor, in which a complex-feature-of-the-tail (eyespots, glow-inthe-dark pigment) was absent (and the tail was absent too).

```{r Glowing in the dark 3, echo = FALSE, results='asis'}

tail <- c(0, 0, 0, 1, 1, 1, 1)
gitd <- c(0, 0,0, "{01}","{01}",0,0)
elec <- c(0,0,0, "{01}","{01}",0,0)

unobserved <- matrix(c(tail, gitd, elec), byrow=TRUE, ncol=length(tail))
colnames(unobserved) <- LETTERS[seq_along(tail)]
rownames(unobserved) <- c("Tail: (0), absent; (1), present",
                        "Tail with glow-in-the-dark pigment: (-), inapplicable; (0), absent; (1), present",
                        "Tail with ability to generate electricity: (-), inapplicable; (0), absent; (1), present")
kable(unobserved, capiton="Coding")
```

This can be handled by the Fitch algorithm, and works well in simple cases:

```{R unobserved character 3, echo=FALSE, fig.height=3, fig.width=8}
par(mfrow=c(1, 2), mar=c(0.2, 0.2, 0.2, 0.2), oma=c(1,0,0,0), cex=0.8)
better <- ape::read.tree(text="(((F, G), C), (A, (B, (D, E))));")
worse  <- ape::read.tree(text="(((F, C), G), (A, (B, (D, E))));")
col <- "000{01}{01}00"

quickPlot(better, col, na=FALSE)
mtext("Tail with glow-in-the-dark pigment: (-), inapplicable; (0), absent; (1), present",
      side=1, line=0, outer=TRUE)
quickPlot(worse, col, na=FALSE)

```

The behaviour only becomes questionable when a tail is secondarily lost, then re-gained, as the loss of a tail seems like it should be a single evolutionary step, but also causes the loss of all contingent characters, which must then "reevolve" as though they had never existed:

```{R loss and gain, echo=FALSE, fig.width=4, fig.height=4}
par(mfrow=c(1, 1), mar=c(0.2, 0.2, 0.2, 0.2), oma=c(1,0,0,0), cex=0.8)
imbal <- ape::read.tree(text="(A, (B, (C, (D, (E, (F, G))))));")
tail <- "1100011"
eyespots <- "1100011"

quickPlot(imbal, eyespots, na=FALSE, legend.pos='topleft')
mtext("Tail eyespots: (0), absent; (1), present", side=1, line=0, outer=TRUE)


```

Perhaps there are cases -- as might be seen in phenotypic plasticity -- where a tail might be lost, and then re-activate preexisting genes when it evolves again?  This starts to require an explicit model of evolution, however, which is somewhat beyond the remit of parsimony.

### Recommendation
- Neomorphic characters should probably be coded as absent everywhere they are absent, whether this is because there's no tail or because there's a tail without the complex feature.



If you're coding a neomorphic character as transformational, then you encounter problems.

```{R Untitled 4, echo=FALSE, fig.height=3, fig.width=6}
setPar()
better <- ape::read.tree(text="(((F, G), C), (A, (B, (D, E))));")
worse  <- ape::read.tree(text="(((F, C), G), (A, (B, (D, E))));")
tail <- "0001111"
col <- "---{01}{01}00"

vignettePlot(better, col)
vignettePlot(worse, col)

mtext(side=1, line=0, "Tail with glow-in-the-dark pigment: (-), inapplicable; (0), absent; (1), present", cex=0.8, outer=TRUE)

```





- <mark> Link to neomorphics </mark>

## How this algorithm weights against multiple innovations

We discussed in an [earlier chapter](FailedSolutions.html) that, if we only 
penalise transformations between states in subsidiary characters, 
trees that imply multiple origins of the parent character receive much lower scores
than those in which the parent character evolves once (but its subsidiary characteristics
change multiple times).

Our algorithm counterbalances this by, in effect, imposing a cost for each additional
origin of the parent character.  At first blush, this sounds like it is weighting
against multiple innovations of the parent character -- but this isn't so; it
weights against multiple independent innovations of the SAME state (i.e. homoplasy),
but if a red tail evolved here and a blue tail evolved there, then two innovations of the 
tail imposes a cost of one (additional region) for tail colour, whereas a single innovation of the tail would also impose a cost of one (transformation) for tail colour.
The additional origin of the tail can

- This has a side-effect that we'll study with an invariant character

[Return to index](Index.html) | [Coding neomorphic characters](Neomorphics.html) | [Coding ambiguous data](AmbiguousData.html)

## References
